%Part{XPACK, Root = "CLM.MSS"}
%Chapter of Common Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{ULTIMATE}

\ifx \rulang\Undef

\chapter{Packages}
\label{XPACK}

One problem with earlier Lisp systems is the use of a single name space
for all symbols.  In large Lisp systems, with modules written by many
different programmers, accidental name collisions become a serious
problem.  Common Lisp addresses this problem through the \emph{package system},
derived from an earlier package system developed for
Lisp Machine Lisp \cite{BLUE-LISPM}.
In addition to preventing name-space conflicts, the
package system makes the modular structure of large Lisp systems more
explicit.

A \emph{package} is a data structure that establishes a mapping from print
names (strings) to symbols.  The package thus replaces the ``oblist'' or
``obarray'' machinery of earlier Lisp systems.  At any given time one
package is current, and this package is used by the Lisp reader in
translating strings into symbols.  The current package is, by definition,
the one that is the
value of the global variable \cdf{*package*}.  It is possible to refer to
symbols in packages other than the current one through the use of
\emph{package qualifiers} in the printed representation of the symbol.
For example, \cd{foo:bar}, when seen by the reader,
refers to the symbol whose name is
\cdf{bar} in the package whose name is \cdf{foo}.
(Actually, this is true only if \cdf{bar} is an external symbol of \cdf{foo},
that is, a symbol that is supposed to be visible outside of \cdf{foo}.
A reference to an internal symbol requires the intentionally
clumsier syntax \cd{foo::bar}.)

The string-to-symbol mappings available in a given package are divided
into two classes, \emph{external} and \emph{internal}.  We refer to the
symbols accessible via these mappings as being \emph{external} and
\emph{internal} symbols of the package in question, though really it is the
mappings that are different and not the symbols themselves.  Within a
given package, a name refers to one symbol or to none; if it does refer
to a symbol, then it is either external or internal in that
package, but not both.

External symbols are part of the package's public interface to other
packages.  External symbols are supposed to be chosen with some care and are
advertised to users of the package.  Internal symbols are for internal
use only, and these symbols are normally hidden from other packages.
Most symbols are created as internal symbols; they become external only
if they appear explicitly in an \cdf{export} command for the package.

A symbol may appear in many packages.  It will always have the same
name wherever it appears, but it may be external in some packages
and internal in others.  On the other hand,
the same name (string) may refer to different symbols in
different packages.

Normally, a symbol that appears in one or more packages
will be \emph{owned} by one particular package, called the \emph{home package}
of the symbol; that package is said to \emph{own} the symbol.
Every symbol has a component called the \emph{package cell}
that contains a pointer to its home package.
A symbol that is owned by some package is said to be \emph{interned}.
Some symbols are not owned by any package; such a symbol
is said to be \emph{uninterned}, and its package cell contains {\false}.

Packages may be built up in layers.  From the point of view of a
package's user, the package is a single collection of mappings from
strings into internal and external symbols.  However, some of these
mappings may be established within the package itself, while other
mappings are inherited from other packages via the \cdf{use-package}
construct.  (The mechanisms responsible for this inheritance are
described below.)  In what follows, we will refer to a symbol as being
\emph{accessible} in a package if it can be referred to
without a package qualifier when that package is current,
regardless of whether the mapping occurs within
that package or via inheritance.   We will refer to a symbol as being
\emph{present} in a package if the mapping is in the package itself and is
not inherited from somewhere else.  Thus a symbol present in a package is accessible,
but an accessible symbol is not necessarily present.

A symbol is said to be \emph{interned in a package} if it is
accessible in that package and also is owned (by either that package
or some other package).  Normally all the symbols accessible in
a package will in fact be owned by some package,
but the terminology is useful when
discussing the pathological case of an accessible but unowned (uninterned)
symbol.

As a verb, to \emph{intern} a symbol in a package means to cause the
symbol to be interned in the package if it was not already;
this process is performed by the function \cdf{intern}.
If the symbol was previously unowned, then the package it is being
interned in becomes its owner (home package); but
if the symbol was previously owned by another package, that other package
continues to own the symbol.

To \emph{unintern} a symbol from the package means to cause it to be not
present in the package
and, additionally, to cause the symbol to be uninterned if the
package was the home package (owner) of the symbol.
This process is performed by the function \cdf{unintern}.

\section{Consistency Rules}

Package-related bugs can be very subtle and confusing: things are not
what they appear to be.  The Common Lisp package system is designed with
a number of safety features to prevent most of the common bugs that
would otherwise occur in normal use.  This may seem over-protective, but
experience with earlier package systems has shown that such safety
features are needed.

In dealing with the package system, it is useful to keep in mind the
following consistency rules, which remain in force as long as the value
of \cdf{*package*} is not changed by the user:

\begin{itemize}
\item
\emph{Read-read consistency:} Reading the same print name always results in
the same (\cdf{eq}) symbol.

\item
\emph{Print-read consistency:} An interned symbol always prints as a
sequence of characters that, when read back in, yields the same (\cdf{eq})
symbol.

\item
\emph{Print-print consistency:} If two interned symbols are not \cdf{eq}, then
their printed representations will be different sequences of
characters.
\end{itemize}

These consistency rules remain true in spite of any amount of implicit
interning caused by typing in Lisp forms, loading files, etc.  This has
the important implication that, as long as the current package
is not changed, results are reproducible regardless of
the order of loading files or the exact history of what symbols were
typed in when.  The rules can only be violated by explicit action:
changing the value of \cdf{*package*}, forcing some action by continuing
from an error, or calling one of the ``dangerous'' functions
\cdf{unintern}, \cdf{unexport}, \cdf{shadow},
\cdf{shadowing-import}, or \cdf{unuse-package}.

\section{Package Names}
\label{PACKAGE-NAMES-SECTION}

Each package has a name (a string) and perhaps some nicknames.  These
are assigned when the package is created, though they can be changed
later.  A package's name should be something long and self-explanatory,
like \cdf{editor}; there might be a nickname that is shorter and easier to
type, such as \cdf{ed}.

There is a single name space for packages.  The function
\cdf{find-package} translates a package name or nickname into the
associated package.  The function \cdf{package-name} returns the name of a
package.  The function \cdf{package-nicknames} returns a list of all
nicknames for a package.  The function \cdf{rename-package} removes a
package's current name and nicknames and replaces them with new ones
specified by the user.  Package renaming is occasionally useful when, for
development purposes, it is desirable to load two versions of a package
into the same Lisp.  One can load the first version, rename it,
and then load the other version, without getting a lot of name conflicts.

When the Lisp reader sees a qualified symbol, it handles the package-name
part in the same way as the symbol part with respect to capitalization.
Lowercase characters in the package name are converted to corresponding
uppercase characters
unless preceded by the escape character \cd{{\Xbackslash}} or
surrounded by \cd{|} characters.  The lookup done by the
\cdf{find-package} function is case-sensitive, like that done for
symbols.  Note that \cd{|Foo|:|Bar|} refers to a symbol whose name is
\cdf{Bar} in a package whose name is \cdf{Foo}.  By contrast,
\cd{|Foo:Bar|} refers to a seven-character symbol that has a colon in its name
(as well as two uppercase letters and four lowercase letters)
and is interned in the current package.  Following the convention used
in this book for symbols, we show ordinary package names using
lowercase letters, even though the name string is internally represented
with uppercase letters.

Most of the functions that require a package-name argument from the
user accept either a symbol or a string.  If a symbol is supplied,
its print name will be used; the print name will already have undergone
case-conversion by the usual rules.  If a string is supplied, it
must be so capitalized as to match exactly the
string that names the package.

\begin{new}
X3J13 voted in January 1989
\issue{PACKAGE-FUNCTION-CONSISTENCY}
to clarify that one may use either a package object or
a package name (symbol or string) in any of the following
situations:
\begin{itemize}
\item the \cd{:use} argument to \cdf{make-package}
\item the first argument to \cdf{package-use-list}, \cdf{package-used-by-list},
\cdf{package-name}, \cdf{package-nicknames},
\cdf{in-package}, \cdf{find-package},
\cdf{rename-package}, or \cdf{delete-package},

\item the second argument to \cdf{intern}, \cdf{find-symbol},
\cdf{unintern}, \cdf{export}, \cdf{unexport}, \cdf{import}, \cdf{shadowing-import},
or \cdf{shadow}
\item the first argument, or a member of the list that is the first argument,
to \cdf{use-package} or \cdf{unuse-package}
\item the value of the \emph{package} given to \cdf{do-symbols},
\cdf{do-external-symbols}, or \cdf{do-all-symbols}
\item a member of the \emph{package-list} given to \cdf{with-package-iterator}
\end{itemize}
Note that the first argument to \cdf{make-package} must still be a package
name and not an actual package; it makes no sense to create an already
existing package.  Similarly, package nicknames must always be expressed
as package names and not as package objects.  If \cdf{find-package} is
given a package object instead of a name, it simply returns that package.
\end{new}

\section{Translating Strings to Symbols}
\label{STRING-TO-SYMBOL-SECTION}

The value of the special variable \cdf{*package*} must always be a package
object (not a name).  Whatever package object is currently the
value of \cdf{*package*} is referred to as the \emph{current package}.

When the Lisp reader has, by parsing, obtained a string of characters
thought to name a symbol, that name is looked up in the current package.
This lookup may involve looking in other packages whose external symbols
are inherited by the current package.  If the name is found,
the corresponding symbol is returned.  If the name is not found
(that is, there is no symbol of that name accessible in the current package),
a new symbol is created for it and is placed in the current package as an
internal symbol.  Moreover, the current package becomes the owner
(home package) of the symbol, and so the symbol becomes interned
in the current package.
If the name is later read again while this same package is
current, the same symbol will then be found and returned.

Often it is desirable to refer to an external symbol in some package
other than the current one.  This is done through the use of a
\emph{qualified name}, consisting of a package name, then a colon, then the
name of the symbol.  This causes the symbol's name to be looked up
in the specified package, rather than in the current one.  For example,
\cd{editor:buffer} refers to the external symbol named \cdf{buffer}
accessible in the package named \cdf{editor}, regardless of whether
there is a symbol named \cdf{buffer} in the current package.  If there
is no package named \cdf{editor}, or if no symbol named \cdf{buffer}
is accessible in \cdf{editor}, or if \cdf{buffer} is an internal
symbol in \cdf{editor}, the Lisp reader will signal
a correctable error to ask the user for instructions.

On rare occasions, a user may need to refer to an \emph{internal} symbol of
some package other than the current one.  It is illegal to do this with
the colon qualifier, since accessing an internal symbol of some other
package is usually a mistake.  However, this operation is legal if
a doubled colon
\cd{::} is used as the separator in place of the usual single colon.  If
\cd{editor::buffer} is seen, the effect is exactly the same as
reading \cdf{buffer} with \cdf{*package*} temporarily rebound to the
package whose name is \cdf{editor}.  This special-purpose qualifier
should be used with caution.

The package named \cdf{keyword} contains all keyword symbols used by the
Lisp system itself and by user-written code.  Such symbols must be
easily accessible from any package, and name conflicts are not an issue
because these symbols are used only as labels and never to carry
package-specific values or properties.  Because keyword symbols are used
so frequently, Common Lisp provides a special reader syntax for them.
Any symbol preceded by a colon but no package name (for example
\cd{:foo}) is added to (or looked up in) the \cdf{keyword} package as
an \emph{external} symbol.  The \cdf{keyword} package is also treated
specially in that whenever a symbol is added to the \cdf{keyword} package
the symbol is always made external; the symbol
is also automatically declared to be a constant
(see \cdf{defconstant}) and made to
have itself as its value.  This is why every keyword evaluates to
itself.  As a matter of style, keywords should always be accessed using
the leading-colon convention; the user should never import or inherit
keywords into any other package.  It is an error to try to apply
\cdf{use-package} to the \cdf{keyword} package.

Each symbol contains a package cell that is used to record the home
package of the symbol, or {\false} if the symbol is uninterned.  This cell
may be accessed by using the function \cdf{symbol-package}.
When an interned
symbol is printed, if it is a symbol in the keyword package,
then it is printed with a preceding colon; otherwise, if it is accessible
(directly or by inheritance) in the current package, it is printed
without any qualification; otherwise, it is printed with the name of the
home package as the qualifier, using \cd{:} as the separator if the
symbol is external and \cd{::} if not.

A symbol whose package slot contains {\false} (that is, has no home
package)
is printed preceded by \cd{\#:}.  It is possible, by the
use of \cdf{import} and \cdf{unintern}, to create a symbol that has no
recorded home package but that in fact is accessible in some package.
The system does not check for this pathological case, and such symbols
will always be printed preceded by \cd{\#:}.

In summary, the following four uses of symbol qualifier syntax are defined.

\begin{flushdesc}
\item[\cd{foo:bar}]
When read, looks up \cd{BAR} among the external symbols of
the package named \cd{FOO}.  Printed when symbol \cd{bar} is external in its
home package \cd{foo} and is not accessible in the current package.

\item[\cd{foo::bar}]
When read, interns \cd{BAR} as if \cd{FOO} were the
current package.  Printed when symbol \cd{bar} is internal in its home package
\cd{foo} and is not accessible in the current package.

\item[\cd{:bar}]
When read, interns \cd{BAR} as an external symbol in the
\cd{keyword} package and makes it evaluate to itself.  Printed when
the home package of symbol \cd{bar} is \cd{keyword}.
    
\item[\cd{\#:bar}]
When read, creates a new uninterned symbol named \cd{BAR}.
Printed when the symbol \cd{bar} is uninterned (has no home package),
even in the pathological case that \cd{bar} is uninterned but
nevertheless somehow accessible in the current package.
\end{flushdesc}

All other uses of colons within names of symbols are not defined by
Common Lisp but are reserved for implementation-dependent use; this
includes names that end in a colon, contain two or more colons, or
consist of just a colon.

\section{Exporting and Importing Symbols} 
\label{EXPORT-IMPORT-SECTION}

Symbols from one package may be made accessible in another package in
two ways.

First, any individual symbol may be added to a package by use
of the function \cdf{import}.  The form \cd{(import 'editor:buffer)} takes
the external symbol named \cdf{buffer} in the \cdf{editor} package (this
symbol was located when the form was read by the Lisp reader) and adds
it to the current package as an internal symbol.  The symbol is then
present in the current package.  The imported symbol is
not automatically exported from the current package, but if it is
already present and external, then the fact that it
is external is not changed.  After the call to
\cdf{import} it is possible to refer to \cdf{buffer} in the importing package
without any qualifier.  The status of \cdf{buffer} in the package named
\cdf{editor} is unchanged, and \cdf{editor} remains the home package for
this symbol.  Once imported, a symbol is \emph{present} in the
importing package and can be removed only by calling \cdf{unintern}.

If the symbol is already present in the importing package, \cdf{import}
has no effect.  If a distinct symbol with the name \cdf{buffer} is
accessible in the importing package (directly or by inheritance), then a
correctable error is signaled, as described in
section~\ref{NAME-CONFLICTS-SECTION}, because \cdf{import} avoids letting
one symbol shadow another.

A symbol is said to be \emph{shadowed} by another symbol in
some package if the first symbol would be accessible by inheritance
if not for the presence of the second symbol.
To import a symbol without the possibility
of getting an
error because of shadowing,
use the function \cdf{shadowing-import}.  This inserts
the symbol into the specified package as an internal symbol, regardless
of whether another symbol of the same name will be shadowed by this
action.
If a different symbol of the same name is already present
in the package, that symbol will first be uninterned from the package
(see \cdf{unintern}).  The new symbol is
added to the package's shadowing-symbols list.  \cdf{shadowing-import}
should be used with caution.  It changes the state of the package system
in such a way that the consistency rules do not hold across the change.

The second mechanism is provided by the function \cdf{use-package}.  This
causes a package to inherit all of the external symbols of some other
package.  These symbols become accessible as \emph{internal} symbols of the
using package.  That is, they can be referred to without a qualifier
while this package is current, but they are not passed along to any
other package that uses this package.  Note that \cdf{use-package},
unlike \cdf{import}, does not cause any new symbols to be \emph{present}
in the current package but only makes them \emph{accessible} by inheritance.
\cdf{use-package} checks carefully for
name conflicts between the newly imported symbols and those already
accessible in the importing package.  This is described in detail in
section~\ref{NAME-CONFLICTS-SECTION}.

Typically a user, working by default in the \cdf{user} package, will
load a number of packages into Lisp to provide an augmented working
environment, and then call \cdf{use-package} on each of these packages
to allow easy access to their external symbols.
\cdf{unuse-package} undoes the effects of a previous \cdf{use-package}.  The
external symbols of the used package are no longer inherited.  However,
any symbols that have been imported into the using package continue to
be present in that package.

There is no way to inherit the \emph{internal} symbols of another package;
to refer to an internal symbol, the user must either make that symbol's home
package current, use a qualifier, or import that symbol into the current
package.

The distinction between
external and internal symbols is a primary means of hiding names
so that one program does not tread on the namespace of another.

When \cdf{intern} or some other function wants to look up a symbol in a
given package, it first looks for the symbol among the external and
internal symbols of the package itself; then it looks through the
external symbols of the used packages in some unspecified order.  The
order does not matter; according to the rules for handling name
conflicts (see below), if conflicting symbols appear in two or more
packages inherited by package \emph{X}, a symbol of this name must also appear
in \emph{X} itself as a shadowing symbol.  Of course, implementations are free
to choose other, more efficient ways of implementing this search, as
long as the user-visible behavior is equivalent to what is described
here.

The function \cdf{export} takes a symbol that is accessible in some
specified package (directly or by inheritance) and makes it an external
symbol of that package.  If the symbol is already accessible as an
external symbol in the package, \cdf{export} has no effect.  If the symbol
is directly present in the package as an internal symbol, it is simply
changed to external status.  If it is accessible as an internal symbol
via \cdf{use-package}, the symbol is first imported into the package, then
exported.  (The symbol is then present in the specified package
whether or not the package
continues to use the package through which the symbol was originally
inherited.)  If the symbol is not
accessible at all in the specified package, a correctable error is
signaled that, upon continuing, asks the user whether the symbol
should be imported.

The function \cdf{unexport} is provided mainly as a way to undo erroneous
calls to \cdf{export}.  It works only on symbols directly present
in the current package, switching them back to internal status.  If
\cdf{unexport} is given a symbol already accessible as an internal
symbol in the current package, it does nothing; if it is given a symbol
not accessible in the package at all, it signals an error.

\section{Name Conflicts}
\label{NAME-CONFLICTS-SECTION}

A fundamental invariant of the package system is that within one package
any particular name can refer to at most one symbol.  A \emph{name conflict}
is said to occur when there is more than one candidate symbol and it is
not obvious which one to choose.  If the system does not always choose
the same way, the read-read consistency rule would be violated.  For
example, some programs or data might have been read in under a certain
mapping of the name to a symbol.  If the mapping changes to a different
symbol, and subsequently additional programs or data are read,
then the two programs will
not access the same symbol even though they use the same name.  Even if
the system did always choose the same way, a name conflict is likely to
result in a mapping from names to symbols different from what was expected by
the user, causing programs to execute incorrectly.  Therefore, any time
a name conflict is about to occur,
an error is signaled.  The user may continue
from the error and tell the package system how to resolve the conflict.

It may be that the same symbol is accessible to a package through more than
one path.  For example, the symbol might be
an external symbol of more than one used package, or the symbol
might be directly present in a package and also inherited from
another package.
In such cases there is no name conflict.
The same identical symbol cannot conflict with itself.
Name conflicts occur only between distinct symbols with
the same name.

The creator of a package can tell the system in advance how to resolve a
name conflict through the use of \emph{shadowing}.  Every package has a
list of shadowing symbols.  A shadowing symbol takes precedence over any
other symbol of the same name that would otherwise be accessible to the
package.  A name conflict involving a shadowing symbol is always
resolved in favor of the shadowing symbol, without signaling an error
(except for one instance involving \cdf{import} described below).  The
functions \cdf{shadow} and \cdf{shadowing-import} may be used to declare
shadowing symbols.

Name conflicts are detected when they become possible, that is, when the
package structure is altered.  There is no need to check for name
conflicts during every name lookup.

The functions \cdf{use-package}, \cdf{import}, and \cdf{export} check for name
conflicts.  \cdf{use-package} makes the external symbols of the package
being used accessible to the using package; each of these symbols is
checked for name conflicts with the symbols already accessible.
\cdf{import} adds a single symbol to the internals of a package, checking
for a name conflict with an existing symbol either present in the
package or accessible to it.  \cdf{import} signals a name conflict error
even if the conflict is with a shadowing symbol, the rationale being
that the user has given two explicit and inconsistent directives.
\cdf{export} makes a single
symbol accessible to all the packages that use the package from which
the symbol is exported.  All of these packages are checked for
name conflicts:  \cd{(export \emph{s} \emph{p})} does
\cd{(find-symbol (symbol-name \emph{s}) \emph{q})} for each package \emph{q}
in \cd{(package-used-by-list \emph{p})}.  Note that in the usual case of
an \cdf{export} during the initial definition of a package, the
result of \cdf{package-used-by-list}
will be {\false} and the name-conflict checking
will take negligible time.

The function \cdf{intern}, which is the one used most
frequently by the Lisp reader for looking up names of symbols,
does not need to do any name-conflict checking, because it
never creates a new symbol if there is already an accessible symbol with
the name given.

\cdf{shadow} and \cdf{shadowing-import} never signal a name-conflict error
because the user, by calling these functions, has specified how any
possible conflict is to be resolved.  \cdf{shadow} does name-conflict
checking to the extent that it checks whether a distinct existing symbol with
the specified name is accessible and, if so, whether it is directly
present in the package or inherited.  In the latter case, a new symbol
is created to shadow it.  \cdf{shadowing-import} does name-conflict
checking to the extent that it checks whether a distinct existing
symbol with the same name is accessible; if so, it is shadowed by
the new symbol, which implies that it must be uninterned
if it was directly present in the package.

\cdf{unuse-package}, \cdf{unexport}, and \cdf{unintern} (when the symbol being
uninterned is not a shadowing symbol) do not need to do any
name-conflict checking because they only remove symbols from a package;
they do not make any new symbols accessible.

Giving a shadowing symbol to \cdf{unintern} can uncover a name conflict that had
previously been resolved by the shadowing.  If package A uses packages
B and C, A contains a shadowing symbol \cdf{x}, and B and C each contain external
symbols named \cdf{x}, then removing the shadowing symbol \cdf{x}
from A will reveal a name
conflict between \cd{b:x} and \cd{c:x} if those two symbols are distinct.
In this case \cdf{unintern} will signal an error.

Aborting from a name-conflict error leaves the original symbol accessible.
Package functions always signal name-conflict errors before making any
change to the package structure.  When multiple changes are to be made,
however, for example when \cdf{export} is given a list of symbols, it is
permissible for the implementation to process each change separately,
so that aborting from a name
conflict caused by the second symbol in the list will not unexport the
first symbol in the list.  However, aborting from a name-conflict error
caused by \cdf{export} of a single symbol will not leave that symbol accessible
to some packages and inaccessible to others; with respect to
each symbol processed, \cdf{export}
behaves as if it were an atomic operation.

Continuing from a name-conflict error should offer the user a chance to
resolve the name conflict in favor of either of the candidates.  The
package structure should be altered to reflect the resolution of the
name conflict, via \cdf{shadowing-import}, \cdf{unintern}, or \cdf{unexport}.

A name conflict in \cdf{use-package} between a symbol directly present in the
using package and an external symbol of the used package may be resolved
in favor of the first symbol by making it a shadowing symbol, or in favor
of the second symbol by uninterning the first symbol from the using
package.  The latter resolution is dangerous if the symbol to be
uninterned is an external symbol of the using package, since it
will cease to be an external symbol.

A name conflict in \cdf{use-package} between two external symbols inherited
by the using package from other packages may be resolved in favor of
either symbol by importing it into the using package and making it a
shadowing symbol.

A name conflict in \cdf{export} between the symbol being exported and a
symbol already present in a package that would inherit the
newly exported symbol may be resolved in favor of the exported symbol
by uninterning the other one, or in favor of the already-present
symbol by making it a shadowing symbol.

A name conflict in \cdf{export} or \cdf{unintern} due to a package
inheriting two distinct symbols with the same name from two other
packages may be resolved in favor of either symbol by importing it into
the using package and making it a shadowing symbol, just as with
\cdf{use-package}.

A name conflict in \cdf{import} between the symbol being imported and a
symbol inherited from some other package may be resolved in favor of the
symbol being imported by making it a shadowing symbol, or in favor
of the symbol already accessible by not doing the \cdf{import}.  A
name conflict in \cdf{import} with a symbol already present in the
package may be resolved by uninterning that symbol, or by not
doing the \cdf{import}.

Good user-interface style dictates that \cdf{use-package} and \cdf{export},
which can cause many name conflicts simultaneously, first check for
all of the name conflicts before presenting any of them to the user.
The user may then choose to resolve all of them wholesale or to resolve
each of them individually, the latter requiring a lot of
interaction but permitting
different conflicts to be resolved different ways.

Implementations may offer other ways of resolving name conflicts.
For instance, if the symbols that conflict are not being used as
objects but only as names for functions, it may be possible to ``merge''
the two symbols by putting the function definition onto both symbols.
References to either symbol for purposes of calling a function would be
equivalent.  A similar merging operation can be done for variable values
and for things stored on the property list.  In Lisp Machine Lisp, for example, one can
also \emph{forward} the value, function, and property cells so that future
changes to either symbol will propagate to the other one.  Some other
implementations are able to do this with value cells but not with
property lists.  Only the user can know whether this way of resolving
a name conflict is adequate, because it will work only if
the use of two non-\cdf{eq}
symbols with the same name will not prevent the correct operation of
the program.  The value of offering symbol merging as a way of resolving
name conflicts is that it can avoid the need to throw away the whole
Lisp world, correct the package-definition forms
that caused the error, and start over from scratch.

\section{Built-in Packages}

\begin{flushdesc}
\item[\cdf{common-lisp}]
The package named \cdf{common-lisp} contains the primitives of the
ANSI Common Lisp system (as opposed to a Common Lisp system based
on the 1984 specification).  Its external symbols include all of the
user-visible functions and global variables that are present in the
ANSI Common Lisp system, such as \cdf{car}, \cdf{cdr}, and \cdf{*package*}.
Note, however, that the home package of such symbols is not
necessarily the \cdf{common-lisp} package (this makes it easier for
symbols such as \cdf{t} and \cdf{lambda} to be shared between
the \cdf{common-lisp} package and another package, possibly one named \cdf{lisp}).
Almost all other packages ought to use \cdf{common-lisp} so that these
symbols will be accessible without qualification.
This package has the nickname \cdf{cl}.

\item[\cdf{common-lisp-user}]
The \cdf{common-lisp-user} package is, by default,
the current package at the time an ANSI Common Lisp system starts up.
This package uses the \cdf{common-lisp} package
and has the nickname \cdf{cl-user}.
It may contain other implementation-dependent symbols
and may use other implementation-specific packages.

\item[\cdf{keyword}]
This package contains all of the keywords used by built-in
or user-defined Lisp functions.  Printed symbol representations
that start with a colon are interpreted as referring to symbols
in this package, which are always external symbols.  All symbols in this
package are treated as constants that evaluate to themselves, so that the
user can type \cd{:foo} instead of \cd{':foo}.
\end{flushdesc}

\begin{new}
X3J13 voted in January 1989
\issue{PACKAGE-CLUTTER}
to modify the requirements on the built-in packages
so as to limit what may appear in the \cdf{common-lisp} package
and to lift the requirement that every implementation have a package
named \cdf{system}.  The details are as follows.

Not only must the \cdf{common-lisp} package in any given implementation
contain all the external symbols prescribed by the standard;
the \cdf{common-lisp} package moreover may not contain any external symbol
that is not prescribed by the standard.  However, the \cdf{common-lisp}
package may contain additional internal symbols, depending on the
implementation.

An external symbol of the \cdf{common-lisp} package may not have a function,
macro, or special operator definition, or a top-level value,
or a \cdf{special} proclamation, or a type definition, unless specifically
permitted by the standard.  Programmers may validly rely on this fact;
for example, \cdf{fboundp} is guaranteed to be false for all
external symbols of the \cdf{common-lisp} package except those explicitly
specified in the standard to name functions, macros, and special operators.
Similarly, \cdf{boundp} will be false of all such external symbols
except those documented to be variables or constants.

Portable programs
may use external symbols in the \cdf{common-lisp} package that are not documented
to be constants or variables as names of local lexical
variables with the presumption that the implementation has not
proclaimed such variables to be special; this legitimizes the common
practice of using such names as \cdf{list} and \cdf{string} as names
for local variables.

A valid implementation may initially have properties on any symbol,
or dynamically put new properties on symbols (even user-created symbols),
as long as no property indicator used for this purpose is
an external symbol of any package defined by the standard
or a symbol that is accessible from the \cdf{common-lisp-user} package or any
package defined by the user.

This vote eliminates the requirement that every implementation have
a predefined package named \cdf{system}.  An implementation may
provide any number of predefined packages; these should be described
in the documentation for that implementation.

The \cdf{common-lisp-user} package may contain symbols not described by the standard
and may use other implementation-specific packages.
\end{new}

\begin{newer}
X3J13 voted in March 1989 \issue{LISP-SYMBOL-REDEFINITION}
to restrict user programs from performing certain actions that
might interfere with built-in facilities or interact badly
with them.
Except where explicitly allowed, the consequences are undefined if any
of the following actions are performed on a symbol in the \cdf{common-lisp}
package.
\begin{itemize}
\item binding or altering its value (lexically or dynamically)
\item defining or binding it as a function
\item defining or binding it as a macro
\item defining it as a type specifier (\cdf{defstruct}, \cdf{defclass}, \cdf{deftype})
\item defining it as a structure (\cdf{defstruct})
\item defining it as a declaration
\item design it as a symbol macro FIXME
\item altering its print name
\item altering its package
\item tracing it
\item declaring or proclaiming it special or lexical
\item declaring or proclaiming its \cdf{type} or \cdf{ftype}
\item removing it from the package \cdf{common-lisp}
\end{itemize}
X3J13 also voted in June 1989 \issue{DEFINE-COMPILER-MACRO}
to add to this list the item
\begin{itemize}
\item defining it as a compiler macro
\end{itemize}

If such a symbol is not globally defined as a variable or a constant,
a user program is allowed to lexically bind it and declare the \cdf{type} of
that binding.

If such a symbol is not defined as a function, macro, or special operator,
a user program is allowed to (lexically) bind it as a function and to declare the
\cdf{ftype} of that binding and to trace that binding.

If such a symbol is not defined as a function, macro, or special operator,
a user program is allowed to (lexically) bind it as a macro.

As an example, the behavior of the code fragment
\begin{lisp}
(flet ((open (filename \&key direction) \\*
~~~~~~~~~(format t "{\Xtilde}\%OPEN was called.")  \\*
~~~~~~~~~(open filename :direction direction))) \\*
~~(with-open-file (x "frob" :direction ':output)  \\*
~~~~(format t "{\Xtilde}\%Was OPEN called?")))
\end{lisp}
is undefined.  Even in a ``reasonable'' implementation,
for example, the macro expansion of \cdf{with-open-file} might refer
to the \cdf{open} function and might not.  However, the preceding rules eliminate
the burden of deciding whether an implementation is reasonable. The code
fragment violates the rules; officially its behavior is therefore
completely undefined, and that's that.

Note that ``altering the property list'' is not in the list of
proscribed actions, so a user program \emph{is} permitted to
add properties to or remove properties from
symbols in the \cdf{common-lisp} package.
\end{newer}

\section{Package System Functions and Variables}
\label{PACKAGE-FUNCTIONS-SECTION}

\beforenoterule
\begin{implementation}
In the past, some Lisp compilers have read
the entire file into Lisp before processing any of the forms.  
Other compilers have arranged for
the loader to do all of its intern operations before evaluating any of the
top-level forms.  Neither of these techniques will work in a
straightforward way in Common Lisp because of the presence of multiple
packages.
\end{implementation}
\afternoterule

For the functions described here, all optional arguments named
\emph{package} default to the current value of \cdf{*package*}.  Where a
function takes an argument that is either a symbol or a list of symbols,
an argument of {\false} is treated as an empty list of symbols.  Any
argument described as a package name may be either a string or a symbol.
If a symbol is supplied, its print name will be used as the package
name; if a string is supplied, the user must take care to specify the
same capitalization used in the package name, normally all uppercase.

\begin{defun}[Variable]
*package*

The value of this variable must be a package; this package is said to be
the current package.  The initial value of \cdf{*package*} is the \cdf{user}
package.

The functions \cdf{load} and \cdf{compile-file} rebind \cdf{*package*} to its current value.  If
some form in the file changes the value of \cdf{*package*} during loading or
compilation, the old value will be restored when the loading is completed. 
\end{defun}

\begin{defun}[Function]
make-package package-name &key :nicknames :use

This creates and returns a new package with the specified package name.  As
described above, this argument may be either a string or a symbol.  The
\cd{:nicknames} argument must be a list of strings to be used as
alternative names for the package.  Once again, the user may supply
symbols in place of the strings, in which case the print names of the
symbols are used.  These names and nicknames must not conflict with
any existing package names; if they do, a correctable error is
signaled.

The \cd{:use} argument is a list of packages or the names (strings or
symbols) of packages whose external symbols are to be inherited by the
new package.  These packages must already exist.  If not supplied,
\cd{:use} defaults to a list of one package, the \cdf{lisp} package.
\end{defun}

\begin{defmac}
in-package name

This macro causes \cdf{*package*} to be set to the package named \emph{name},
    which must be a symbol or string.  The \emph{name} is not evaluated.
    An error is signaled if the
    package does not already exist.  Everything this macro does is also
    performed at compile time if the call appears at top level.

\cdf{in-package} returns the new package, that is, the
value of \cdf{*package*} after the operation has been executed.
\end{defmac}

\begin{defun}[Function]
find-package name

The \emph{name} must be a string that is the name or nickname for a
package.  This argument may also be a symbol, in which case the symbol's
print name is used.  The package with that name or nickname
is returned; if no such package exists, \cdf{find-package} returns {\false}.
The matching of names observes case (as in \cdf{string=}).

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
package-name package

The argument must be a package.  This function returns the string that
names that package.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).

\cdf{package-name} returns \cdf{nil} instead of the package if the package has been
removed. See \cdf{delete-package}.
\end{defun}

\begin{defun}[Function]
package-nicknames package

The argument must be a package.  This function returns the list of
nickname strings for that package, not including the primary name.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
rename-package package new-name &optional new-nicknames

The old name and all of the old nicknames of \emph{package} are eliminated
and are replaced by \emph{new-name} and \emph{new-nicknames}.  The
\emph{new-name} argument is a string or symbol; the \emph{new-nicknames}
argument, which defaults to {\false}, is a list of strings or symbols.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
package-use-list package

A list of other packages used by the argument package is returned.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
package-used-by-list package

A list of other packages that use the argument package is returned.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
package-shadowing-symbols package

A list is returned of symbols that have been declared as shadowing
symbols in this package by \cdf{shadow} or \cdf{shadowing-import}.  All
symbols on this list are present in the specified package.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
list-all-packages 

This function returns a list of all packages that currently exist in the
Lisp system.
\end{defun}

\begin{defun}[Function]
delete-package package

The \cdf{delete-package} function 
deletes the specified \emph{package} from all package system data structures.
The \emph{package} argument may be either a package or the name of a package.

If \emph{package} is a name but there is currently no package of that name,
a correctable error is signaled.  Continuing from the error makes
no deletion attempt but merely returns \cdf{nil} from the call to
\cdf{delete-package}.

If \emph{package} is a package object that has already been deleted,
no error is signaled and no deletion is attempted; instead,
\cdf{delete-package} immediately returns \cdf{nil}.

If the package specified for deletion is currently used by other packages,
a correctable error is signaled.  Continuing from this error,
the effect of the function \cdf{unuse-package} is performed on all
such other packages so as to remove their dependency on the
specified package, after which \cdf{delete-package} proceeds to
delete the specified package as if no other package had been using it.

If any symbol had the specified package as its home package before
the call to \cdf{delete-package}, then its home package is unspecified
(that is, the contents of its package cell are unspecified)
after the \cdf{delete-package} operation has been completed.
Symbols in the deleted package are not modified in any other way.

The name and nicknames of the \emph{package} cease to be recognized package
names.  The package object is still a package, but anonymous; \cdf{packagep} will
be true of it, but \cdf{package-name} applied to it will return \cdf{nil}.

The effect of any other package operation on a deleted package object
is undefined.  In particular, an attempt to locate a symbol within a
deleted package (using \cdf{intern} or \cdf{find-symbol}, for example)
will have unspecified results.

\cdf{delete-package} returns \cdf{t} if the deletion succeeds,
and \cdf{nil} otherwise.
\end{defun}

\begin{defun}[Function]
intern string &optional package

The \emph{package}, which defaults to the current package, is
searched for a symbol with the name specified by the \emph{string}
argument.  This search will include inherited symbols, as described
in section~\ref{EXPORT-IMPORT-SECTION}.
If a symbol with the specified name is found, it is returned.
If no such symbol is found, one is created and is installed in the
specified package as an internal symbol (as an external symbol
if the package is the \cdf{keyword} package); the specified package becomes the
home package of the created symbol.

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to specify that \cdf{intern} may in effect perform the
search using a copy of the argument string in which
some or all of the implementation-defined
attributes have been removed from the characters of the string.
It is implementation-dependent which attributes are removed.
\end{newer}

Two values are returned.  The first is the symbol that was found or
created.  The second value is {\false} if no pre-existing symbol was found,
and takes on one of three values if a symbol was found:
\begin{indentdesc}{6pc}
\item[\cd{:internal}]
The symbol was directly present in the package as an internal symbol.

\item[\cd{:external}]
The symbol was directly present as an external symbol.

\item[\cd{:inherited}]
The symbol was inherited via \cdf{use-package} (which
implies that the symbol is internal).
\end{indentdesc}

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
find-symbol string &optional package

This is identical to \cdf{intern}, but it never creates a new symbol.  If
a symbol with the specified name is found in the specified package,
directly or by inheritance, the symbol found is returned as the first
value and the second value is as specified for \cdf{intern}.  If the
symbol is not accessible in the specified package, both values are
{\false}.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
unintern symbol &optional package

If the specified symbol is present in the specified \emph{package}, it is
removed from that package and also from the package's shadowing-symbols
list if it is present there.  Moreover, if the \emph{package} is the home
package for the symbol, the symbol is made to have no home package.
Note that in some circumstances the symbol may continue to be accessible
in the specified package by inheritance.
\cdf{unintern} returns {\true} if it actually removed a symbol,
and {\false} otherwise.

\cdf{unintern} should be used with caution.  It changes the state of the
package system in such a way that the consistency rules do not hold
across the change.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
export symbols &optional package

The \emph{symbols} argument should be a list of symbols, or possibly a single
symbol.  These symbols become accessible as external symbols in
\emph{package} (see section~\ref{EXPORT-IMPORT-SECTION}).
\cdf{export} returns {\true}.

By convention, a call to \cdf{export} listing all exported symbols is
placed near the start of a file to advertise which of the symbols
mentioned in the file are intended to be used by other programs.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
unexport symbols &optional package

The \emph{symbols} argument should be a list of symbols, or possibly a single symbol.
These symbols become internal symbols in \emph{package}.
It is an error to unexport a symbol from the \cdf{keyword} package
(see section~\ref{EXPORT-IMPORT-SECTION}).
\cdf{unexport} returns {\true}.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
import symbols &optional package

The argument should be a list of symbols, or possibly a single symbol.
These symbols become internal symbols in \emph{package} and can therefore
be referred to without having to use qualified-name (colon) syntax.
\cdf{import} signals a
correctable error if any of the imported symbols has the same name as
some distinct symbol already accessible in the package
(see section~\ref{EXPORT-IMPORT-SECTION}).
\cdf{import} returns {\true}.

If any symbol to be imported has no home package
then \cdf{import} sets the home package of the symbol to the
\emph{package} to which the symbol is being imported.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
shadowing-import symbols &optional package

This is like \cdf{import}, but it does not signal an error even if the
importation of a symbol would shadow some symbol already accessible in
the package.  In addition to being imported, the symbol is placed on the
shadowing-symbols list of \emph{package}
(see section~\ref{NAME-CONFLICTS-SECTION}).
\cdf{shadowing-import} returns {\true}.

\cdf{shadowing-import} should be used with
caution.  It changes the state of the package system in such a way that
the consistency rules do not hold across the change.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
shadow symbols &optional package

The argument should be a list of symbols, or possibly a single symbol.
The print name of each symbol is extracted, and the specified \emph{package} is
searched for a symbol of that name.  If such a symbol is present in this
package (directly, not by inheritance), then nothing is done.  Otherwise,
a new symbol is created with this print name, and it is inserted in the
\emph{package} as an internal symbol.  The symbol is also placed on the
shadowing-symbols list of the \emph{package}
(see section~\ref{NAME-CONFLICTS-SECTION}).
\cdf{shadow} returns {\true}.

\cdf{shadow} should be used with
caution.  It changes the state of the package system in such a way that
the consistency rules do not hold across the change.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
use-package packages-to-use &optional package

The \emph{packages-to-use} argument should be a list of packages or package
names, or possibly a single package or package name.  These packages are
added to the use-list of \emph{package} if they are not there already.  All
external symbols in the packages to use become accessible in \emph{package}
as internal symbols
(see section~\ref{EXPORT-IMPORT-SECTION}).
It is an error to try to use the \cdf{keyword} package.
\cdf{use-package} returns {\true}.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
unuse-package packages-to-unuse &optional package

The \emph{packages-to-unuse} argument should be a list of packages or
package names, or possibly a single package or package name.  These
packages are removed from the use-list of \emph{package}.
\cdf{unuse-package} returns {\true}.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defmac}
defpackage defined-package-name {option}*

This creates a new package, or modifies an existing one, whose name
is \emph{defined-package-name}.  The \emph{defined-package-name}
may be a string or a symbol;
if it is a symbol, only its print name matters, and not what package, if any,
the symbol happens to be in.
The newly created or modified package is returned as the value of
the \cdf{defpackage} form.

Each standard \emph{option} is a list of a keyword (the name of the option)
and associated arguments.  No part of a \cdf{defpackage} form is evaluated.
Except for the \cd{:size} option, more than one option of the same
kind may occur within the same \cdf{defpackage} form.

The standard options for \cdf{defpackage} are as follows.
In every case, any option argument called \emph{package-name}
or \emph{symbol-name}
may be a string or a symbol;
if it is a symbol, only its print name matters, and not what package, if any,
the symbol happens to be in.

\begin{flushdesc}
\item[\cd{(:size \emph{integer})}]
This specifies approximately the number of symbols expected to be in the
package.  This is purely an efficiency hint to the storage allocator,
so that implementations using hash tables as part
of the package data structure (the usual technique) will not
have to incrementally expand the package as new symbols are added to it
(for example, as a large file is read while ``in'' that package).

\item[\cd{(:nicknames \Mstar\emph{package-name})}]
The specified names become nicknames of the package being defined.
If any of the specified nicknames already refers to an existing
package, a continuable error is signaled exactly as for the
function \cdf{make-package}.

\item[\cd{(:shadow \Mstar\emph{symbol-name})}]
Symbols with the specified names are created as shadows
in the package being defined, just as with the function \cdf{shadow}.

\item[\cd{(:shadowing-import-from \emph{package-name} \Mstar\emph{symbol-name})}]
Symbols with the specified names are located in the specified package.
These symbols are imported into the package being defined, shadowing
other symbols if necessary, just as with the function \cdf{shadowing-import}.
In no case will symbols be created in a package other than
the one being defined;
a continuable error is signaled if for any \emph{symbol-name} there
is no symbol of that name accessible in the package named \emph{package-name}.

\item[\cd{(:use \Mstar\emph{package-name})}]
The package being defined is made to ``use'' (inherit from)
the packages specified by this option, just as with
the function \cdf{use-package}.
If no \cd{:use} option is supplied, then option is unspecified.

\item[\cd{(:import-from \emph{package-name} \Mstar\emph{symbol-name})}]
Symbols with the specified names are located in the specified package.
These symbols are imported into the package being defined,
just as with the function \cdf{import}.
In no case will symbols be created in a package other than
the one being defined;
a continuable error is signaled if for any \emph{symbol-name} there
is no symbol of that name accessible in the package named \emph{package-name}.

\item[\cd{(:intern \Mstar\emph{symbol-name})}]
Symbols with the specified names are located or created
in the package being defined, just as with the function
\cdf{intern}.  Note that the action of this option may be
affected by a \cd{:use}
option, because an inherited symbol will be used in preference
to creating a new one.

\item[\cd{(:export \Mstar\emph{symbol-name})}]
Symbols with the specified names are located or created
in the package being defined and then exported, just as with the function
\cdf{export}.  Note that the action of this option may be
affected by a \cd{:use}, \cd{:import-from}, or \cd{:shadowing-import-from}
option, because an inherited or imported symbol will be used in preference
to creating a new one.
\end{flushdesc}

The order in which options appear in a \cdf{defpackage} form does not matter;
part of the convenience of \cdf{defpackage} is that it sorts out the options
into the correct order for processing.
Options are processed in the following order:
\begin{tabbing}
1.~~\cd{:shadow} and \cd{:shadowing-import-from} \\
2.~~\cd{:use} \\
3.~~\cd{:import-from} and \cd{:intern} \\
4.~~\cd{:export}
\end{tabbing}
Shadows are established first in order to avoid spurious name conflicts
when use links are established.  Use links must occur before importing
and interning so that those operations may refer to normally inherited
symbols rather than creating new ones.  Exports are performed last so that
symbols created by any of the other options, in particular,
shadows and imported symbols, may be exported.  Note that exporting an
inherited symbol implicitly imports it first
(see section~\ref{EXPORT-IMPORT-SECTION}).

If no package named \emph{defined-package-name} already exists,
\cdf{defpackage} creates it.  If such a package does already exist,
then no new package is created.  The existing package is
modified, if possible, to reflect the new definition.  The results are
undefined if the new definition is not consistent with the current
state of the package.

An error is signaled if more than one \cd{:size} option appears.
Если опция \cd{:size} указана более одного раза сигнализируется ошибка.

An error is signaled if the same \cdf{symbol-name} argument (in the sense
of comparing names with \cdf{string=}) appears more than once among
the arguments to all the \cd{:shadow}, \cd{:shadowing-import-from},
\cd{:import-from}, and \cd{:intern} options.

An error is signaled if the same \cdf{symbol-name} argument (in the sense
of comparing names with \cdf{string=}) appears more than once among
the arguments to all the \cd{:intern} and \cd{:export} options.

Other kinds of name conflicts are handled in the same manner that
the underlying operations \cdf{use-package}, \cdf{import}, and \cdf{export}
would handle them.

Implementations may support other \cdf{defpackage} options.
Every implementation should signal an error on encountering
a \cdf{defpackage} option it does not support.

The function \cdf{compile-file} should treat top-level \cdf{defpackage}
forms in the same way it would treat top-level calls to package-affecting
functions (as described at the beginning of
section~\ref{PACKAGE-FUNCTIONS-SECTION}).

Here is an example of a call to \cdf{defpackage} that ``plays it safe''
by using only strings as names.
\begin{lisp}
(cl:defpackage "MY-VERY-OWN-PACKAGE" \\*
~~(:size 496) \\*
~~(:nicknames "MY-PKG" "MYPKG" "MVOP") \\*
~~(:use "COMMON-LISP") \\
~~(:shadow "CAR" "CDR") \\*
~~(:shadowing-import-from "BRAND-X-LISP" "CONS") \\*
~~(:import-from "BRAND-X-LISP" "GC" "BLINK-FRONT-PANEL-LIGHTS") \\*
~~(:export "EQ" "CONS" "MY-VERY-OWN-FUNCTION"))
\end{lisp}
The preceding \cdf{defpackage} example is designed to operate correctly
even if the package current when the form is read happens not to
``use'' the \cdf{common-lisp} package.  (Note the use in this example
of the nickname \cdf{cl} for the \cdf{common-lisp} package.)
Moreover, neither reading in nor evaluating
this \cdf{defpackage} form will ever create any symbols in the
current package.  Note too the use of uppercase letters in the strings.

Here, for the sake of contrast, is a rather similar use of
\cdf{defpackage} that ``plays the whale'' by using all sorts of
permissible syntax.
\begin{lisp}
(defpackage my-very-own-package \\*
~~(:export :EQ common-lisp:cons my-very-own-function) \\*
~~(:nicknames "MY-PKG" \#:MyPkg) \\*
~~(:use "COMMON-LISP") \\
~~(:shadow "CAR") \\*
~~(:size 496) \\*
~~(:nicknames mvop) \\
~~(:import-from "BRAND-X-LISP" "GC" Blink-Front-Panel-Lights) \\
~~(:shadow common-lisp::cdr) \\*
~~(:shadowing-import-from "BRAND-X-LISP" CONS))
\end{lisp}
This example has exactly the same effect on the newly created package
but may create useless symbols in other packages.
The use of explicit package tags is particularly confusing;
for example, this \cdf{defpackage} form will cause the symbol
\cdf{cdr} to be shadowed \emph{in the new package}; it will not be
shadowed in the package \cdf{common-lisp}.  The fact that the name ``\cdf{CDR}''
was specified by a package-qualified reference to a symbol in the
\cdf{common-lisp} package is a red herring.
The moral is that the syntactic flexibility of \cdf{defpackage},
as in other parts of Common Lisp,
yields considerable convenience when used with commonsense competence,
but unutterable confusion when used with Malthusian profusion.

\beforenoterule
\begin{implementation}
An implementation of \cdf{defpackage} might choose to transform
all the \emph{package-name} and \emph{symbol-name} arguments
into strings at macro expansion time, rather than at the time
the resulting expansion is executed, so that even if source code
is expressed in terms of strange symbols in the \cdf{defpackage} form,
the binary file resulting from compiling the source code would
contain only strings.  The purpose of this is simply to minimize
the creation of useless symbols in production code.  This technique
is permitted as an implementation strategy but is not a
behavior required by the specification of \cdf{defpackage}.
\end{implementation}
\afternoterule

Note that \cdf{defpackage} is not capable by itself of defining
mutually recursive packages, for example two packages each of
which uses the other.  However, nothing prevents one from using
\cdf{defpackage} to perform much of the initial setup and then
using functions such as \cdf{use-package}, \cdf{import}, and \cdf{export}
to complete the links.

The purpose of \cdf{defpackage} is to encourage the user to
put the entire definition of a package and its relationships to
other packages in a single place.  It may also encourage the designer
of a large system to place the definitions of all relevant packages
into a single file (say) that can be loaded before loading or compiling
any code that depends on those packages.  Such a file, if carefully
constructed, can simply be loaded into the \cdf{common-lisp-user} package.

Implementations and programming environments may also be better able
to support the programming process (if only by providing better
error checking) through global knowledge of the intended package setup.
\end{defmac}

\begin{defun}[Function]
find-all-symbols string-or-symbol

\cdf{find-all-symbols}
searches every package in the Lisp system to find
every symbol whose print name is the
specified string.  A list of all such symbols found is returned.
This search is case-sensitive.
If the argument is a symbol, its print name supplies
the string to be searched for.
\end{defun}

\begin{defmac}
do-symbols (var [package [result-form]])
           {declaration}* {tag | statement}*

\cdf{do-symbols} provides straightforward iteration over the symbols of a
package.  The body is performed once for each symbol accessible in the
\emph{package}, in no particular order, with the variable \emph{var} bound to
the symbol.  Then \emph{result-form} (a single form, \emph{not} an implicit
\cdf{progn}) is evaluated, and the result is the value of the
\cdf{do-symbols} form.  (When the \emph{result-form} is evaluated, the control
variable \emph{var} is still bound and has the value {\false}.)  If the
\emph{result-form} is omitted, the result is {\false}.  \cdf{return} may be used
to terminate the iteration prematurely.  If execution of the body affects
which symbols are contained in the \emph{package}, other than possibly to
remove the symbol currently the value of \emph{var} by using \cdf{unintern},
the effects are unpredictable.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).

\begin{new}
X3J13 voted in March 1988
\issue{DO-SYMBOLS-DUPLICATES}
to specify that the body of a \cdf{do-symbols}
form may be executed more than once for the same accessible symbol, and users
should take care to allow for this possibility.

The point is that the same symbol might be accessible via more than one
chain of inheritance, and it is implementationally costly to eliminate
such duplicates.  Here is an example:
\begin{lisp}
(setq *a* (make-package 'a))~~~~~~;\textrm{Implicitly uses package \cdf{common-lisp}} \\*
(setq *b* (make-package 'b))~~~~~~;\textrm{Implicitly uses package \cdf{common-lisp}} \\*
(setq *c* (make-package 'c :use '(a b))) \\
\\
(do-symbols (x *c*) (print x))~~~~;\textrm{Symbols in package \cdf{common-lisp}} \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;~\textrm{might be printed once or twice here}
\end{lisp}

X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\begin{new}
Note that the \cdf{loop} construct provides a kind of \cdf{for} clause that
can iterate over the symbols of a package (see chapter~\ref{LOOP}).
\end{new}
\end{defmac}

\begin{defmac}
do-external-symbols (var [package [result]])
                    {declaration}* {tag | statement}*

\cdf{do-external-symbols} is just like \cdf{do-symbols}, except that only
the external symbols of the specified package are scanned.

\begin{new}
The clarification voted by X3J13
in March 1988 for \cdf{do-symbols}
\issue{DO-SYMBOLS-DUPLICATES},
regarding redundant executions of the body for the same symbol,
applies also to \cdf{do-external-symbols}.
\end{new}

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defmac}

\begin{defmac}
do-all-symbols (var [result-form])
               {declaration}* {tag | statement}*

This is similar to \cdf{do-symbols} but executes the body once for every
symbol contained in every package.  (This will not process every symbol
whatsoever, because a symbol not accessible in any package will not
be processed.  Normally, uninterned symbols are not accessible in any package.)
It is \emph{not} in general
the case that each symbol is processed only once, because a symbol may
appear in many packages.

\begin{new}
The clarification voted by X3J13
in March 1988 for \cdf{do-symbols}
\issue{DO-SYMBOLS-DUPLICATES},
regarding redundant executions of the body for the same symbol,
applies also to \cdf{do-all-symbols}.
\end{new}

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defmac}

\begin{defmac}
with-package-iterator (mname package-list {symbol-type}+)
                      {form}*

The name \emph{mname} is bound and defined as if by \cdf{macrolet},
with the body \emph{form\/}s as its lexical scope, to be a ``generator macro''
such that each invocation of \cd{(\emph{mname})} will
return a symbol and that successive invocations
will eventually deliver, one by one, all the symbols
from the packages that are elements of the list that is the value of the
expression \emph{package-list} (which is evaluated exactly once).

Each element of the \emph{package-list} value
may be either a package or the name of a package.
As a further convenience, if the \emph{package-list} value
is itself a package or the name of a package, it is treated
as if a singleton list containing that value had been provided.
If the \emph{package-list} value is \cdf{nil}, it is considered
to be an empty list of packages.

At each invocation of the generator macro, there are two possibilities.
If there is yet another unprocessed symbol, then
four values are returned: \cdf{t}, the symbol,
a keyword
indicating the accessibility of the symbol within the package (see below), and
the package from which the symbol was accessed.
If there are no more unprocessed symbols in the
list of packages, then one value is returned: \cdf{nil}.

When the generator macro returns a symbol as its second value, the
fourth value is always one of the packages present or named in the
\emph{package-list} value, and the third value is a keyword indicating
accessibility:
\cd{:internal} means present in the package and not exported;
\cd{:external} means present and exported;
and \cd{:inherited} means not present (thus not shadowed) but inherited
from some package used by the package that is the fourth value.

Each \emph{symbol-type} in an invocation of \cdf{with-package-iterator}
is not evaluated.  More than one may be present; their order does not
matter.  They indicate the accessibility types of interest.
A symbol is not returned by the generator macro unless its actual
accessibility matches one of the \emph{symbol-type} indicators.
The standard \emph{symbol-type} indicators are \cd{:internal},
\cd{:external}, and \cd{:inherited}, but implementations are permitted
to extend the syntax of \cdf{with-package-iterator} by recognizing
additional symbol accessibility types.  An error is signaled
if no \emph{symbol-type} is supplied, or if any supplied \emph{symbol-type}
is not recognized by the implementation.

The order in which symbols are produced by successive invocations
of the generator macro is not necessarily correlated in any way
with the order of the packages in the \emph{package-list}.
When more than one package is in the \emph{package-list},
symbols accessible from more than one package may be produced
once or more than once.  Even when only one package is specified,
symbols inherited in multiple ways via used packages may be
produced once or more than once.

The implicit interior state of the iteration over the list of packages
and the symbols within them has dynamic extent.
It is an error to invoke the generator macro
once the \cdf{with-package-iterator} form has been exited.

Any number of invocations of \cdf{with-package-iterator}
and related macros may be nested, and the generator macro of an
outer invocation may be called from within an inner invocation
(provided, of course, that its name is visible or otherwise made available).

X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.

\beforenoterule
\begin{rationale}
This facility is a bit more flexible in some ways than \cdf{do-symbols}
and friends.
In particular, it makes it possible to implement \cdf{loop}
clauses for iterating over packages in a way that is both portable
and efficient (see chapter~\ref{LOOP}).
\end{rationale}
\afternoterule
\end{defmac}

%RUSSIAN
\else

\chapter{Пакеты}
\label{XPACK}

В ранних реализациях Lisp'а для всех символов использовалось одно
пространство имён. В больших Lisp'овых системах, с модулями,
написанными разными программистами, случайные совпадения имён стали
серьёзной проблемой. Common Lisp решает эту проблему с помощью
\emph{системы пакетов}, производной от системы пакетов, разработанной
для Lisp Machine \cite{BLUE-LISPM}. Кроме того система пакетов делает
модульную структуру больших Lisp систем более явной.

\emph{Пакет} --- это структура данных, которая устанавливает связь
между именами символов (строковый тип) и самими символами. Во время
работы только один пакет является \emph{текущим}, и этот пакет
используется Lisp'овым считывателем для преобразовании строк-имён
символов в сами символы. Текущий пакет храниться в глобальной
переменной \cdf{*package*}. С помощью \emph{имени пакета} в имени
символа существует возможность ссылаться на символы других пакетов.
Например, когда Common Lisp'ом будет прочтено имя \cd{foo:bar}, то оно
будет ссылаться на символ \cd{bar} из пакета \cd{foo}.  (Но при
условии, что \cd{bar} является экспортированным символом из \cd{foo},
то есть символом, который является видимым извне пакета
\cd{foo}. Ссылка на внутренний символ требует удваивания двоеточия:
\cd{foo::bar}.)

Связь символов и их имён, доступных в данном пакете, делится на два
вида: \emph{внешняя} и \emph{внутренняя}. Речь будет идти о символах
доступных с помощью этих связей, как о \emph{внешних} или
\emph{внутренних} символах пакета, хотя на самом деле различаются
связи, а не символы. Внутри заданного пакета имя ссылается максимум
на один символ. Если оно ссылается на символ, тогда этот символ в
данном пакете является или внешним, или внутренним.

Внешние символы являются частью интерфейса пакета, доступного для
других пакетов. Внешние символы должны быть аккуратно спроектированы и
предоставлены для пользователей этого пакета. Внутренние символы
предусмотрены только для внутреннего использования, и эти символы
обычно скрыты от других пакетов. Большинство символов создаются как
внутренние. Они становятся внешними, только если явно передаются в
команду \cdf{export}. Таким образом внешние символы это то же, что и
экспортированные функции и переменные в других языках, поэтому внешние
символы иногда будут называться экспортированными от имени функции
\cdf{export}.

Символ может встречаться во многих пакетах. Он будет всегда иметь одно
и то же имя, но в некоторых пакетах он может быть внешним (если его
экспортировали), а в других внутренним. С другой стороны, одно и то же
имя символа (строка) может ссылаться на различные символы в различных
пакетах.

Обычно, символ, который встречается в одном и более пакетах, будет иметь только
один родительский пакет, называемый \emph{домашний пакет} символа. Говорится,
что такой пакет содержит данный символ.
Все символы содержат свойство, называемое \emph{ячейка пакета}, которое хранит
указатель на домашний пакет.
Символ, который имеет домашний пакет, называется \emph{пакетным}.
Некоторые символы не имеют домашнего пакета. Они называются
\emph{беспакетными}. Их ячейка пакета содержит значение {\false}.

Пакеты могут быть представлены как слои. С этой точки зрения, для пользователя
пакет выглядит как коллекция связей имён с внутренними и внешними
символами. Некоторые из этих связей могут устанавливаться внутри
самого пакета. Другие связи наследуются из других пакетов с
помощью конструкции \cdf{use-package}. (Механизм такого наследования описан
ниже.) В дальнейшем, мы будем называть символ \emph{доступным} в пакете, если
на него можно сослаться без указания имени пакета, вне зависимости от
того унаследована ли связь символов с именем или установлена текущим пакетом. И
мы будем называть символ \emph{родным} в пакете, если связь установлена
самим пакетом, а не унаследована. Таким образом, \emph{родной} символ в пакете
является \emph{доступным}, но \emph{доступный} символ не обязательно является
\emph{родным}.

Символ называется \emph{пакетным}, если он доступен в этом
пакете и имеет некоторый родительский пакет. Обычно все символы
доступные в пакете будут в собственности некоторого пакета, но иногда
описываются случаи доступности никому не принадлежащего (\emph{беспакетного})
символа.

<<\emph{Пакетировать} символ!>> означает сделать так, чтобы
пакет стал владельцем символа, если до этого было не так.
Этот процесс выполняется функцией \cdf{intern}.
Если символ прежде был бесхозным (никому не принадлежал), тогда пакет становится
его владельцем (домашним пакетом). Но если символ уже принадлежал кому-то, то
домашний пакет не меняется.

<<\emph{Лишить} символ пакета>> означает убрать его из пакета. Данный
процесс выполняется функцией \cdf{unintern}. FIXME

\section{Правила согласованности}

Ошибки связанные с пакетами могут быть очень тонкими и
запутанными. Для предотвращения большинства распространённых ошибок,
которые могли бы быть при обычном использовании, система пакетов
Common Lisp'а спроектирована с рядом безопасных мер. Может показаться,
что такая защита избыточна, однако опыт предыдущих систем пакетов
показал, что такие меры необходимы.

При работе с системой пакетов, полезно держать в памяти следующие правила.
Эти правила остаются в силе, пока пользователь не изменил значение \cdf{*package*}.

\begin{itemize}
\item \emph{Согласованность чтения-чтения:} Чтение одного и того же
  имени приводит к одному и тому же символу (\cdf{eq} вернёт истину).

\item \emph{Согласованность вывода-чтения:} Пакетный символ
  всегда выводится как последовательность строковых символов, которые
  при повторном чтении дают исходный символ (\cdf{eq} вернёт истину).

\item \emph{Согласованность вывода-вывода:} Если два пакетных
  символа не равны \cdf{eq}, тогда и их имена будут разными.
\end{itemize}

Эти правила согласованности остаются в силе, несмотря на любое
количество неявных случаев пакетирования символов в Lisp'овых формах,
загрузках файлов и так далее. Пока текущий пакет не меняется,
согласованность сохраняется вне зависимости от порядка загрузки файлов
или истории вводимых символов. Правила могут быть нарушены только
явным действием: изменением значения \cdf{*package*}, продолжением
выполнения после ошибки, или вызовом одной из <<опасных>> функций
\cdf{unintern}, \cdf{unexport}, \cdf{shadow}, \cdf{shadowing-import}
или \cdf{unuse-package}.

\section{Имена пакетов}
\label{PACKAGE-NAMES-SECTION}

Каждый пакет имеет имя (строку) и, возможно, несколько
псевдонимов. Они указываются при создании пакета, и могут быть
изменены позднее. Имя пакета должно быть длинным и информативным,
например \cdf{editor}. Псевдоним должен быть коротким и простым в
написании, например \cdf{ed}.

Для имен пакетов существует только одно пространство имён. Функция
\cdf{find-package} транслирует имя или псевдоним пакета в объект
пакета. Функция \cdf{package-name} возвращает имя пакета. Функция
\cdf{package-nicknames} возвращает список всех псевдонимов для
пакета. Функция \cdf{rename-package} заменяет текущее имя пакета и
псевдонимы на указанные пользователем. Переименование пакета редко
бывает полезным, но один из случаев, например, для разработки, когда
необходимо загрузить две версии одного пакета в Lisp систему. Можно
загрузить первую версию, переименовать её, и затем загрузить другую
версию, без разрешения конфликтов имён.

Когда Lisp'овый считыватель встречает полное имя символа, он
обрабатывает часть имени пакета, также как и часть имени символа,
возводя все неэкранированные буквы в верхний регистр. Экранирование
букв производится с помощью символов \cd{{\Xbackslash}} или
\cd{|}. Поиск, осуществляемый функцией \cdf{find-package}, является
регистрозависимым, также как и для символов. Следует отметить, что
\cd{|Foo|:|Bar|} ссылается на символ, имя которого \cd{Bar}, в пакете
\cd{Foo}. Для сравнения \cd{|Foo:Bar|} ссылается на семизначный
символ, имя которого содержит двоеточие (а также две заглавные и
четыре прописные буквы) и символ принадлежит текущему пакету. В данной
книге символы и пакеты указываются без экранирования строковыми
символами только в нижнем регистре, при этом внутри Lisp машины они
будут переведены в верхний регистр.

Большинство функций, которые принимают имя пакета, могут принимать или
символ, или строку. Если указан символ, то используется его имя,
которое подвергается обычным преобразованиям в верхний регистр. Если
указана строка, то она должна быть заранее преобразована для полного
совпадения с именем пакета.

\begin{new}
X3J13 voted in January 1989
\issue{PACKAGE-FUNCTION-CONSISTENCY}
to clarify that one may use either a package object or
a package name (symbol or string) in any of the following
situations:
\begin{itemize}
\item the \cd{:use} argument to \cdf{make-package}
\item the first argument to \cdf{package-use-list}, \cdf{package-used-by-list},
\cdf{package-name}, \cdf{package-nicknames},
\cdf{in-package}, \cdf{find-package},
\cdf{rename-package}, or \cdf{delete-package},

\item the second argument to \cdf{intern}, \cdf{find-symbol},
\cdf{unintern}, \cdf{export}, \cdf{unexport}, \cdf{import}, \cdf{shadowing-import},
or \cdf{shadow}
\item the first argument, or a member of the list that is the first argument,
to \cdf{use-package} or \cdf{unuse-package}
\item the value of the \emph{package} given to \cdf{do-symbols},
\cdf{do-external-symbols}, or \cdf{do-all-symbols}
\item a member of the \emph{package-list} given to \cdf{with-package-iterator}
\end{itemize}
Note that the first argument to \cdf{make-package} must still be a package
name and not an actual package; it makes no sense to create an already
existing package.  Similarly, package nicknames must always be expressed
as package names and not as package objects.  If \cdf{find-package} is
given a package object instead of a name, it simply returns that package.
\end{new}

В некоторых местах можно использовать как имя пакета (символ или
строку), так и сам объект:

\begin{itemize}
\item аргумент \cd{:use} для \cdf{make-package},

\item первый аргумент для \cdf{package-use-list},
  \cdf{package-used-by-list}, \cdf{package-name},
  \cdf{package-nicknames}, \cdf{in-package}, \cdf{find-package},
  \cdf{rename-package} или \cdf{delete-package},

\item второй аргумент для \cdf{intern}, \cdf{find-symbol},
  \cdf{unintern}, \cdf{export}, \cdf{unexport}, \cdf{import},
  \cdf{shadowing-import} или \cdf{shadow},

\item первый аргумент, или элемент списка, который является первым
  аргументов для \cdf{use-package}, \cdf{unuse-package},

\item значение аргумента \emph{package} для \cdf{do-symbols},
  \cdf{do-external-symbols} или \cdf{do-all-symbols}.

\item элемент списка \emph{package-list} переданного в
  \cdf{with-package-iterator}.
\end{itemize}

Заметьте, что первый аргумент для \cdf{make-package} должен быть
именем пакета, а не самим пакетом, так как нет смысла создавать уже
созданный пакет. Также и псевдонимы пакета не могут быть объектами
пакета. Если \cdf{find-package} получает объект пакета, а не его имя,
она просто возвращает этот объект.

\section{Преобразование строк в символы}
\label{STRING-TO-SYMBOL-SECTION}

Значение специальной переменной \cdf{*package*} должно быть всегда объектом
пакета (не именем). Данный объект называется \emph{текущим пакетом}.

Когда Lisp'овый считыватель получает строку для символа, он ищет его
по имени в текущем пакете.  Данный поиск может привести к поиску в
других пакетах, экспортированные символы которых унаследованы текущим
пакетом. Если имя найдено, то возвращается соответствующий
символ. Если имя не найдено (то есть, в текущем пакете не существует
соответствующего доступного символа), то создаётся новый символ и
помещается в текущий пакет. Если точнее, то текущий пакет становится
владельцем (домашним пакетом) символа.  Если это имя будет прочитано
ещё раз позже и в этом же пакете, то будет возвращён уже созданный
символ.

Часто необходимо сослаться на внешний символ в некотором другом, не текущем
пакете. Это может быть сделано с помощью \emph{полного имени}, включающем имя
пакета, затем двоеточие, и, наконец, имя символа. Это приводит к поиску символа
в указанном, а не текущем пакете. Например, \cd{editor:buffer} ссылается на
внешний символ с именем \cdf{buffer} доступный из пакета с именем \cdf{editor},
вне зависимости от того, есть ли в текущем пакете символ с таким же именем.
Если пакета с именем \cdf{editor} или символа с именем \cdf{buffer} в указанном
пакете не сущетсвует, Lisp'овый считыватель сигнализирует исправимую ошибку.

В редких случаях пользователь может нуждаться в ссылке на
\emph{внутренний} символ некоторого не текущего пакета. Это нельзя
сделать с помощью двоеточия, так как данная запись позволяет ссылаться
только на внешние (экспортированный) символы. Однако, это можно
сделать с помощью двойного двоеточия \cd{::}, указанного вместо
одинарного. Если используется \cd{editor::buffer}, то эффект такой же,
как если бы произошла попытка найти символ с именем \cdf{buffer} и
\cdf{*package*} была связана с пакетом \cd{editor}. Двойное
двоеточие должно использоваться с осторожностью.

Пакет с именем \cdf{keyword} содержит все ключевые символы
используемые Lisp'овой системой и пользовательским кодом. Такие
символы должны быть легко доступны из любого пакета, и конфликт имён
не является проблемой, так как эти символы используются только в
качестве меток и не содержат значений. Так как ключевые символы
используются часто, то для них Common Lisp предоставляет специальный
синтаксис. Любой символ с двоеточием в начале и без имени пакета
(например \cd{:foo}) добавляется (или ищется) в пакете \cdf{keyword}
как \emph{внешний} символ. Пакет \cdf{keyword} также отличается тем,
что при добавлении в него символа, последний автоматически становится
внешним. Символ также автоматически декларируется как константа
(смотрите \cdf{defconstant}) и его значением становится он сам.  В
целях хорошего стиля, ключевые символы должны быть всегда доступны с
помощью двоеточия в начале имени. Пользователь никогда не должен
импортировать или наследовать ключевые символы в другие
пакеты. Попытка использовать \cdf{use-package} для пакета
\cdf{keyword} является ошибкой.

Каждый символ содержит ячейку пакета, которая используется для записи
домашнего пакета символа, или {\false}, если символ беспакетный. Эта
ячейка доступна с помощью функции \cdf{symbol-package}.  Когда
пакетный символ выводится в поток, если это символ в пакете ключевых
символов \cdf{keyword}, тогда он выводится с двоеточием в начале,
иначе, если он доступен (напрямую или унаследовано) в текущем пакете,
он выводится без имени пакета, иначе он выводится полностью, с
именем пакета, именем символа и \cd{:} в качестве разделителя для
внешнего символа, и \cd{::} для внутреннего.

Символ, у которого слот (ячейка) пакета содержит {\false} (то есть, домашний
пакет отсутствует) печатается с \cd{\#:} в начале имени. С использованием
\cdf{import} и \cdf{unintern} возможно создать символ, который не имеет
домашнего пакета, но фактически доступен в некоторых пакетах.
Lisp система не проверяет такие патологические случаи, и такие символы будут
всегда печататься с предшествующими \cd{\#:}.

В целом, синтаксис имён символов может быть выражен в следующих четырёх примерах.

\begin{flushdesc}
\item[\cd{foo:bar}] При прочтении, выполняется поиск символа \cd{BAR}
  среди внешних символов пакета \cd{FOO}. При выводе, когда символ
  \cd{bar} является внешним (экспортированным) в домашнем пакете
  \cd{foo} и недоступен в текущем пакете.

\item[\cd{foo::bar}] При прочтении, пакетирует символ \cd{BAR}, как
  если бы пакет \cd{FOO} являлся текущим. При выводе, когда символ
  \cd{bar} является внутренним в его домашнем пакете \cd{foo} и
  недоступен в текущем пакете.

\item[\cd{:bar}] При прочтении, пакетирует \cd{BAR} как внешний символ
  в пакете \cd{keyword} и выполняет его самого в себя. При выводе,
  когда \cd{keyword} является домашним пакетом для символа.

\item[\cd{\#:bar}] При прочтении, создаёт новый беспакетный символ с
  именем \cd{BAR}.  При выводе, когда символ \cd{bar} не имеет
  домашнего пакета.
\end{flushdesc}

Все другие использования двоеточия внутри имен символов не определены Common
Lisp'ом, но зарезервированы для реализаций. Сюда включены имена с двоеточием в
конце, или содержащими два и более двоеточиях или просто состоящими из
двоеточия.

\section{Экспортирование и импортирование символов} 
\label{EXPORT-IMPORT-SECTION}

Символы из одного пакета могут стать доступными в другом пакете двумя способами.

Первый способ, каждый отдельный символ может быть добавлен в пакет с
использованием функции \cdf{import}. Форма \cd{(import
  'editor:buffer)} принимает внешний символ с именем \cd{buffer} в
пакете \cd{editor} (этот символ распознаётся Lisp'овым считывателем) и
добавляет его в текущий пакет в качестве внутреннего символа. Символ
становится \emph{доступным} в текущем пакете. Импортированный символ
автоматически не экспортируется из текущего пакета, но если он уже
существовал в пакете и был внешним, то это свойство не меняется. После
вызова \cdf{import} в импортирующем пакете появляется возможность
ссылаться на \cdf{buffer} без указания полного имени. Свойства
\cdf{buffer} в пакете \cdf{editor} не меняются, \cdf{editor}
продолжает оставаться домашним пакетом для этого символа. Будучи
импортированным, символ будет присутствовать в пакете и может быть
удалён только с помощью вызова \cdf{unintern}.

Если символ уже присутствует в импортирующем пакете, \cdf{import}
ничего не делает. Если другой символ с таким же именем \cdf{buffer}
уже доступен в импортирующем пакете (напрямую или унаследован), тогда
сигнализируется исправимая ошибка, как написано в
разделе~\ref{NAME-CONFLICTS-SECTION}. \cdf{import} не допускает
сокрытия одного символа другим.

Символ называется скрытым другим символом в некотором пакете, когда первый
символ был бы доступен через наследование, если бы не присутствие второго
символа.
Для импортирования символа без ошибки скрытия, используйте функцию
\cdf{shadowing-import}. Она вставляет символ в указанный пакет, как внутренний
символ, вне зависимости от того, происходит ли скрытие другого символа с тем же
именем.
Если другой символ с тем же именем присутствовал в пакете, тогда этот символ
сначала удаляется из пакета \cdf{unintern}. Новый символ добавляется в список
скрывающих символов FIXME. \cdf{shadowing-import} должна использоваться
аккуратно. Она изменяет состояние системы пакетов так, что правила согласованности
могут перестать работать.

Второй способ предоставляется функцией \cdf{use-package}. Эта функция делает
так, что пакет наследует все внешние символы некоторого другого пакета. Эти
символы становятся доступными, как \emph{внутренние} символы, используемого
пакета. То есть, на них можно ссылаться без указания пакета внутри текущего
пакета, но они не становятся доступными в других пакетах, использующих
данный. Следует отметить, что \cdf{use-package}, в отличие от \cdf{import}, не
делает новые символы \emph{родственными} в текущем пакете, а делает их только
\emph{доступными} с помощью наследования связи символов с именами.
\cdf{use-package} проверяет конфликты имен между импортируемыми и уже доступными
символами в импортирующем пакете. Это подробнее описано в
разделе~\ref{NAME-CONFLICTS-SECTION}.

Обычно пользователь, по-умолчанию работая в пакете
\cdf{common-lisp-user}, будет загружать ряд пакетов в Lisp систему для
предоставления расширенного рабочего окружения, и затем вызывать
\cdf{use-package} для каждого из этих пакетов для простого доступа к
их внешним символами. \cdf{unuse-package} производит обратные
действия относительно \cdf{use-package}. Внешние символы используемые
пакетом перестают наследоваться. Однако, любые импортированные
символы, остаются доступными.

Не существует способа наследовать \emph{внутренние} символы другого пакета. Для
ссылки на внутренний символ, пользователь должен поменять домашний пакет для
данного символа на текущий, или использовать полное имя (вместе с пакетом), или
импортировать этот символ в текущий пакет.

Различие между внешними и внутренними символами прежде всего означает скрытие
имён, так чтобы одна программа не могла использовать пространство имён другой
программы.

Когда \cdf{intern} или некоторые другие функций хотят найти символ в заданном
пакете, они сначала ищут символ среди внешних и внутренних символов текущего
пакета, затем они в неопределённом порядке ищут среди внешних символов
используемых пакетов. Порядок не имеет значение. В соответствии с правилами
разрешения конфликтов имён (смотрите ниже), если конфликтующие символы существуют
в двух и более пакетах, унаследованных пакетом \emph{X}, символ с этим именем
должен также быть в \emph{X}, как скрывающий символ. Конечно, реализации могут
выбрать другой, более эффективный способ для реализации такого поиска, не
изменяя поведение ранее описанного интерфейса.

Функция \cdf{export} принимает символ, который доступен в некотором указанном
пакете (напрямую или унаследован из другого пакета) и делает его внешним символом
этого пакета. Если символ уже доступен как внешний, \cdf{export} ничего не
делает. Если символ представлен, как внутренний \emph{родственный} символ, его
статус просто меняется на внешний. Если он доступен, как внутренний символ,
полученный с помощью \cdf{use-package}, символ сначала импортируется в пакет, а
затем делается внешним. (После этого символ становиться импортированным в пакет
и остаётся в нем, вне зависимости от того будет ли использована
\cdf{unuse-package} или нет). Если символ вообще недоступен в указанном пакете,
то сигнализируется ошибка с возможностью решить проблему, а, именно, какой
символ должен быть импортирован.

Функция \cdf{unexport} откатывает ошибочное экспортирование
символа. Она работает только для символов напрямую представленных в
текущем пакете, меняя их свойство на <<внутреннее>>.  Если
\cdf{unexport} получает символ, который в текущем пакете уже является
внутренним, она ничего не делает. Если получает вообще недоступный
символ, то сигнализирует ошибку.

\section{Конфликты имён}
\label{NAME-CONFLICTS-SECTION}

Основное неизменяемое правило системы пакетов состоит в том, что внутри одного
пакета каждое имя может ссылаться не более, чем на один символ.
\emph{Конфликтом имён} называется ситуация, когда существует более одного
подходящего символа и не ясно какой из них должен быть выбран. Если система не
будет следовать одному методу выбора, то правило чтения-чтения будет
нарушено. Например, некоторая программа или данные должны быть прочитаны при
некоторой связи имени с символом. Если связь изменяется в другой
символ, и затем прочитывается дополнительная программа или символ, то две
программы не будут получать доступ к одному и тому же символу, даже если
используют одинаковое имя. Даже если система всегда выбирает один метод выбора
символа, конфликт имён приводит к связи имени с символом отличной от той,
что ожидает пользователь, приводя к некорректному выполнению программы. Таким
образом, в любом случае возникновения конфликта имён сигнализируется
ошибка. Пользователь может указать системе пакетов, как разрешить конфликт, и
продолжить выполнение.

Может быть ситуация, когда один символ может быть доступен для пакета более чем
одним способом. Например, символ может быть внешним символов более чем одного
используемого пакета, или символ может быть напрямую представлен в пакете и
также унаследован из другого пакета.
В таких случаях конфликта имён не возникает.
Один и тот же символ не может конфликтовать сам с собой.
Конфликты имён возникают только между разными символами с одинаковыми именами.

Создатель пакета может заранее указать системе, как разрешать конфликт
имён, используя \emph{скрытие}. Каждый пакет имеет список скрывающих
символов. Скрывающий символ имеет преимущество перед любым другим
символом с тем же именем. Разрешение конфликта с участием скрывающего
символа всегда происходит в пользу последнего без сигнализирования об
ошибке (за исключение одного использования \cdf{import} описанного
ниже). Функции \cdf{shadow} и \cdf{shadowing-import} могут
использоваться для декларации скрывающих символов.

Конфликты имён обнаруживаются, когда они становятся возможными, то есть, когда
изменяется структура пакета. Нет смысла проверять конфликты в каждом процессе
поиска имени для символа.

Функции \cdf{use-package}, \cdf{import} и \cdf{export} проверяют возникновение
конфликтов имён. \cdf{use-package} делает внешние символы пакета доступными для
использования в другом пакете. Каждый из этих символов проверяется на конфликт
имён с уже доступным в пакете символом.
\cdf{import} добавляет один символ как внутренний символ пакета, проверяя на
конфликты имён с \emph{родственными} или \emph{доступными
 символами}. \cdf{import} сигнализирует об ошибке конфликта имён, даже если
конфликт произошёл со скрывающим символом. Это объясняется том, что пользователь
дал два явных и взаимоисключающих указания.
\cdf{export} делает один символ доступным для всех пакетов, которые используют
пакет, из которого символ был экспортирован. Все эти пакеты проверяются на
конфликты имён: \cd{(export \emph{s} \emph{p})} делает \cd{(find-symbol
  (symbol-name \emph{s} \emph{q})} для каждого пакета \emph{q} в
\cd{(package-used-by-list \emph{p})}. Следует отметить, что в обычно при
выполнении \cdf{export} в течение первоначального определения пакета, результат
\cdf{package-used-by-list} будет {\false} и проверка конфликта имён не будет
занимать много времени.

Функция \cdf{intern}, которая является одной из часто используемых
Lisp'овыми считывателем для поиска имён символов, не нуждается в
проверке конфликта имён, потому что она никогда не создаёт новые
символы, если символ с указанным именем уже \emph{доступен}.

\cdf{shadow} и \cdf{shadowing-import} никогда не сигнализируют ошибку конфликта
имён, потому что пользователь, вызывая их, указывает, как возможный конфликт
будет разрешён. \cdf{shadow} проверяет конфликт имён при условии, что другой
существующий символ с указанным именем доступен и, если так, является ли
\emph{родственным} или унаследованным. В последнем случае, новый символ
создаётся, чтобы скрыть старый. \cdf{shadowing-import} проверяет конфликт
имён при условии, что другой существующий символ с указанным именем доступен и,
если так, он скрывается новым символом, что означает, что он должен быть
удалён из пакета, если он был представлен в пакете напрямую.

\cdf{unuse-package}, \cdf{unexport} и \cdf{unintern} (когда символ, будучи
удаляемым, не является скрывающим символом) не требуют проверки
конфликтов имён, потому что они просто удаляют символы из пакета. Они не делают
доступными какие-либо новые символы.

Указание скрывающего символа в функцию \cdf{unintern} может
возобновлять конфликт имён, который был ранее разрешён с помощью
затенения. Если пакет A использует пакеты B и C, A содержит скрывающий
символ \cdf{x}, и B, и C, каждый содержит внешний символ с именем
\cdf{x}, тогда при удалении скрывающего символа \cdf{x} из A будет
обнаружен конфликт между \cd{b:x} и \cd{c:x}, если эти два символа
различны. В этом случае \cdf{unintern} будет сигнализировать ошибку.

Прерывание ошибки конфликта имён оставляет оригинальный символ доступным.
Функции для пакетов всегда сигнализируют ошибки конфликтов имён перед любыми
изменениями в структуре пакетов. Однако когда изменяются много символов за раз,
например, когда \cdf{export} получила список символов, реализация может
обрабатывать каждое изменение по отдельности, таким образом прерывание ошибки,
возникшей для второго символа, не приведёт к отмене результатов, выполненных для
первого символа. Однако, прерывание из ошибки конфликта имён при использовании
\cdf{export} для одного символа не оставит этот символ доступным для одних
пакетов и недоступным для других. В отношении к каждому обрабатываемому символу
\cdf{export} ведёт себя как атомарная операция.

Продолжение из ошибки конфликта имён должно предлагать пользователю возможность
разрешить конфликт имён в пользу какого-либо из кандидатов. Структура пакета
должна измениться в соответствие с разрешением конфликта имён, с помощью
\cdf{shadowing-import}, \cdf{unintern} или \cdf{unexport}.

Конфликт имён в \cdf{use-package} между \emph{родственными} символом в
использующем пакете и внешними символом в используемом пакете может
быть разрешён в пользу первого символа с помощью создания скрывающего
символа, или в пользу второго символа с помощью удаления первого
символа из использующего пакета. Последний способ опасен тем, что если
символ для удаления является внешним символом использующего пакета, он
перестанет быть внешним символом.

Конфликт имён в \cdf{use-package} между двумя внешними символами,
унаследованными в использующем пакете из других пакетов, может быть
разрешён в пользу одного из символов, с помощью импортирования его в
использующий пакет и превращения его в затеняющий символ.

Конфликт имён в \cdf{export} между символом для экспорта и символом уже
присутствующем в пакете, который будет наследовать свеже экспортирующийся
символ, может быть разрешён в пользу экспортируемого символа с помощью
удаления другого символа, или в пользу уже присутствующего символа,
превращением его в скрывающий.

Конфликт имён в \cdf{export} или \cdf{unintern} из-за пакета,
наследующего два различных символа с одинаковым именем из двух разных
пакетов, может быть разрешён в пользу одного из символов с помощью
импортирования его в использующий пакет и превращении его в
скрывающий, также как и при использовании \cdf{use-package}.

Конфликт имён в \cdf{import} между символом для импортирования и
символом унаследованным из некоторого другого пакета может быть
разрешён в пользу импортируемого символа превращением его в скрывающий
символ или в пользу уже доступного символа с помощью отмены
\cdf{import}. Конфликт имён в \cdf{import} с символом уже
присутствующем в пакете может быть разрешён с помощью
удаления этого символа, или отмены \cdf{import}.

Хороший стиль пользовательского интерфейса диктует то, что \cdf{use-package} и
\cdf{export}, которые могут вызывать за раз много конфликтов имён, сначала
проверяют все конфликты имён перед тем, как предоставить любой из них
пользователю.
Пользователь может выбрать разрешать ли конфликт для всех сразу или по
отдельности. Последний способ трудоёмок, но позволяет разрешить каждый конфликт
отдельным способом.

Реализации могут предлагать другие пути решения конфликтов имён.
Например, если конфликтующие символы, не используются для объектов, а только для
имен функций, они могут быть <<слиты>> с помощью размещения определения функции
в обоих символах. Ссылка на любой символ в целях вызова функции будет
эквивалентна. Похожая операция <<слияния>> может быть сделана для значений
переменных или для вещей, сохранённых в списке свойств. В Lisp Machine Lisp'е,
например, можно было также \emph{выдвинуть (forward)} значение, функцию и ячейки
свойств так, что изменения в одном символе приводили к изменению в
другом. Некоторые другие реализации позволяют сделать это для ячейки значения,
но на для ячейки списка свойств. Тогда пользователь может знать является ли этот
метод разрешения конфликтов имён адекватным, потому что метод будет работать
только, если использование двух не-\cdf{eq} символов с одинаковым именем не
будет препятствовать корректной работе программы. Значение стоимости слияния
символов, как разрешении конфликта имён, в том, что оно может избегать
необходимости выбрасывать весь Lisp'овый мир, исправлять формы определения
пакета, который вызвал ошибку и начинать с нуля.

\section{Системные пакеты}

\begin{flushdesc}
\item[\cdf{common-lisp}]
Пакет с именем \cdf{common-lisp} содержит базовые элементы системы ANSI Common
Lisp. Его внешние символы включают все видимые пользователю функции и глобальные
переменные, которые представлены в ANSI Common Lisp системе, такие как
\cdf{car}, \cdf{cdr} и \cdf{*package*}.
Следует однако отметить, что домашним пакетом этих символов не обязательно
должен является пакет \cdf{common-lisp} (для символов, например \cdf{t} и
\cdf{lambda} будет проще быть доступными и в \cdf{common-lisp}, и в другом
пакете, возможно с именем \cdf{lisp} FIXME).
Почти все другие пакеты должны использовать \cdf{common-lisp}, таким образом эти
символы будут доступны без использования полного имени (с двоеточием).
Данный пакет имеет псевдоним \cdf{cl}.

\item[\cdf{common-lisp-user}]
Пакет \cdf{common-lisp-user} является, по-умолчанию, текущим пакетом во время
запуска ANSI Common Lisp системы.
Этот пакет использует пакет \cdf{common-lisp} и имеет псевдоним \cdf{cl-user}.
В зависимости от реализации он также может содержать другие символы и
использовать платформоспецифичные пакеты.

\item[\cdf{keyword}]
Этот пакет содержит все ключевые символы, используемые встроенными или
пользовательскими Lisp'овыми функциями. Имя символа, начинающегося с двоеточия,
интерпретируется, как ссылка на символ из этого пакета, который всегда является
внешним. Все символы в этом пакете является константами, которые вычисляются
сами в себя, поэтому пользователь может записывать \cd{:foo} вместо \cd{':foo}.
\end{flushdesc}

Пользовательские программы не могут выполнять следующие действия, которые
могут противоречить базовому функционалу или негативно с ним взаимодействовать.
Если над символом в пакете \cdf{common-lisp} совершается одно из действий ниже,
за исключением явных указаний в книге, последствия не определены.
\begin{itemize}
\item связывание или изменение значения символа (лексически или динамически)
\item определение или связывания символа с функцией
\item определение или связывания символа с макросом
\item определение его как спецификатора типа (\cdf{defstruct}, \cdf{defclass}, \cdf{deftype})
\item определение его как структуры (\cdf{defstruct})
\item определение его как декларации
\item определение его макроса символа
\item изменение имени символа
\item изменение пакета символа
\item трассировка символа
\item декларация или прокламация символа как специального или лексического
\item декларация или прокламация типа символа (\cdf{type}, \cdf{ftype})
\item удаление символа из пакета \cdf{common-lisp}
\item определение как макроса компилятора
\end{itemize}

Если такой символ не определён глобально как переменная или константа,
пользовательская программа может связывать его лексически и декларировать тип
\cdf{type} данного связывания.

Если такой символ не определён как функция, макрос или специальная форма,
пользовательская программа может лексически связать символ с функцией,
декларировать тип \cdf{ftype} данного связывания и трассировать это связывание. 

Если такой символ не определён как функция, макрос или специальная форма,
пользовательская программа может лексически связать символ с макросом.

В качестве примера, поведение данного фрагмента кода
\begin{lisp}
(flet ((open (filename \&key direction) \\*
~~~~~~~~~(format t "{\Xtilde}\%Была вызвана функция open.")  \\*
~~~~~~~~~(open filename :direction direction))) \\*
~~(with-open-file (x "frob" :direction ':output)  \\*
~~~~(format t "{\Xtilde}\%Была ли вызвана open?")))
\end{lisp}
не определено. Даже в <<разумной>> реализации, например, раскрытие макроса
\cdf{with-open-file} должно ссылаться на функцию \cdf{open}. Тем не менее,
предшествующие правила определяют является ли реализация <<разумной>>.
Данный фрагмент кода нарушает правила. Официально его поведение, таким образом,
полностью не определено, и точка.

Следует отметить, что <<изменение списка свойств>> не входит в список упомянутых
действий, таким образом пользовательская программа может добавлять или удалять
свойства для символов в \cdf{common-lisp} пакете.

\section{Функции и переменные для системы пакетов}
\label{PACKAGE-FUNCTIONS-SECTION}

Для описанных здесь функций, все необязательные аргументы с именем
\emph{package} имеют значение по-умолчанию \cdf{*package*}. Там, где
функция принимает аргумент, который может быть символом или списком
символов, значение {\false} расценивается, как пустой список
символов. Любой аргумент, описанный как имя пакета, может быть
символом или строкой.  Если указан символ, то используется его
имя. Если строка, то пользователь должен позаботиться о преобразовании
регистра символов в верхний там, где это необходимо.

\begin{defun}[Переменная]
*package*

Значение этой переменной должно быть объектом пакета. Этот пакет называется
текущим. Первоначальное значение \cdf{*package*} является пакетом \cdf{common-lisp-user}.

Функции \cdf{load} и \cdf{compile-file} пересвязывают \cdf{*package*} в текущее значение. Если
некоторая форма в файле во время загрузки изменяет значение \cdf{*package*},
старое значение будет восстановлено после завершения загрузки.

Функция \cdf{compile-file} пересвязывает \cdf{*package*} в текущее
значение. Если некоторая форма в файле во время загрузки или компиляции изменяет
значение \cdf{*package*}, старое значение будет восстановлено после
завершения функции \cdf{compile-file}.
\end{defun}

\begin{defun}[Функция]
make-package package-name &key :nicknames :use

Эта функция создаёт и возвращает новый пакет с указанным именем. Как было
описано выше, аргументом может быть или символ, или строка. Аргумент
\cd{:nicknames} должен быть списком строк, которые будут псевдонимами. И здесь
пользователь вместо строк может указывать символы, в случае которых будут
использоваться их имена. Это имя и псевдонимы не могут конфликтовать с
уже имеющимися именами пакетов. Если конфликт произошёл,
сигнализируется исправимая ошибка.

Аргумент \cd{:use} является списком пакетов или имён (строк или символов)
пакетов, чьи внешние символы будут унаследованы новым пакетом. Эти пакеты должны
существовать перед вызовом функции. 
\end{defun}

\begin{defmac}
in-package name

Этот макрос пересвязывает переменную \cdf{*package*} с пакетом, имя которого
указано в параметре \emph{name}. Параметр \emph{name} может быть строкой или
символом. Форма \emph{name} не вычисляется.
В случае отсутствия пакета, сигнализируется ошибка.
Кроме того, в случае вызова в качестве формы верхнего уровня, этот макрос
работает и во время компиляции.

\cdf{in-package} возвращает новый пакет, то есть значение \cdf{*package*} после
выполнения операции.
\end{defmac}

\begin{defun}[Функция]
find-package name

Параметр \emph{name} должен быть строкой, которая является именем или
псевдонимом искомого пакета. Этот параметр может также быть символов, в случае
которого используется имя. В результате возвращается объект пакета с
указанным именем или псевдонимом. Если пакет найден не был, то
\cdf{find-package} возвращает {\false}.
Сравнение имён регистрозависимо (как в \cdf{string=}).

Аргумент \emph{package} может быть объектом пакета, в таком случае значение
аргумента сразу возвращается. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
package-name package

Аргумент должен быть объектом пакета. Данная функция возвращает строку имени
указанного пакета.

Кроме того функция принимает имя пакета или псевдоним, и в этом случае
возвращает главное имя пакета. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.

\cdf{package-name} возвращает \cdf{nil} вместо имени пакета, если пакет был
удалён. Смотрите \cdf{delete-package}.
\end{defun}

\begin{defun}[Функция]
package-nicknames package

Аргумент должен быть объектом пакета. Эта функция возвращает список псевдонимов
для заданного пакета, не включая главное имя.

Кроме того функция принимает имя пакета или псевдоним, и в этом случае
возвращается список псевдонимов пакета. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
rename-package package new-name &optional new-nicknames

Старое имя и все старые псевдонимы пакета \emph{package} удаляются и заменяются
на \emph{new-name} и \emph{new-nicknames}. Аргумент \emph{new-name} может быть
строкой или символом. Аргумент \emph{new-nicknames}, который по-умолчанию
{\false}, является списком строк или символов.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.

\cdf{rename-package} возвращает \emph{package}.
\end{defun}

\begin{defun}[Функция]
package-use-list package

Данная функция возвращает список пакетов, используемых указанным в параметре
пакетом.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
package-used-by-list package

Данная функция возвращает список пакетов, использующих указанный в параметре
пакет.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
package-shadowing-symbols package

Данная функция возвращает список символов, которые были задекларированы, как
скрывающие символы, с помощью \cdf{shadow} или \cdf{shadowing-import}. Все
символы в этом списке является \emph{родственными} указанному пакету.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
list-all-packages 

Эта функция возвращает список всех пакетов, которые существуют в Lisp'овой
системе. 
\end{defun}

\begin{defun}[Функция]
delete-package package

Функция \cdf{delete-package} удаляет указанный в аргументе \emph{package} пакет,
из всех структур данных системы пакетов.
Аргумент \emph{package} может быть как пакетом, так и его именем.

Если \emph{package} является именем, но пакета с данным именем не существует,
сигнализируется исправимая ошибка. Продолжение из этой ошибки не делает попытку
удаления, но возвращает \cdf{nil} из вызова \cdf{delete-package}.

Если \emph{package} является пакетов, но пакет уже был удалён,
ошибка не сигнализируется и попыток удаления не происходит. Вместо этого
\cdf{delete-package} немедленно возвращает \cdf{nil}.

Если пакет, указанный для удаления, в этот момент используется другими пакетами,
сигнализируется исправимая ошибка. Продолжение из этой ошибки выглядит как, если
бы функция \cdf{unuse-package} была выполнена на всех использующих пакетах для
удаления зависимостей, после чего была вызвана \cdf{delete-package} для удаления
пакета.

Если указанный пакет является домашним для некоторого символа, тогда после
выполнения \cdf{delete-package}, ячейка домашнего пакета символа становится
неопределённой. Никак по-другому символы в удаляемом пакете не модифицируются.

Имя и псевдонимы пакета \emph{package} перестают быть сами собой. Объект пакета
остаётся, но анонимно: \cdf{packagep} будет истинным, но \cdf{package-name}
применительно к нему будет возвращать \cdf{nil}.

Влияние любой другой операции на удалённым объектом пакета не определена. В
частности, попытка найти символ в удалённый пакет (например, используя \cdf{intern}
или \cdf{find-symbol}) будет иметь неопределённый результат.

Если удаление было успешно, \cdf{delete-package} возвращает \cdf{t}, иначе \cdf{nil}.
\end{defun}

\begin{defun}[Функция]
intern string &optional package

В пакете \emph{package}, который по-умолчанию равен текущему пакету,
осуществляется поиск символа с именем, указанным в аргументе \emph{string}. Этот
поиск будет включить унаследованные символы, как описано в
разделе~\ref{EXPORT-IMPORT-SECTION}.
Если ни одного символа не найдено, то символ создаётся и устанавливается в
указанный пакет в качестве внутреннего символа (или внешнего символа, если пакет
\cdf{keyword}). Указанный пакет становиться домашним пакетом для созданного символа.
Возвращается два значения. Первое является символом, который был найден или
создан. Второе значение {\false}, если символ не существовал ранее, или одно из
следующих значений:
\begin{indentdesc}{6pc}
\item[\cd{:internal}] Символ напрямую представлен в пакете как
  внутренний символ.

\item[\cd{:external}] Символ напрямую представлен в пакете как внешний
  символ.

\item[\cd{:inherited}] Символ унаследован с помощью \cdf{use-package}
  (и следовательно символ является внутренним).
\end{indentdesc}

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
find-symbol string &optional package

Эта функция идентична \cdf{intern}, но она никогда не создаёт новый символ. Если
символ с указанным именем был найден в указанном пакете, напрямую или через
наследование, найденный возвращается символ как первое значение и второе
значение так же как в \cdf{intern}. Если символ не доступен в заданном пакете,
оба значения равны {\false}.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
unintern symbol &optional package

Если указанный символ представлен в указанном пакете \emph{package}, он
удаляется из этого пакета и также из списка скрывающих символов, если он там
был. Кроме того, если \emph{package} для символа является домашним пакетом, то
символ отсоединяется и становится бездомным.
Следует отметить, что в некоторых обстоятельствах может продолжить быть
доступным с помощью наследования в указанном пакете.
Если удаление действительно произошло, \cdf{unintern} возвращает {\true}, иначе
{\false}.

\cdf{unintern} должна использоваться с осторожностью. Она изменяет состояние
системы пакетов так, что правила согласованности перестают действовать.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
export symbols &optional package

Аргумент \emph{symbols} должен быть списком символов или одиночным
символом. Эти символы становятся доступными как внешние символы в пакете
\emph{package} (смотрите раздел~\ref{EXPORT-IMPORT-SECTION}).
\cdf{export} возвращает {\true}.

По соглашению, вызов \cdf{export} содержит все экспортируемые символы и
помещается рядом с началом файла, для указания того, какие символы
экспортируются данным файлом для использования другими программами. 

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
unexport symbols &optional package

Аргумент \emph{symbols} должен быть списком символов или одиночным символом. Эти
символы становятся внутренними символами в пакете \emph{package}. 
Использование этой операции для символов пакета \cdf{keyword} является ошибкой.
(смотрите раздел~\ref{EXPORT-IMPORT-SECTION}).
\cdf{unexport} возвращает {\true}.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
import symbols &optional package

Аргумент \emph{symbols} должен быть списком символов или одиночным символом.
Эти символы становятся внутренними символами в пакете \emph{package} и, таким
образом, могут быть указаны без использования полного имени (с двоеточием).
\cdf{import} сигнализирует исправимую ошибку, если любой из импортируемых
символов имеет такое же имя, как один из уже присутствующих в пакете символов
(смотрите раздел~\ref{EXPORT-IMPORT-SECTION}).
\cdf{import} возвращает {\true}.

Если любой импортируемый символ не имеет домашнего пакета, тогда \cdf{import}
устанавливает домашний пакет тот, в который символ импортируется. 

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
shadowing-import symbols &optional package

Данная функция похожа на \cdf{import}, но не сигнализирует ошибку, даже если
импортирование символа будет скрывать некоторый другой символ, уже
присутствующий в пакете. В дополнение к импортированию символ помещается в
список скрывающих символов пакета \emph{package} (смотрите
раздел~\ref{NAME-CONFLICTS-SECTION}).
\cdf{shadowing-import} возвращает {\true}.

\cdf{shadowing-import} должна использоваться с осторожностью. Она изменяет
состояние системы пакетов так, что правила согласованности перестают действовать.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
shadow symbols &optional package

Аргумент должен быть списком символов или строк или одиночным символом или строкой.
Рассматривается имя каждого символа (или просто строка) и в указанном
пакете \emph{package} ищется символ с таким же именем. Если данный символ
присутствует в этом пакете (напрямую, а не с помощью наследования), тогда он
добавляется в список скрывающих символов. Иначе, создаётся новый символ с
указанным именем, и вставляется в пакет \emph{package} как внутренний
символ. Символ также помещается в список затеняющих символов пакета
\emph{package} (смотрите раздел~\ref{NAME-CONFLICTS-SECTION}).
\cdf{shadow} возвращает {\true}.

\cdf{shadowing} должна использоваться с осторожностью. Она изменяет
состояние системы пакетов так, что правила согласованности перестают действовать.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
use-package packages-to-use &optional package

Аргумент \emph{packages-to-use} должен быть списком пакетов или их имён или
одиночным пакетом или его именем. Эти пакеты добавляются в список использования
\emph{package}, если их там ещё нет. Все внешние символы в пакетах становятся
доступными в пакете \emph{package} как внутренние символы (смотрите
раздел~\ref{EXPORT-IMPORT-SECTION}).
Использование пакета \cdf{keyword} является ошибкой.
\cdf{use-package} возвращает {\true}.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[Функция]
unuse-package packages-to-unuse &optional package

Аргумент \emph{packages-to-use} должен быть списком пакетов или их имён или
одиночным пакетом или его именем. Эти пакеты удаляются из списка использования
\emph{package}, если они там были.
\cdf{unuse-package} возвращает {\true}.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defmac}
defpackage defined-package-name {option}*

Эта функция создаёт новый пакет, или модифицирует уже существующий, имя которого
является \emph{defined-package-name}. Аргумент \emph{define-package-name} может
быть строкой или символом.
Если он является символом, то используется его имя, а не пакет, если
вдруг в котором находится данный символ.
Созданный или модифицированный пакет возвращается как значение формы
\cdf{defpackage}.

\begin{flushdesc}
\item[\cd{(:size \emph{integer})}]
Запись указывает примерное количество символов ожидаемых быть в пакете. 
Это просто подсказка для менеджера памяти так, что реализация используя
хеш-таблицы для хранения структуры пакета может указать данный параметр, и
память будет более эффективно выделяться (удобно, например при чтении файла и
всех его символов в пакет).

\item[\cd{(:nicknames \Mstar\emph{package-name})}]
Запись указывает псевдонимы для пакета.
Если один из псевдонимов уже указывает на имеющийся пакет, то сигнализируется
исправимая ошибка, как для функции \cdf{make-package}.

\item[\cd{(:shadow \Mstar\emph{symbol-name})}]
Указывает имена символов, которые будут затеняющими в определяемом
пакете. Работает как \cdf{shadow}.

\item[\cd{(:shadowing-import-from \emph{package-name} \Mstar\emph{symbol-name})}]
Указывает имена символов, которые будут размещены в определяемом пакете.
Эти символы импортируются в пакет, будучи при необходимости затеняющими, как при
использовании функции \cdf{shadowing-import}.
Ни в коем случае символы не создаются.
Если для любого имени \emph{symbol-name} не существует символа доступного в
пакете с именем \emph{package-name}, то сигнализируется исправимая ошибка.

\item[\cd{(:use \Mstar\emph{package-name})}]
Указывает определяемому пакету <<использовать>> (наследовать от) пакеты
указанные в этой опции. Работает также, как и \cdf{use-package}.
Если \cdf{:use} не указана, тогда опция имеет неопределённое значение.

\item[\cd{(:import-from \emph{package-name} \Mstar\emph{symbol-name})}]
Указывает символы, которые будут размещены в определяемом пакете.
Эти символы импортируются в пакет, как при использовании функции \cdf{shadowing-import}.
Ни в коем случае символы не создаются.
Если для любого имени \emph{symbol-name} не существует символа доступного в
пакете с именем \emph{package-name}, то сигнализируется исправимая ошибка.

\item[\cd{(:intern \Mstar\emph{symbol-name})}]
Указанные символы размещаются или создаются в определяемом пакете, как
при использовании функции \cdf{intern}. Следует отметить, что действие этой
опции может зависеть от опции \cd{:use}, так как преимущество отдаётся
унаследованному символу, чем созданию нового.

\item[\cd{(:export \Mstar\emph{symbol-name})}]
Указанные символы размещаются или создаются в определяемом пакете и затем
экспортируются, как при использовании функции \cdf{export}. Следует отметить,
что действие этой опции может зависеть от опции \cd{:use}, \cd{import-from} или
\cd{shadowing-import-from} так как преимущество отдаётся  
унаследованному или импортированному символу, чем созданию нового.
\end{flushdesc}

Порядок, в котором опции используются в форме \cdf{defpackage}, не имеет
значения. Часть соглашения в том, что \cdf{defpackage} сортирует опции перед
обработкой.
Опции обрабатываются в следующем порядке:
\begin{tabbing}
1.~~\cd{:shadow} and \cd{:shadowing-import-from} \\
2.~~\cd{:use} \\
3.~~\cd{:import-from} and \cd{:intern} \\
4.~~\cd{:export}
\end{tabbing}
Сначала устанавливаются затенения, чтобы избежать ложных конфликтов при
установке связей для use. Связи use должны устанавливаться перед импортированием
и интернированием, таким образом эти операции могут ссылаться на нормально
унаследованные символы, а не создавать новые. Экспортирование выполняется
последним, таким образом символы созданные любой другой операцией, в частности,
затеняющие и импортированные символы, могут быть экспортированы. Следует
отметить, что экспортирование унаследованного символа сначала неявно импортирует
его (смотрите раздел~\ref{EXPORT-IMPORT-SECTION}).

Если пакета с именем \emph{defined-package-name} не существовало, то
\cdf{defpackage} создаст его. Если такой пакет уже существовал, то новый пакет
создан не будет. Существующий пакет модифицируется, если возможно, для отражения
нового определения. Результат не определён, если новое определение не совместимо
с текущим состоянием пакета.

Если одинаковый аргумент \cdf{symbol-name} (в смысле сравнения имён с помощью
\cdf{string=}) встречается более одного раза в опциях \cd{:shadow},
\cd{:shadowing-import-from}, \cd{:import-from} и \cd{:intern}, сигнализируется
ошибка.

Если одинаковый аргумент \cdf{symbol-name} (в смысле сравнения имён с помощью
\cdf{string=}) встречается более одного раза в опциях \cd{:intern} и
\cd{:export}, сигнализируется ошибка.

Другие виды конфликтов обрабатывается в том же стиле, как в соответствующих
операциях \cdf{use-package}, \cdf{import} и \cdf{export}.

Реализация может поддерживать другие опции для \cdf{defpackage}.
Каждая реализация должно сигнализировать ошибку при встрече с неподдерживаемой
опцией для \cdf{defpackage}.

Функция \cdf{compile-file} должна обрабатывается формы верхнего уровня
\cdf{defpackage} таким же методом, как и обрабатывает формы верхнего уровня для
работы с пакетам (как описано в начале раздела~\ref{PACKAGE-FUNCTIONS-SECTION}).

Вот пример вызова \cdf{defpackage}, которая <<не рискует (plays it safe)>>, используя только
строки в качестве имён.
\begin{lisp}
(cl:defpackage "MY-VERY-OWN-PACKAGE" \\*
~~(:size 496) \\*
~~(:nicknames "MY-PKG" "MYPKG" "MVOP") \\*
~~(:use "COMMON-LISP") \\
~~(:shadow "CAR" "CDR") \\*
~~(:shadowing-import-from "BRAND-X-LISP" "CONS") \\*
~~(:import-from "BRAND-X-LISP" "GC" "BLINK-FRONT-PANEL-LIGHTS") \\*
~~(:export "EQ" "CONS" "MY-VERY-OWN-FUNCTION"))
\end{lisp}
\cdf{defpackage} пример выше спроектирован работать корректно, даже если текущий
пакет не использует пакет \cdf{common-lisp}. (Следует отметить, что
в этом примере используется псевдоним \cdf{cl} для пакета \cdf{common-lisp}.)
Более того, выполнение этой формы \cdf{defpackage} не создаст символа в текущем
пакете. А также для последующего удобства для строк использованы буквы в верхнем
регистре.

\beforenoterule
\begin{implementation}
An implementation of \cdf{defpackage} might choose to transform
all the \emph{package-name} and \emph{symbol-name} arguments
into strings at macro expansion time, rather than at the time
the resulting expansion is executed, so that even if source code
is expressed in terms of strange symbols in the \cdf{defpackage} form,
the binary file resulting from compiling the source code would
contain only strings.  The purpose of this is simply to minimize
the creation of useless symbols in production code.  This technique
is permitted as an implementation strategy but is not a
behavior required by the specification of \cdf{defpackage}.
\end{implementation}
\afternoterule

А вот для контраста пример \cdf{defpackage}, который <<играет по крупному (plays
the whale)>> с использованием всех типов допустимого синтаксиса.
\begin{lisp}
(defpackage my-very-own-package \\*
~~(:export :EQ common-lisp:cons my-very-own-function) \\*
~~(:nicknames "MY-PKG" \#:MyPkg) \\*
~~(:use "COMMON-LISP") \\
~~(:shadow "CAR") \\*
~~(:size 496) \\*
~~(:nicknames mvop) \\
~~(:import-from "BRAND-X-LISP" "GC" Blink-Front-Panel-Lights) \\
~~(:shadow common-lisp::cdr) \\*
~~(:shadowing-import-from "BRAND-X-LISP" CONS))
\end{lisp}
Этот пример производит то же влияние на вновь созданный пакет,  но может
создавать бесполезные символы в других пакетах.
Использования явных тегов пакетов особенно запутаны.
Например, эта форма \cdf{defpackage} делает так, что символ \cdf{cdr} будет
затенён в \emph{новом пакете}. Данный символ не будет затенён в пакете
\cdf{common-lisp}. Факт, что имя <<\cdf{CDR}>> было указано полным именем (с
двоеточием) является отвлекающим маневром.
Мораль в том, что синтаксическая гибкость \cdf{defpackage}, как в других частях
Common Lisp'а, даёт большие удобства в использовании в рамках здравого смысла, 
но создаёт невообразимую путаницу при использовании мальтузианского изобилия.

Следует отметить, что \cdf{defpackage} не способна сама по себе определять
взаимно рекурсивные пакеты, например, два пакета использующих друг друга. Однако,
ничто не мешает использовать \cdf{defpackage} для выполнения первоначальных
установок, а затем использовать такие функции, как \cdf{use-package},
\cdf{import} и \cdf{export} для создания связи.

Цель \cdf{defpackage} поощрять пользователя размещать определение пакета и его
зависимостей в одном месте. Это может также позволить проектировщику большой
системы размещать определения всех необходимых пакетов (скажем) в один файл,
который может быть загружен перед загрузкой или компиляцией кода, который
зависит от этих пакетов. Такой файл, если аккуратно сконструирован, может быть
просто загружен в пакет \cdf{common-lisp-user}.

Реализации и программные окружения могут также лучше поддерживать процесс
разработки (если только предлагая лучшую проверку ошибок) с помощью глобальной
базы значений о предполагаемых установках пакетов.
\end{defmac}

\begin{defun}[Функция]
find-all-symbols string-or-symbol

\cdf{find-all-symbols} просматривает каждый пакет в Lisp'овой системе для поиска
символа, имя которого совпадает с указанной строкой. Список всех найденных
символов возвращается в качестве результата.
Этот поиск регистрозависимый.
Если аргумент является символом, для поиска по строке используется его
имя.
\end{defun}

\begin{defmac}
do-symbols (var [package [result-form]])
           {declaration}* {tag | statement}*

\cdf{do-symbols} предоставляет прямой цикл по символам пакета. Тело выполняется
единожды для каждого символа доступного в пакете \emph{package}. Символ
связывается с переменной \emph{var}.
Затем вычисляется форма \emph{result-form} (одиночная форма, \emph{не} неявный
\cdf{progn}), и результат является результатом формы \cdf{do-symbols}. (Когда
вычисляется форма \emph{result-form}, переменная \emph{var} продолжает быть
связанной и имеет значение {\false}.) Если \emph{result-form} опущена, результат
{\false}. Для немедленного завершения цикла может использоваться
\cdf{return}. Если выполнение тела влияет на то, какие символы содержаться в
пакете \emph{package}, то возможно только удаление символа связанного с
переменной \emph{var} с использованием \cdf{unintern}, иначе результат
не определён.

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.

\begin{new}
Тело \cdf{do-symbols} для одного и того же символа может быть
выполнено несколько раз, пользователь должен сам следить за этим.

Фишка в том, что один и тот же символ может быть доступен с помощью
нескольких цепочек наследования, и для реализаций дорого следить за
этим. Например:
\begin{lisp}
(setq *a* (make-package 'a))~~~~~~;\textrm{Неявно использует \cdf{common-lisp}} \\*
(setq *b* (make-package 'b))~~~~~~;\textrm{Неявно использует \cdf{common-lisp}} \\*
(setq *c* (make-package 'c :use '(a b))) \\
\\
(do-symbols (x *c*) (print x))~~~~;\textrm{Символы пакета \cdf{common-lisp}} \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;~\textrm{могут быть выведены один или два раза}
\end{lisp}

\end{new}

Пользователь ограничен в создании побочных действий так, как это описано в
разделе~\ref{STRUCTURE-TRAVERSAL-SECTION}

Следует отметить, что конструкция \cdf{loop} предоставляет тип выражения
\cdf{for}, которое может проходить в цикле по символам пакета (смотрите главу~\ref{LOOP}).
\end{defmac}

\begin{defmac}
do-external-symbols (var [package [result]])
                    {declaration}* {tag | statement}*

\cdf{do-external-symbols} похожа на \cdf{do-symbols} за исключением того, что
сканируются только внешние символы пакета.

\begin{new}
The clarification voted by X3J13
in March 1988 for \cdf{do-symbols}
\issue{DO-SYMBOLS-DUPLICATES},
regarding redundant executions of the body for the same symbol,
applies also to \cdf{do-external-symbols}.
\end{new}

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.

Пользователь ограничен в создании побочных действий так, как это описано в
разделе~\ref{STRUCTURE-TRAVERSAL-SECTION}
\end{defmac}

\begin{defmac}
do-all-symbols (var [result-form])
               {declaration}* {tag | statement}*

Эта функция похожа на \cdf{do-symbols}, но выполняет тело единожды для каждого
символа каждого пакета. (Функция не обрабатывает все возможные символы, так как
символ может быть доступен ни в одном пакете. Обычно, дезинтернированые символы
не доступны ни в одном пакете.)
В общем случае тело может выполняться для одно символа несколько раз, так как
этот символ может встречаться в нескольких пакетах.

\begin{new}
The clarification voted by X3J13
in March 1988 for \cdf{do-symbols}
\issue{DO-SYMBOLS-DUPLICATES},
regarding redundant executions of the body for the same symbol,
applies also to \cdf{do-all-symbols}.
\end{new}

Аргумент \emph{package} может быть как объектом пакета, так и его
именем. Смотрите раздел~\ref{PACKAGE-NAMES-SECTION}.

Пользователь ограничен в создании побочных действий так, как это описано в
разделе~\ref{STRUCTURE-TRAVERSAL-SECTION}
\end{defmac}

\begin{defmac}
with-package-iterator (mname package-list {symbol-type}+)
                      {form}*

Имя \emph{mname} связывается и определяется как если бы с помощью
\cdf{macrolet}, лексически для тела \emph{form}, и является
<<генератором>>, таким образом, что каждый вызов \cd{(\emph{mname})}
будет возвращать следующий символ, из списка всех символов, которые
присутствуют в пакетах, перечисленных в списке полученным от выражения
\emph{package-list} (которое вычисляется единожды).

Каждый элемент значения \emph{package-list} может быть или объектом
пакета или его именем. Кроме того, если значение \emph{package-list}
является просто объектом пакета или его и именем, то оно трактуется
как список с одним этим элементом. Если значение \emph{package-list}
равно \cdf{nil}, то трактуется как пустой список.

При каждом вызове <<генератора>> возможны два исхода.
Если символы для обработки ещё есть, возвращается четыре значения:
\cdf{t}, символ, ключевой символ, который характеризует искомый символ
(смотрите ниже) и пакет, в котором данный символ доступен.
Если символом для обработки не осталось, то возвращается одно
значение: \cdf{nil}.

Когда <<генератор>> во втором значении возвращает символ, четвёртое
значение это всегда пакет из списка, который был получен в
\emph{package-list}, и третье значение характеризует искомый символ
так:
\cd{:internal} означает, что символ внутренний;
\cd{:external} означает, что символ внешний (экспортированный);
и \cd{:inherited} означает, что символ не представлен (следовательно
не скрыт), но унаследован из некоторого другого пакета, который
используется в пакете из четвёртого значения.

Элементы \emph{symbol-type} в вызове \cdf{with-package-iterator} не
вычисляются. Их может быть несколько, порядок не имеет значения. Они
указывают на свойства интересующих пользователя символов.
Символ будет возвращён из <<генератора>> только если его свойство было
указано в \emph{symbol-type}. Стандартными значениями
\emph{symbol-type} являются \cd{:internal}, \cd{:external},
\cd{:inherited}, но реализации могут добавлять свои свойства. В случае
если в \emph{symbol-type} не указано ни одно свойство, или если
указанные не поддерживаются реализацией, сигнализируется ошибка.

Порядок, в котором возвращаются символы с помощью <<генератора>>,
никак не коррелирует с порядком перечисления пакетов в
\emph{package-list}.
При наличии в \emph{package-list} более одного пакета, символы,
которые доступны более чем из одного пакета могут быть возвращены один
или более раз. Даже если указан только один пакет, символы
унаследованные различными путями могут быть обработаны один или
несколько раз.

Неявное состояние перечисления символов имеет динамическую
продолжительность жизни.
После завершения формы \cdf{with-package-iterator} вызов
<<генератора>> приведёт к ошибке.

Любое количество вызовов \cdf{with-package-iterator} и связанных
с ними макросов может быть вложенным.

Пользователь ограничен в создании побочных действий так, как это описано в
разделе~\ref{STRUCTURE-TRAVERSAL-SECTION}

\beforenoterule
\begin{rationale}
Этот функция в некотором смысле более гибкий, чем \cdf{do-symbols} и
подобные ей функции.
В частности, он позволяет реализовать подвыражения для \cdf{loop} для
итераций над символами пакетов и переносимо, и эффективно (смотрите
главу~\ref{LOOP}).
\end{rationale}
\afternoterule


\end{defmac}
\fi