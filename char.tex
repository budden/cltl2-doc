%Part{Char, Root = "CLM.MSS"}
%%% Chapter of Common Lisp Manual.  Copyright 1984, 1987, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\ifx \rulang\Undef

\chapter{Characters}

Common Lisp provides a character data type; objects of this type
represent printed symbols such as letters.

In general, characters in Common Lisp are not true objects; \cdf{eq} cannot
be counted upon to operate on them reliably.  In particular,
it is possible that the expression
\begin{lisp}
(let ((x z) (y z)) (eq x y))
\end{lisp}
may be false rather than true, if the value of \cdf{z} is a character.

\beforenoterule
\begin{rationale}
This odd breakdown of \cdf{eq} in the case of characters
allows the implementor enough design freedom to produce exceptionally
efficient code on conventional architectures.  In this respect the
treatment of characters exactly parallels that of numbers, as described
in chapter~\ref{NUMBER}.
\end{rationale}
\afternoterule

\begin{table}
\caption{Standard Character Labels, Glyphs, and Descriptions}
\label{STANDARD-CHAR-REPERTOIRE-TABLE}
\tabcolsep0pt
\def\arraystretch{1.1}

\begin{tabular*}{\textwidth}{@{}l@{\extracolsep{\fill}}llllllll@{}}
           &&&\cd{SM05}&\cd{{\Xatsign}}&\textrm{commercial at}&\cd{SD13}&\cd{{\Xbq}}&\textrm{grave accent} \\
\cd{SP02}&\cd{!}&\textrm{exclamation mark}&\cd{LA02}&\cdf{A}&\textrm{capital A}&\cd{LA01}&\cdf{a}&\textrm{small a} \\
\cd{SP04}&\cd{"}&\textrm{quotation mark}&\cd{LB02}&\cdf{B}&\textrm{capital B}&\cd{LB01}&\cdf{b}&\textrm{small b} \\
\cd{SM01}&\cd{\#}&\textrm{number sign}&\cd{LC02}&\cdf{C}&\textrm{capital C}&\cd{LC01}&\cdf{c}&\textrm{small c} \\
\cd{SC03}&\cd{\$}&\textrm{dollar sign}&\cd{LD02}&\cdf{D}&\textrm{capital D}&\cd{LD01}&\cdf{d}&\textrm{small d} \\
\cd{SM02}&\cd{\%}&\textrm{percent sign}&\cd{LE02}&\cdf{E}&\textrm{capital E}&\cd{LE01}&\cdf{e}&\textrm{small e} \\
\cd{SM03}&\cd{\&}&\textrm{ampersand}&\cd{LF02}&\cdf{F}&\textrm{capital F}&\cd{LF01}&\cdf{f}&\textrm{small f} \\
\cd{SP05}&\cd{'}&\textrm{apostrophe}&\cd{LG02}&\cdf{G}&\textrm{capital G}&\cd{LG01}&\cdf{g}&\textrm{small g} \\
\cd{SP06}&\cd{(}&\textrm{left parenthesis}&\cd{LH02}&\cdf{H}&\textrm{capital H}&\cd{LH01}&\cdf{h}&\textrm{small h} \\
\cd{SP07}&\cd{)}&\textrm{right parenthesis}&\cd{LI02}&\cdf{I}&\textrm{capital I}&\cd{LI01}&\cdf{i}&\textrm{small i} \\
\cd{SM04}&\cdf{*}&\textrm{asterisk}&\cd{LJ02}&\cdf{J}&\textrm{capital J}&\cd{LJ01}&\cdf{j}&\textrm{small j} \\
\cd{SA01}&\cdf{+}&\textrm{plus sign}&\cd{LK02}&\cdf{K}&\textrm{capital K}&\cd{LK01}&\cdf{k}&\textrm{small k} \\
\cd{SP08}&\cd{,}&\textrm{comma}&\cd{LL02}&\cdf{L}&\textrm{capital L}&\cd{LL01}&\cdf{l}&\textrm{small l} \\
\cd{SP10}&\cdf{-}&\textrm{hyphen or minus sign}&\cd{LM02}&\cdf{M}&\textrm{capital M}&\cd{LM01}&\cdf{m}&\textrm{small m} \\
\cd{SP11}&\cd{.}&\textrm{period or full stop}&\cd{LN02}&\cdf{N}&\textrm{capital N}&\cd{LN01}&\cdf{n}&\textrm{small n} \\
\cd{SP12}&\cdf{/}&\textrm{solidus}&\cd{LO02}&\cdf{O}&\textrm{capital O}&\cd{LO01}&\cdf{o}&\textrm{small o} \\
\cd{ND10}&\cd{0}&\textrm{digit 0}&\cd{LP02}&\cdf{P}&\textrm{capital P}&\cd{LP01}&\cdf{p}&\textrm{small p} \\
\cd{ND01}&\cd{1}&\textrm{digit 1}&\cd{LQ02}&\cdf{Q}&\textrm{capital Q}&\cd{LQ01}&\cdf{q}&\textrm{small q} \\
\cd{ND02}&\cd{2}&\textrm{digit 2}&\cd{LR02}&\cdf{R}&\textrm{capital R}&\cd{LR01}&\cdf{r}&\textrm{small r} \\
\cd{ND03}&\cd{3}&\textrm{digit 3}&\cd{LS02}&\cdf{S}&\textrm{capital S}&\cd{LS01}&\cdf{s}&\textrm{small s} \\
\cd{ND04}&\cd{4}&\textrm{digit 4}&\cd{LT02}&\cdf{T}&\textrm{capital T}&\cd{LT01}&\cdf{t}&\textrm{small t} \\
\cd{ND05}&\cd{5}&\textrm{digit 5}&\cd{LU02}&\cdf{U}&\textrm{capital U}&\cd{LU01}&\cdf{u}&\textrm{small u} \\
\cd{ND06}&\cd{6}&\textrm{digit 6}&\cd{LV02}&\cdf{V}&\textrm{capital V}&\cd{LV01}&\cdf{v}&\textrm{small v} \\
\cd{ND07}&\cd{7}&\textrm{digit 7}&\cd{LW02}&\cdf{W}&\textrm{capital W}&\cd{LW01}&\cdf{w}&\textrm{small w} \\
\cd{ND08}&\cd{8}&\textrm{digit 8}&\cd{LX02}&\cdf{X}&\textrm{capital X}&\cd{LX01}&\cdf{x}&\textrm{small x} \\
\cd{ND09}&\cd{9}&\textrm{digit 9}&\cd{LY02}&\cdf{Y}&\textrm{capital Y}&\cd{LY01}&\cdf{y}&\textrm{small y} \\
\cd{SP13}&\cd{:}&\textrm{colon}&\cd{LZ02}&\cdf{Z}&\textrm{capital Z}&\cd{LZ01}&\cdf{z}&\textrm{small z} \\
\cd{SP14}&\cd{;}&\textrm{semicolon}&\cd{SM06}&\cd{{\Xlbracket}}&\textrm{left square bracket}&\cd{SM11}&\cd{{\Xlbrace}}&\textrm{left curly bracket} \\
\cd{SA03}&\cdf{<}&\textrm{less-than sign}&\cd{SM07}&\cd{{\Xbackslash}}&\textrm{reverse solidus}&\cd{SM13}&\cd{|}&\textrm{vertical bar} \\
\cd{SA04}&\cdf{=}&\textrm{equals sign}&\cd{SM08}&\cd{{\Xrbracket}}&\textrm{right square bracket}&\cd{SM14}&\cd{{\Xrbrace}}&\textrm{right curly bracket} \\
\cd{SA05}&\cdf{>}&\textrm{greater-than sign}&\cd{SD15}&\cd{{\Xcircumflex}}&\textrm{circumflex accent}&\cd{SD19}&\cd{{\Xtilde}}&\textrm{tilde} \\
\cd{SP15}&\cd{?}&\textrm{question mark}&\cd{SP09}&\cd{{\Xunderscore}}&\textrm{low line}&
\end{tabular*}

\vfill
\begin{small}
\noindent
The characters in this table plus the space and newline characters make up
the standard Common Lisp character repertoire (type \cdf{standard-char}).
The character labels and character descriptions shown here are taken
from ISO standard 6937/2 .  The first character of the label
categorizes the character as Latin, Numeric, or Special.
\end{small}
\end{table}

If two objects are to be compared for ``identity,'' but either might be
a character, then the predicate \cdf{eql} is probably appropriate.

\section{Character Attributes}

\begin{defun}[Constant]
char-code-limit

The value of \cdf{char-code-limit} is a non-negative
integer that is the upper exclusive bound on values produced
by the function \cdf{char-code}, which returns the \emph{code} component
of a given character; that is, the values returned by \cdf{char-code}
are non-negative and strictly less than the value of
\cdf{char-code-limit}.

Common Lisp does not at present explicitly guarantee that all integers between
zero and the value of \cdf{char-code-limit} are valid character codes, and so
it is wise in any case for the programmer to assume that the space of
assigned character codes may be sparse.
\end{defun}

\section{Predicates on Characters}

The predicate \cdf{characterp} may be used to determine
whether any Lisp object is a character object.

\begin{defun}[Function]
standard-char-p char

The argument \emph{char} must be a character object.
\cdf{standard-char-p} is true if the argument is a ``standard character,''
that is, an object of type \cdf{standard-char}.

Note that any character with a non-zero bits or
font attribute is non-standard.
\end{defun}

\begin{defun}[Function]
graphic-char-p char

The argument \emph{char} must be a character object.
\cdf{graphic-char-p} is true if the argument is a ``graphic'' (printing)
character, and false if it is a ``non-graphic'' (formatting or control)
character.  Graphic characters have a standard textual representation
as a single glyph, such as \cdf{A} or \cdf{*} or \cdf{=}.
By convention, the space character is considered to be graphic.
Of the standard characters
all but \cd{\#{\Xbackslash}Newline} are graphic.
The semi-standard characters
\cd{\#{\Xbackslash}Backspace}, \cd{\#{\Xbackslash}Tab}, \cd{\#{\Xbackslash}Rubout}, \cd{\#{\Xbackslash}Linefeed}, \cd{\#{\Xbackslash}Return},
and \cd{\#{\Xbackslash}Page} are not graphic.
\end{defun}

\begin{defun}[Function]
alpha-char-p char

The argument \emph{char} must be a character object.
\cdf{alpha-char-p} is true if the argument is an alphabetic
character, and otherwise is false.

If a character is alphabetic, then it is perforce graphic.
Therefore any character with a non-zero bits attribute cannot be alphabetic.
Whether a character is alphabetic may depend on its font number.

Of the standard characters (as defined by \cdf{standard-char-p}),
the letters \cdf{A} through \cdf{Z} and \cdf{a} through \cdf{z} are alphabetic.
\end{defun}

\begin{defun}[Function]
upper-case-p char \\
lower-case-p char \\
both-case-p char

The argument \emph{char} must be a character object.

\cdf{upper-case-p} is true if the argument is an uppercase
character, and otherwise is false.

\cdf{lower-case-p} is true if the argument is a lowercase
character, and otherwise is false.

\cdf{both-case-p} is true if the argument is an uppercase character and
there is a corresponding lowercase character (which can be obtained
using \cdf{char-downcase}), or if the argument is a lowercase character and
there is a corresponding uppercase character (which can be obtained
using \cdf{char-upcase}).

If a character is either uppercase or lowercase, it is necessarily
alphabetic (and therefore is graphic, and therefore has a zero bits
attribute).  However, it is permissible in theory for an alphabetic
character to be neither uppercase nor lowercase.

Of the standard characters (as defined by \cdf{standard-char-p}),
the letters \cdf{A} through \cdf{Z} are uppercase and \cdf{a}
through \cdf{z} are lowercase.
\end{defun}

\begin{defun}[Function]
digit-char-p char &optional (radix 10)

The argument \emph{char} must be a character object,
and \emph{radix} must be a non-negative integer.
If \emph{char} is not a digit of the radix
specified by \emph{radix}, then \cdf{digit-char-p} is
false; otherwise it returns
a non-negative integer that is the ``weight'' of \emph{char} in that radix.

Digits are necessarily graphic characters.

Of the standard characters (as defined by \cdf{standard-char-p}),
the characters \cd{0} through \cd{9}, \cdf{A} through \cdf{Z},
and \cdf{a} through \cdf{z}
are digits.  The weights of \cd{0} through \cd{9} are the integers 0 through 9,
and of \cdf{A} through \cdf{Z} (and also \cdf{a} through \cdf{z}) are 10 through 35.
\cdf{digit-char-p} returns the weight for one of these digits if and only if
its weight is strictly less than \emph{radix}.  Thus, for example,
the digits for radix 16 are
\begin{lisp}
0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
\end{lisp}

Here is an example of the use of \cdf{digit-char-p}:
\begin{lisp}
(defun convert-string-to-integer (str \&optional (radix 10)) \\
~~"Given a digit string and optional radix, return an integer." \\
~~(do ((j 0 (+ j 1)) \\
~~~~~~~(n 0 (+ (* n radix) \\
~~~~~~~~~~~~~~~(or (digit-char-p (char str j) radix) \\
~~~~~~~~~~~~~~~~~~~(error "Bad radix-{\Xtilde}D digit: {\Xtilde}C" \\
~~~~~~~~~~~~~~~~~~~~~~~~~~radix \\
~~~~~~~~~~~~~~~~~~~~~~~~~~(char str j)))))) \\
~~~~~~((= j (length str)) n)))
\end{lisp}
\end{defun}

\begin{defun}[Function]
alphanumericp char

The argument \emph{char} must be a character object.
\cdf{alphanumericp} is true if \emph{char} is either alphabetic
or numeric.  By definition,
\begin{lisp}
(alphanumericp x) \\
~~~\EQ\ (or (alpha-char-p x) (not (null (digit-char-p x))))
\end{lisp}
Alphanumeric characters are therefore necessarily graphic
(as defined by the predicate \cdf{graphic-char-p}).

Of the standard characters (as defined by \cdf{standard-char-p}),
the characters \cd{0} through \cd{9}, \cdf{A} through \cdf{Z},
and \cdf{a} through \cdf{z} are alphanumeric.
\end{defun}

\begin{defun}[Function]
char= character &rest more-characters \\
char/= character &rest more-characters \\
char< character &rest more-characters \\
char> character &rest more-characters \\
char<= character &rest more-characters \\
char>= character &rest more-characters

The arguments must all be character objects.
These functions compare the objects using the implementation-dependent
total ordering on characters, in a manner analogous to numeric
comparisons by \cdf{=} and related functions.

The total ordering on characters is guaranteed to have the following
properties:
\begin{itemize}
\item
The standard alphanumeric characters obey the following partial ordering:
\begin{lisp}
A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z \\
a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y<z \\
0<1<2<3<4<5<6<7<8<9 \\
\emph{either} 9<A \emph{or} Z<0 \\
\emph{either} 9<a \emph{or} z<0
\end{lisp}
This implies that alphabetic ordering holds within each case (upper and
lower), and that the digits as a group
are not interleaved with letters.  However, the ordering
or possible interleaving of
uppercase letters and lowercase letters is unspecified.
(Note that both the ASCII and the EBCDIC character sets
conform to this specification.  As it happens, neither ordering
interleaves uppercase and lowercase letters:
in the ASCII ordering, \cd{9<A} and \cd{Z<a},
whereas in the EBCDIC ordering \cd{z<A} and \cd{Z<0}.)
\end{itemize}

The total ordering is not necessarily the same as the total
ordering on the integers produced by applying \cdf{char-int} to the
characters (although it is a reasonable implementation technique to
use that ordering).

While alphabetic characters of a given case must be
properly ordered, they need not be contiguous; thus \cd{(char<= \#{\Xbackslash}a x
\#{\Xbackslash}z)} is \emph{not} a valid way of determining whether or not \cdf{x} is a
lowercase letter.  That is why a separate
\cdf{lower-case-p} predicate is provided.

\begin{lisp}
(char= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is true.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is false.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{is false.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{is true.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}D) \textrm{is false.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}D) \textrm{is true.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is true.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is false.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}x \#{\Xbackslash}d) \textrm{is false.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}x \#{\Xbackslash}d) \textrm{is false.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}y \#{\Xbackslash}x \#{\Xbackslash}c) \textrm{is false.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}y \#{\Xbackslash}x \#{\Xbackslash}c) \textrm{is true.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}d) \textrm{is false.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}d) \textrm{is false.} \\
(char< \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{is true.} \\
(char<= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{is true.} \\
(char< \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is false.} \\
(char<= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is true.} \\
(char< \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}y \#{\Xbackslash}z) \textrm{is true.} \\
(char<= \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}y \#{\Xbackslash}z) \textrm{is true.} \\
(char< \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}e \#{\Xbackslash}y) \textrm{is false.} \\
(char<= \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}e \#{\Xbackslash}y) \textrm{is true.} \\
(char> \#{\Xbackslash}e \#{\Xbackslash}d) \textrm{is true.} \\
(char>= \#{\Xbackslash}e \#{\Xbackslash}d) \textrm{is true.} \\
(char> \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}b \#{\Xbackslash}a) \textrm{is true.} \\
(char>= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}b \#{\Xbackslash}a) \textrm{is true.} \\
(char> \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{is false.} \\
(char>= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{is true.} \\
(char> \#{\Xbackslash}e \#{\Xbackslash}d \#{\Xbackslash}b \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{is false.} \\
(char>= \#{\Xbackslash}e \#{\Xbackslash}d \#{\Xbackslash}b \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{is false.} \\
(char> \#{\Xbackslash}z \#{\Xbackslash}A) \textrm{may be true or false.} \\
(char> \#{\Xbackslash}Z \#{\Xbackslash}a) \textrm{may be true or false.}
\end{lisp}

There is no requirement that \cd{(eq c1 c2)} be true merely because
\cd{(char= c1 c2)} is true.  While \cdf{eq} may distinguish two character
objects that \cdf{char=} does not, it is distinguishing them not
as \emph{characters}, but in some sense on the basis of a lower-level
implementation characteristic.
(Of course, if \cd{(eq c1 c2)} is true,
then one may expect \cd{(char= c1 c2)} to be true.)
However, \cdf{eql} and \cdf{equal}
compare character objects in the same
way that \cdf{char=} does.
\end{defun}

\begin{defun}[Function]
char-equal character &rest more-characters \\
char-not-equal character &rest more-characters \\
char-lessp character &rest more-characters \\
char-greaterp character &rest more-characters \\
char-not-greaterp character &rest more-characters \\
char-not-lessp character &rest more-characters

For the standard characters, the ordering is such that
\cd{A=a}, \cd{B=b}, and so on, up to \cd{Z=z}, and furthermore either
\cd{9<A} or \cd{Z<0}.
For example:
\begin{lisp}
(char-equal \#{\Xbackslash}A \#{\Xbackslash}a) \textrm{is true.} \\
(char= \#{\Xbackslash}A \#{\Xbackslash}a) \textrm{is false.} \\
(char-equal \#{\Xbackslash}A \#{\Xbackslash}Control-A) \textrm{is true.}
\end{lisp}
\end{defun}

\section{Character Construction and Selection}

These functions may be used to extract attributes of a character
and to construct new characters.

\begin{defun}[Function]
char-code char

The argument \emph{char} must be a character object.
\cdf{char-code} returns the code attribute of the character object;
this will be a non-negative integer less than the (normal) value of
the variable \cdf{char-code-limit}.

This is usually what you need in order to treat a character as an
index into a vector.  The length of the vector should then be
equal to \cdf{char-code-limit}.  Be careful how you initialize this
vector; remember that you cannot necessarily
expect all non-negative integers less than
\cdf{char-code-limit} to be valid character codes.
\end{defun}

\begin{defun}[Function]
code-char code

Returns a character with the code attribute given by code. If no such character
exists and one cannot be created, nil is returned.
For example:
\begin{lisp}
(char= (code-char (char-code c)) c)
\end{lisp}
\end{defun}

\section{Character Conversions}

These functions perform various transformations on characters,
including case conversions.

\begin{defun}[Function]
character object

The function \cdf{character} coerces its argument to be a character
if possible; see \cdf{coerce}.
\begin{lisp}
(character x) \EQ\ (coerce x 'character)
\end{lisp}
\end{defun}

\begin{defun}[Function]
char-upcase char \\
char-downcase char

The argument \emph{char} must be a character object.
\cdf{char-upcase} attempts to convert its argument to an uppercase
equivalent; \cdf{char-downcase} attempts to convert its argument
to a lowercase equivalent.
\end{defun}

\begin{defun}[Function]
digit-char weight &optional (radix 10)

All arguments must be integers.  \cdf{digit-char}
determines whether or not it is possible to construct
a character object whose \emph{code} is such that the
result character has the weight \emph{weight} when considered as
a digit of the radix \emph{radix} (see the predicate \cdf{digit-char-p}).
It returns such a character if that is possible, and otherwise returns {\false}.

\cdf{digit-char} cannot return {\false} \emph{radix} is between 2 and 36
inclusive, and \emph{weight} is non-negative and less than \emph{radix}.

If more than one character object can encode
such a weight in the given radix, one will be chosen consistently
by any given implementation; moreover, among the standard characters,
uppercase letters are preferred to lowercase letters.
For example:
\begin{lisp}
(digit-char 7) \EV\ \#{\Xbackslash}7 \\
(digit-char 12) \EV\ {\false} \\
(digit-char 12 16) \EV\ \#{\Xbackslash}C~~~~~;\textrm{not} \#{\Xbackslash}c \\
(digit-char 6 2) \EV\ {\false} \\
(digit-char 1 2) \EV\ \#{\Xbackslash}1
\end{lisp}
\end{defun}

\begin{defun}[Function]
char-int char

The argument \emph{char} must be a character object.
\cdf{char-int} returns a non-negative integer encoding the character object.

\cdf{char-int} returns the same integer \cdf{char-code}.
Also,
\begin{lisp}
(char= c1 c2) \EQ\ (= (char-int c1) (char-int c2))
\end{lisp}
for characters \cd{c1} and \cd{c2}.

This function is provided primarily for the purpose of hashing characters.
\end{defun}

\begin{defun}[Function]
char-name char

The argument \emph{char} must be a character object.
If the character has a name, then that name (a string) is returned;
otherwise {\false} is returned.  All characters that are non-graphic
(do not satisfy the predicate \cdf{graphic-char-p}) have names.
Graphic characters may or may not have names.

The standard newline and space characters have the respective
names \cdf{Newline} and \cdf{Space}.
The semi-standard characters have the names
\cdf{Tab}, \cdf{Page}, \cdf{Rubout}, \cdf{Linefeed}, \cdf{Return}, and \cdf{Backspace}.

Characters that have names can be notated as \cd{\#{\Xbackslash}} followed
by the name.  (See section~\ref{SHARP-SIGN-MACRO-CHARACTER-SECTION}.)
Although the name may be written in any case,
it is stylish to capitalize it thus: \cd{\#{\Xbackslash}Space}.
\end{defun}

\begin{defun}[Function]
name-char name

The argument \emph{name} must be an object coerceable to a string
as if by the function \cdf{string}.
If the name is the same as the name of a character object
(as determined by \cdf{string-equal}), that object
is returned; otherwise {\false} is returned.
\end{defun}

\else %RUSSIAN

\chapter{Буквы}

Common Lisp содержит тип данных буквы.

Буквы в Common Lisp'е не совсем объекты. Нельзя положится на то, что
\cdf{eq} будет работать с ними правильно. В частности, возможно что выражение
\begin{lisp}
(let ((x z) (y z)) (eq x y))
\end{lisp}
будет ложным, а не истинным, если значение \cdf{z} является буквой.

\beforenoterule
\begin{rationale}
Необязательное равенство букв с помощью \cdf{eq} позволяет разработчикам реализации
сделать оптимизации на тех архитектурах, где это удобно. Такое же правило
сделано и для чисел, смотрите главу~\ref{NUMBER}.
\end{rationale}
\afternoterule

\begin{table}
\caption{Стандартные метки букв, символы и описания}
\label{STANDARD-CHAR-REPERTOIRE-TABLE}
\tabcolsep0pt
\def\arraystretch{1.1}

\begin{tabular*}{\textwidth}{@{}l@{\extracolsep{\fill}}llllllll@{}}
           &&&\cd{SM05}&\cd{{\Xatsign}}&\textrm{собака}&\cd{SD13}&\cd{{\Xbq}}&\textrm{обратная кавычка} \\
\cd{SP02}&\cd{!}&\textrm{восклицательный знак}&\cd{LA02}&\cdf{A}&\textrm{прописная A}&\cd{LA01}&\cdf{a}&\textrm{маленькая a} \\
\cd{SP04}&\cd{"}&\textrm{двойная кавычка}&\cd{LB02}&\cdf{B}&\textrm{прописная B}&\cd{LB01}&\cdf{b}&\textrm{маленькая b} \\
\cd{SM01}&\cd{\#}&\textrm{диез, решётка}&\cd{LC02}&\cdf{C}&\textrm{прописная C}&\cd{LC01}&\cdf{c}&\textrm{маленькая c} \\
\cd{SC03}&\cd{\$}&\textrm{знак доллара}&\cd{LD02}&\cdf{D}&\textrm{прописная D}&\cd{LD01}&\cdf{d}&\textrm{маленькая d} \\
\cd{SM02}&\cd{\%}&\textrm{знак процента}&\cd{LE02}&\cdf{E}&\textrm{прописная E}&\cd{LE01}&\cdf{e}&\textrm{маленькая e} \\
\cd{SM03}&\cd{\&}&\textrm{амперсанд}&\cd{LF02}&\cdf{F}&\textrm{прописная F}&\cd{LF01}&\cdf{f}&\textrm{маленькая f} \\
\cd{SP05}&\cd{'}&\textrm{апостроф}&\cd{LG02}&\cdf{G}&\textrm{прописная G}&\cd{LG01}&\cdf{g}&\textrm{маленькая g} \\
\cd{SP06}&\cd{(}&\textrm{левая круглая скобка}&\cd{LH02}&\cdf{H}&\textrm{прописная H}&\cd{LH01}&\cdf{h}&\textrm{маленькая h} \\
\cd{SP07}&\cd{)}&\textrm{права круглая скобка}&\cd{LI02}&\cdf{I}&\textrm{прописная I}&\cd{LI01}&\cdf{i}&\textrm{маленькая i} \\
\cd{SM04}&\cdf{*}&\textrm{звёздочка}&\cd{LJ02}&\cdf{J}&\textrm{прописная J}&\cd{LJ01}&\cdf{j}&\textrm{маленькая j} \\
\cd{SA01}&\cdf{+}&\textrm{знак плюс}&\cd{LK02}&\cdf{K}&\textrm{прописная K}&\cd{LK01}&\cdf{k}&\textrm{маленькая k} \\
\cd{SP08}&\cd{,}&\textrm{запятая}&\cd{LL02}&\cdf{L}&\textrm{прописная L}&\cd{LL01}&\cdf{l}&\textrm{маленькая l} \\
\cd{SP10}&\cdf{-}&\textrm{дефис или знак минус}&\cd{LM02}&\cdf{M}&\textrm{прописная M}&\cd{LM01}&\cdf{m}&\textrm{маленькая m} \\
\cd{SP11}&\cd{.}&\textrm{точка}&\cd{LN02}&\cdf{N}&\textrm{прописная N}&\cd{LN01}&\cdf{n}&\textrm{маленькая n} \\
\cd{SP12}&\cdf{/}&\textrm{слеш}&\cd{LO02}&\cdf{O}&\textrm{прописная O}&\cd{LO01}&\cdf{o}&\textrm{маленькая o} \\
\cd{ND10}&\cd{0}&\textrm{цифра 0}&\cd{LP02}&\cdf{P}&\textrm{прописная P}&\cd{LP01}&\cdf{p}&\textrm{маленькая p} \\
\cd{ND01}&\cd{1}&\textrm{цифра 1}&\cd{LQ02}&\cdf{Q}&\textrm{прописная Q}&\cd{LQ01}&\cdf{q}&\textrm{маленькая q} \\
\cd{ND02}&\cd{2}&\textrm{цифра 2}&\cd{LR02}&\cdf{R}&\textrm{прописная R}&\cd{LR01}&\cdf{r}&\textrm{маленькая r} \\
\cd{ND03}&\cd{3}&\textrm{цифра 3}&\cd{LS02}&\cdf{S}&\textrm{прописная S}&\cd{LS01}&\cdf{s}&\textrm{маленькая s} \\
\cd{ND04}&\cd{4}&\textrm{цифра 4}&\cd{LT02}&\cdf{T}&\textrm{прописная T}&\cd{LT01}&\cdf{t}&\textrm{маленькая t} \\
\cd{ND05}&\cd{5}&\textrm{цифра 5}&\cd{LU02}&\cdf{U}&\textrm{прописная U}&\cd{LU01}&\cdf{u}&\textrm{маленькая u} \\
\cd{ND06}&\cd{6}&\textrm{цифра 6}&\cd{LV02}&\cdf{V}&\textrm{прописная V}&\cd{LV01}&\cdf{v}&\textrm{маленькая v} \\
\cd{ND07}&\cd{7}&\textrm{цифра 7}&\cd{LW02}&\cdf{W}&\textrm{прописная W}&\cd{LW01}&\cdf{w}&\textrm{маленькая w} \\
\cd{ND08}&\cd{8}&\textrm{цифра 8}&\cd{LX02}&\cdf{X}&\textrm{прописная X}&\cd{LX01}&\cdf{x}&\textrm{маленькая x} \\
\cd{ND09}&\cd{9}&\textrm{цифра 9}&\cd{LY02}&\cdf{Y}&\textrm{прописная Y}&\cd{LY01}&\cdf{y}&\textrm{маленькая y} \\
\cd{SP13}&\cd{:}&\textrm{двоеточие}&\cd{LZ02}&\cdf{Z}&\textrm{прописная Z}&\cd{LZ01}&\cdf{z}&\textrm{маленькая z} \\
\cd{SP14}&\cd{;}&\textrm{точка с запятой}&\cd{SM06}&\cd{{\Xlbracket}}&\textrm{левая квадратная скобка}&\cd{SM11}&\cd{{\Xlbrace}}&\textrm{левая фигурная скобка} \\
\cd{SA03}&\cdf{<}&\textrm{знак меньше чем}&\cd{SM07}&\cd{{\Xbackslash}}&\textrm{обратный слеш}&\cd{SM13}&\cd{|}&\textrm{вертикальная черта} \\
\cd{SA04}&\cdf{=}&\textrm{знак равенства}&\cd{SM08}&\cd{{\Xrbracket}}&\textrm{правая квадратная скобка}&\cd{SM14}&\cd{{\Xrbrace}}&\textrm{правая фигурная скобка} \\
\cd{SA05}&\cdf{>}&\textrm{знак больше чем}&\cd{SD15}&\cd{{\Xcircumflex}}&\textrm{крыша}&\cd{SD19}&\cd{{\Xtilde}}&\textrm{тильда} \\
\cd{SP15}&\cd{?}&\textrm{вопросительный знак}&\cd{SP09}&\cd{{\Xunderscore}}&\textrm{знак подчёркивания}&
\end{tabular*}
\vfill
\begin{small}
\noindent
Символы в этой таблице, а также пробел и символы новой строки составляют
стандартный набор букв для Common Lisp'а (тип \cdf{standard-char}).
Метки символов и описания символов взяты из ISO 6937/2. Первый символ на метке
классифицирует символ как Latin, Numeric или Special.
\end{small}
\end{table}

Для сравнения двух объектов, один из которых может быть буквой, необходимо
использовать предикат \cdf{eql}.

\section{Свойство букв}

\begin{defun}[Константа]
char-code-limit

Значением \cdf{char-code-limit} является неотрицательное целое число, которое
отображает наибольшее из возможных значений функции \cdf{char-code}
невключительно. То есть значения, возвращаемые \cdf{char-code} неотрицательны и
строго меньше чем значение \cdf{char-code-limit}.

Common Lisp не гарантирует, что все целые числа между нулём и
\cdf{char-code-limit} являются корректными кодами для символов.
\end{defun}

\section{Предикаты для букв}

Предикат \cdf{characterp} используется для определения, является ли
Lisp'овый объект буквой. 

\begin{defun}[Функция]
standard-char-p char

Аргумент \emph{char} должен быть буквой.  \cdf{standard-char-p}
истинен, если аргумент является <<стандартной буквой>>, то есть объект
принадлежит типу \cdf{standard-char}.
\end{defun}

\begin{defun}[Функция]
graphic-char-p char

Аргумент \emph{char} должен быть буквой.
\cdf{graphic-char-p} истинен, если аргумент является <<графическим>> (выводимым)
символом, или ложен, если аргумент является <<неграфическим>> (форматирующим или
управляющим) символом. Графические символы имеют стандартное текстовое
представление в качестве одного знака, такого как например \cdf{A} или \cdf{*}
или \cdf{=}.
По соглашению, символы пробела рассматриваются как графические.
Все стандартные символы за исключением \cd{\#{\Xbackslash}Newline} являются
графическими.
Не совсем стандартные символы
\cd{\#{\Xbackslash}Backspace}, \cd{\#{\Xbackslash}Tab},
\cd{\#{\Xbackslash}Rubout}, \cd{\#{\Xbackslash}Linefeed},
\cd{\#{\Xbackslash}Return} и  \cd{\#{\Xbackslash}Page} графическими не являются.
\end{defun}

\begin{defun}[Функция]
alpha-char-p char

Аргумент \emph{char} должен быть буквой.
\cdf{alpha-char-p} истинен, если аргумент являются алфавитным символом, иначе
предикат ложен.

Если символ является алфавитным, тогда он является графическим.

Из стандартных символов (как определено с помощью \cdf{standard-char-p}), буквы
c \cdf{A} по \cdf{Z} и с \cdf{a} по \cdf{z} являются алфавитными.
\end{defun}

\begin{defun}[Функция]
upper-case-p char \\
lower-case-p char \\
both-case-p char

Аргумент \emph{char} должен быть буквой.

\cdf{upper-case-p} истинен, если аргумент является символом в верхнем регистре,
иначе ложен.

\cdf{lower-case-p} истинен, если аргумент является символом в нижнем регистре,
иначе ложен.

\cdf{both-case-p} истинен, если аргумент является символом в верхнем регистре,
и для этого символа существует аналогичный в нижнем регистре (это может быть
установлено с помощью \cdf{char-downcase}), или если аргумент является символом
в нижнем регистре, 
и для этого символа существует аналогичный в верхнем регистре (это может быть
установлено с помощью \cdf{char-upcase}).

Из стандартных символов (как определено с помощью \cdf{standard-char-p}), буквы
c \cdf{A} по \cdf{Z} имеют верхний регистр и буквы с \cdf{a} по \cdf{z} нижний.
\end{defun}

\begin{defun}[Функция]
digit-char-p char &optional (radix 10)

Аргумент \emph{char} должен быть буквой, и \emph{radix}
неотрицательным целым числом.
Если \emph{char} не является цифрой для указанной в \emph{radix} системы
счисления, тогда \cdf{digit-char-p} ложен, иначе предикат возвращает значение
данного символа в этой системе счисления.

Цифры принадлежат графическим символам.

Из стандартных символов (как определено с помощью \cdf{standard-char-p}),
символы с \cd{0} по \cd{9}, с \cd{A} по \cd{Z} и с \cd{a} по \cd{z} являются
цифровыми. Веса c \cd{0} по \cd{9} совпадают с числами с 0 по 9, и с \cd{A} по
\cd{Z} (а также с \cdf{a} по \cd{z}) совпадают с числами с 10 по 35.
\cdf{digit-char-p} возвращает вес одной их этих цифр тогда и только тогда, когда
их вес строго меньше чем \emph{radix}. Таким образом, например, цифры для
шестнадцатеричной системы счисления будут такими
\begin{lisp}
0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
\end{lisp}

Пример использования \cdf{digit-char-p}:
\begin{lisp}
(defun convert-string-to-integer (str \&optional (radix 10)) \\
~~"Принимает строку и опционально систему счисления, возвращает целое число." \\
~~(do ((j 0 (+ j 1)) \\
~~~~~~~(n 0 (+ (* n radix) \\
~~~~~~~~~~~~~~~(or (digit-char-p (char str j) radix) \\
~~~~~~~~~~~~~~~~~~~(error "Bad radix-{\Xtilde}D digit: {\Xtilde}C" \\
~~~~~~~~~~~~~~~~~~~~~~~~~~radix \\
~~~~~~~~~~~~~~~~~~~~~~~~~~(char str j)))))) \\
~~~~~~((= j (length str)) n)))
\end{lisp}
\end{defun}

\begin{defun}[Функция]
alphanumericp char

Аргумент \emph{char} должен быть буквой.
Предикат \cdf{alphanumericp} истинен, если \emph{char} является буквой или
цифрой. Определение:
\begin{lisp}
(alphanumericp x) \\
~~~\EQ\ (or (alpha-char-p x) (not (null (digit-char-p x))))
\end{lisp}
Таким образом алфавитно-цифровой символ обязательно является графическим (в
соответствии с предикатом \cdf{graphic-char-p}).

Из стандартных символов (в соответствие с предикатом \cdf{standard-char-p}),
символы с \cd{0} по \cd{9}, с \cdf{A} по \cdf{Z}, с \cdf{a} по \cdf{z} являются
алфавитно-цифровыми.
\end{defun}

\begin{defun}[Функция]
char= character &rest more-characters \\
char/= character &rest more-characters \\
char< character &rest more-characters \\
char> character &rest more-characters \\
char<= character &rest more-characters \\
char>= character &rest more-characters

Все аргументы должны быть строковыми символами.
Данный функции сравнивают символы методом зависящим от реализации.

Порядок расположения букв гарантированно удовлетворяет следующим
правилам:
\begin{itemize}
\item
Стандартные алфавитно-цифровые символы подчиняются следующему порядку:
\begin{lisp}
A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z \\
a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y<z \\
0<1<2<3<4<5<6<7<8<9 \\
\emph{одно из двух} 9<A \emph{или} Z<0 \\
\emph{одно из двух} 9<a \emph{или} z<0
\end{lisp}
\end{itemize}

Порядок следования символов необязательно совпадает с порядком следования их
кодов, полученных из функции \cdf{char-int}.

Порядок следование символов не является неразрывным.
Таким образом выражение \cd{(char<= \#{\Xbackslash}a x
\#{\Xbackslash}z)} нельзя использовать для проверки является ли \cdf{x} символом
в нижнем регистре. Для этого предназначен предикат \cdf{lower-case-p}. 

\begin{lisp}
(char= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{истина.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{ложь.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{ложь.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{истина.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}D) \textrm{ложь.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}D) \textrm{истина.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{истина.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{ложь.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}x \#{\Xbackslash}d) \textrm{ложь.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}x \#{\Xbackslash}d) \textrm{ложь.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}y \#{\Xbackslash}x \#{\Xbackslash}c) \textrm{ложь.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}y \#{\Xbackslash}x \#{\Xbackslash}c) \textrm{истина.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}d) \textrm{ложь.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}d) \textrm{ложь.} \\
(char< \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{истина.} \\
(char<= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{истина.} \\
(char< \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{ложь.} \\
(char<= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{истина.} \\
(char< \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}y \#{\Xbackslash}z) \textrm{истина.} \\
(char<= \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}y \#{\Xbackslash}z) \textrm{истина.} \\
(char< \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}e \#{\Xbackslash}y) \textrm{ложь.} \\
(char<= \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}e \#{\Xbackslash}y) \textrm{истина.} \\
(char> \#{\Xbackslash}e \#{\Xbackslash}d) \textrm{истина.} \\
(char>= \#{\Xbackslash}e \#{\Xbackslash}d) \textrm{истина.} \\
(char> \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}b \#{\Xbackslash}a) \textrm{истина.} \\
(char>= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}b \#{\Xbackslash}a) \textrm{истина.} \\
(char> \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{ложь.} \\
(char>= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{истина.} \\
(char> \#{\Xbackslash}e \#{\Xbackslash}d \#{\Xbackslash}b \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{ложь.} \\
(char>= \#{\Xbackslash}e \#{\Xbackslash}d \#{\Xbackslash}b \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{ложь.} \\
(char> \#{\Xbackslash}z \#{\Xbackslash}A) \textrm{может быть истиной или ложью.} \\
(char> \#{\Xbackslash}Z \#{\Xbackslash}a) \textrm{может быть истиной или ложью.}
\end{lisp}

Если и \cd{(char= c1 c2)} является истиной, то \cd{(eq c1 c2)} истиной может и
не являться. 
\cdf{eq} сравнивает буквы не как символы, а как объекты с различием
в свойствах, которое зависит от конкретной реализации.
(Конечно, если \cd{(eq c1 c2)} истинно, то \cd{(char= c1 c2)} также будет
истинно.)
Однако, \cdf{eql} и \cdf{equal} сравнивают буквы также как и
\cdf{char=}.
\end{defun}

\begin{defun}[Функция]
char-equal character &rest more-characters \\
char-not-equal character &rest more-characters \\
char-lessp character &rest more-characters \\
char-greaterp character &rest more-characters \\
char-not-greaterp character &rest more-characters \\
char-not-lessp character &rest more-characters

Для стандартных символов порядок между ними такой, что выполняются равенства
\cd{A=a}, \cd{B=b} и так до \cd{Z=z}, а также выполняется одно из двух
неравенств \cd{9<A} или \cd{Z<0}.
\begin{lisp}
(char-equal \#{\Xbackslash}A \#{\Xbackslash}a) \textrm{истина.} \\
(char= \#{\Xbackslash}A \#{\Xbackslash}a) \textrm{ложь.} \\
(char-equal \#{\Xbackslash}A \#{\Xbackslash}Control-A) \textrm{истина.}
\end{lisp}
\end{defun}

\section{Код символа}

\begin{defun}[Функция]
char-code char

Аргумента \emph{char} должен быть строковым объектом.
\cdf{char-code} возвращает код символа, а именно неотрицательное целое число,
меньшее чем значение переменной \cdf{char-code-limit}.

Однако помните, не все целые числа на это промежутке могут быть корректными
отображениями символов.
\end{defun}

\begin{defun}[Функция]
code-char code

Возвращает букву для заданного кода. Если для этого кода буквы не
существует, тогда возвращается {\nil}.
Например:
\begin{lisp}
(char= (code-char (char-code c)) c)
\end{lisp}
\end{defun}

\section{Преобразование букв}

Данные функции выполняют различные преобразования букв, включая изменение
регистра.

\begin{defun}[Функция]
character object

Функция \cdf{character} если возможно возвращает преобразованный в символ
аргумент \emph{object}. Смотрите \cdf{coerce}.
\begin{lisp}
(character x) \EQ\ (coerce x 'character)
\end{lisp}
\end{defun}

\begin{defun}[Функция]
char-upcase char \\
char-downcase char

Аргумент \emph{char} должен быть буквой.
\cdf{char-upcase} пытается возвести символ в верхний
регистр. \cdf{char-downcase} пытается возвести символ в нижний регистр.
\end{defun}

\begin{defun}[Функция]
digit-char weight &optional (radix 10)

Все аргументы должны быть целыми числами. \cdf{digit-char} устанавливает может
ли быть создан символ, у которого код \emph{code} такой, что итоговый символ
имеет вес \emph{weight}, когда рассматривается как цифра системы счисления
\emph{radix} (смотрите предикат \cdf{digit-char-p}).
В случае успеха возвращается этот символ, иначе {\false}.

\cdf{digit-char} не может вернуть {\false}, если \emph{radix} находится между 2
и 36 включительно и \emph{weight} имеет неотрицательное значение и меньше чем
\emph{radix}.

Если для результата подходят несколько символов, выбор лежит на плечах
реализации. Но символы в верхнем регистре предпочтительнее символов в нижем.
Например:
\begin{lisp}
(digit-char 7) \EV\ \#{\Xbackslash}7 \\
(digit-char 12) \EV\ {\false} \\
(digit-char 12 16) \EV\ \#{\Xbackslash}C~~~~~;\textrm{not} \#{\Xbackslash}c \\
(digit-char 6 2) \EV\ {\false} \\
(digit-char 1 2) \EV\ \#{\Xbackslash}1
\end{lisp}
\end{defun}

\begin{defun}[Функция]
char-int char

Аргумент \emph{char} должен быть буквой.
\cdf{char-int} возвращает неотрицательный целый числовой код символа.

Следует отметить, что
\begin{lisp}
(char= c1 c2) \EQ\ (= (char-int c1) (char-int c2))
\end{lisp}
для любых символов \cd{c1} и \cd{c2}

Данная функция создана в основном для хеширования символов.
\end{defun}

\begin{defun}[Функция]
char-name char

Аргумент \emph{char} должен быть буквой.
Если буква имеет имя, то результатом будет это имя (в виде строки),
иначе результат будет {\false}. Имена есть у всех неграфических (не
удовлетворяющих предикату \cdf{graphic-char-p}).

Стандартные символы перевода строки и проблема имеют имена \cdf{Newline} и
\cdf{Space}.
Полустандартные символы имеют имена 
\cdf{Tab}, \cdf{Page}, \cdf{Rubout}, \cdf{Linefeed}, \cdf{Return} и \cdf{Backspace}.

Символы, у которых есть имена, могут быть заданы с помощью \cd{\#{\Xbackslash}}
и последующего имени. (Смотрите
раздел~\ref{SHARP-SIGN-MACRO-CHARACTER-SECTION}.)
Имя может быть записано в любом регистре, но основной стиль предполагает запись
просто с большой буквы \cd{\#{\Xbackslash}Space}.
\end{defun}

\begin{defun}[Функция]
name-char name

Аргумент \emph{name} должен быть объектом, который можно превратить в строку,
например, с помощью функции \cdf{string}.
Если имя совпадает с именем некоторого строкового символа (проверка
осуществляется с помощью \cdf{string-equal}), тогда будет
возвращён этот символ, иначе возвращается {\false}.
\end{defun}

\fi