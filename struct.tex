%Part{Struct, Root = "CLM.MSS"}
%%%Chapter of Common Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\ifx \rulang\Undef

\chapter{Structures}

Common Lisp provides a facility for creating named record structures
with named components.  In effect, the user can define a new data type;
every data structure of that type has components with specified names.
Constructor, access, and assignment constructs are automatically
defined when the data type is defined.

This chapter is divided into two parts.  The first part discusses
the basics of the structure facility, which is very simple and allows
the user to take advantage of the type-checking, modularity, and
convenience of user-defined record data types.  The second part,
beginning with section~\ref{Defstruct-Hairy-Stuff},
discusses a number of specialized features of the facility that
have advanced applications.  These features are completely optional,
and you needn't even know they exist in order to take
advantage of the basics.

\section{Introduction to Structures}
\label{DEFSTRUCT-INTRO-SECTION}

The structure facility is embodied in the \cdf{defstruct} macro,
which allows the user to create and use
aggregate data types with named elements.  These are like
``structures'' in {PL/I}, or ``records'' in Pascal.

As an example, assume you are writing a Lisp
program that deals with space ships in a two-dimensional plane.
In your program, you need to
represent a space ship by a Lisp object of some kind.  The interesting
things about a space ship, as far as your program is concerned, are
its position (represented as \emph{x} and \emph{y} coordinates),
velocity (represented as components along the \emph{x} and \emph{y} axes), and
mass.

A ship might therefore be represented as a record structure with five
components: \emph{x}-position, \emph{y}-position, \emph{x}-velocity, \emph{y}-velocity, and mass.
This structure could in turn be implemented as a Lisp object in a
number of ways.  It could be a list of five elements; the \emph{x}-position
could be the \emph{car}, the \emph{y}-position the \emph{cadr}, and so on.  Equally
well it could be a vector of five elements: the \emph{x}-position could be
element 0, the \emph{y}-position element 1, and so on.  The problem with either
of these representations is that the components occupy places in the
object that are quite arbitrary and hard to remember.  Someone looking at
\cd{(cadddr~ship1)} or \cd{(aref~ship1~3)} in a piece of code might
find it difficult to determine that this is accessing the \emph{y}-velocity
component of \cd{ship1}.  Moreover, if the representation of a ship should
have to be changed, it would be very difficult to find all the places
in the code to be changed to match (not all occurrences of \cdf{cadddr}
are intended to extract the \emph{y}-velocity from a ship).

Ideally components of record structures should have names.  One would
like to write something like
\cd{(ship-y-velocity ship1)} instead of \cd{(cadddr ship1)}.
One would also like a more mnemonic way to create a ship than this:
\begin{lisp}
(list 0 0 0 0 0)
\end{lisp}
Indeed, one would like \cdf{ship} to be a new data type, just like other
Lisp data types, that one could test with \cdf{typep}, for example.
The \cdf{defstruct} facility provides all of this.

\cdf{defstruct} itself is a macro that defines a structure.  For the
space ship example, one might define the structure by saying:
\begin{lisp}
(defstruct ship \\
~~x-position \\
~~y-position \\
~~x-velocity \\
~~y-velocity \\
~~mass)
\end{lisp}
This declares that every \cdf{ship} is an object with five named components.
The evaluation of this form does several things:

\begin{itemize}
\item
It defines \cdf{ship-x-position} to be a function
of one argument, a ship, that returns the \emph{x}-position
of the ship; \cdf{ship-y-position}
and the other components are given similar function definitions.
These functions are called the \emph{access functions}, as they
are used to access elements of the structure.

\item
The symbol \cdf{ship} becomes the name of a data type of which instances
of ships are elements.  This name becomes acceptable to \cdf{typep},
for example; \cd{(typep x 'ship)} is true if \cdf{x} is a ship
and false if \cdf{x} is any object other than a ship.

\item
A function named \cdf{ship-p} of one argument is defined; it is a predicate
that is true if its argument is a ship and is false otherwise.

\item
A function called \cdf{make-ship} is defined that, when invoked,
will create a data structure with five components, suitable for use with
the access functions.  Thus executing
\begin{lisp}
(setq ship2 (make-ship))
\end{lisp}
sets \cd{ship2} to a newly created \cdf{ship} object.
One can specify the initial values of any desired component in the call
to \cdf{make-ship} by using keyword arguments in this way:
\begin{lisp}
(setq ship2 (make-ship \cd{:mass} *default-ship-mass* \\
~~~~~~~~~~~~~~~~~~~~~~~\cd{:x-position} 0 \\
~~~~~~~~~~~~~~~~~~~~~~~\cd{:y-position} 0))
\end{lisp}
This constructs a new ship and initializes three of its components.
This function is called the \emph{constructor function}
because it constructs a new structure.

\item
The \cd{\#S} syntax can be used to read instances of \cdf{ship}
structures, and a printer function is provided for printing
out ship structures.  For example, the value of the
variable \cd{ship2} shown above might be printed as
\begin{lisp}
\#S(ship  x-position 0  y-position 0  x-velocity nil \\
~~~~~~~~~y-velocity nil  mass 170000.0)
\end{lisp}

\item
A function called \cdf{copy-ship} of one argument
is defined that, when given a \cdf{ship} object,
will create a new \cdf{ship} object that is a copy of the given one.
This function is called the \emph{copier function}.

\item
One may use \cdf{setf} to alter the components of a \cdf{ship}:
\begin{lisp}
(setf (ship-x-position ship2) 100)
\end{lisp}
This alters the \emph{x}-position of \emph{ship2} to be \cd{100}.
This works because \cdf{defstruct} behaves as if
it generates an appropriate \cdf{defsetf}
form for each access function.
\end{itemize}

This simple example illustrates the power of \cdf{defstruct} to provide
abstract record structures in a convenient manner.
\cdf{defstruct} has many other features as well for specialized purposes.

\section{How to Use Defstruct}

All structures are defined through the \cdf{defstruct} construct.
A call to \cdf{defstruct} defines a new data type whose instances
have named slots.

\begin{defmac}
defstruct name-and-options [doc-string] {slot-description}*

This defines a record-structure data type.
A general call to \cdf{defstruct} looks like the following example.
\begin{lisp}
(defstruct (\emph{name} \emph{option-1} \emph{option-2} ... \emph{option-m}) \\
~~~~~~~~~~~\emph{doc-string} \\
~~~~~~~~~~~\emph{slot-description-1} \\
~~~~~~~~~~~\emph{slot-description-2} \\
~~~~~~~~~~~... \\
~~~~~~~~~~~\emph{slot-description-n}) \\
\end{lisp}
The \emph{name} must be a symbol; it becomes the name of a new data type
consisting of all instances of the structure.
The function \cdf{typep} will accept and use this name
as appropriate.  The \emph{name} is returned as the value of the \emph{defstruct}
form.

Usually no options are needed at all.
If no options are specified, then one may write simply \emph{name} instead
of \cd{(\emph{name})} after the word \cdf{defstruct}.  The syntax of options
and the options provided are discussed in section~\ref{DEFSTRUCT-OPTIONS}.

If the optional documentation string \emph{doc-string} is present,
then it is attached to the \emph{name}
as a documentation string of type \cdf{structure}; see \cdf{documentation}.

Each \emph{slot-description-j} is of the form
\begin{lisp}
(\emph{slot-name} \emph{default-init} \\
~~~~~\emph{slot-option-name-1} \emph{slot-option-value-1} \\
~~~~~\emph{slot-option-name-2} \emph{slot-option-value-2} \\
~~~~~... \\
~~~~~\emph{slot-option-name-k${}_{j}$} \emph{slot-option-value-k${}_{j}$})
\end{lisp}
Each \emph{slot-name} must be a symbol; an access function is defined
for each slot. If no options and no \emph{default-init} are specified,
then one may write simply \emph{slot-name} instead of \cd{(\emph{slot-name})}
as the slot description.

\emph{default-init} form is evaluated only if the corresponding
argument is not supplied to the constructor function. 
The \emph{default-init} is a form that is
evaluated \emph{each time} its value
is to be used as the initial value of the slot.

If no \emph{default-init}
is specified, then the initial contents of the slot are undefined
and implementation-dependent.  The available slot-options are
described in section~\ref{Defstruct-Slot-Options}.

\begin{new}
X3J13 voted in January 1989
\issue{DEFSTRUCT-SLOTS-CONSTRAINTS-NAME}
to specify that it is an error for
two slots to have the same name; more precisely, no two slots may
have names for whose print names \cdf{string=} would be true.
Under this interpretation
\begin{lisp}
(defstruct lotsa-slots slot slot)
\end{lisp}
obviously is incorrect
but the following one is also in error, even assuming that the symbols
\cd{coin:slot} and \cd{blot:slot} really are distinct (non-\cdf{eql}) symbols:
\begin{lisp}
(defstruct no-dice coin:slot blot:slot)
\end{lisp}
To illustrate another case, the first \cdf{defstruct} form below is
correct, but the second one is in error.
\begin{lisp}
(defstruct one-slot slot) \\*
(defstruct (two-slots (:include one-slot)) slot)
\end{lisp}

\beforenoterule
\begin{rationale}
Print names are the criterion for slot-names being the same, rather
than the symbols themselves, because \cdf{defstruct} constructs names
of accessor functions from the print names and interns the resulting
new names in the current package.
\end{rationale}
\afternoterule

X3J13 recommended that expanding
a \cdf{defstruct} form violating this
restriction should signal an error and noted, with an eye to the Common Lisp
Object System
\issue{CLOS}, that the restriction applies only to the operation of the
\cdf{defstruct} macro as such and not to the \cdf{structure-class} or
structures defined with \cdf{defclass}.
\end{new}

\begin{newer}
X3J13 voted in March 1989 \issue{DEFINING-MACROS-NON-TOP-LEVEL}
to clarify that, while defining forms normally appear at top level,
it is meaningful to place them in non-top-level contexts;
\cdf{defstruct} must treat slot \emph{default-init} forms
and any\vadjust{\penalty-10000}
initialization forms within the specification of a by-position
constructor function as occurring
within the enclosing lexical environment, not within the global
environment.
\end{newer}

\cdf{defstruct} not only defines an access function for each slot, but also
arranges for \cdf{setf} to work properly on such access functions,
defines a predicate named \cd{\emph{name}-p},
defines a constructor function named \cd{make-\emph{name}},
and defines a copier function named \cd{copy-\emph{name}}.
All names of automatically created functions are interned
in whatever package is current at the time the \cdf{defstruct}
form is processed (see \cdf{*package*}).
Also, all such functions may be declared \cdf{inline}
at the discretion of the implementation to improve efficiency;
if you do not want some function declared \cdf{inline},
follow the \cdf{defstruct} form with a \cdf{notinline} declaration
to override any automatic \cdf{inline} declaration.

\begin{newer}
X3J13 voted in January 1989 \issue{DEFSTRUCT-REDEFINITION}
to specify that the results of redefining a \cdf{defstruct} structure
(that is, evaluating more than one \cdf{defstruct} structure
for the same name) are undefined.

The problem is that if instances have been created under the old definition
and then remain accessible after the new definition has been evaluated,
the accessors and other functions for the new definition may be incompatible
with the old instances.  Conversely, functions associated with the
old definition may have been declared \cdf{inline} and compiled
into code that remains accessible after the new definition has been
evaluated; such code may be incompatible with the new instances.

In practice this restriction affects the development
and debugging process rather than production runs of fully developed code.
The \cdf{defstruct} feature is intended to provide
``the most efficient'' structure class.
CLOS classes defined by \cdf{defclass}
allow much more flexible structures to be defined and redefined.

Programming environments are allowed and encouraged to permit \cdf{defstruct}
redefinition, perhaps with warning messages about possible interactions
with other parts of the programming environment or memory state.
It is beyond the scope of the Common Lisp
language standard to define those interactions except to note that they
are not portable.
\end{newer}
\end{defmac}

\section{Using the Automatically Defined Constructor Function}

After you have defined a new structure with \cdf{defstruct}, you can
create instances of this structure by using the constructor function.
By default, \cdf{defstruct} defines this function automatically.
For a structure named \cdf{foo}, the constructor function is normally
named \cdf{make-foo};
you can specify a different name
by giving it as the argument to the
\cd{:constructor} option, or specify that you don't
want a normal
constructor function at all by using {\false} as the argument
(in which case one or more ``by-position'' constructors should be
requested; see section~\ref{DEFSTRUCT-CONSTRUCTOR-SYNTAX}).

A call to a constructor function, in general, has the form
\begin{lisp}
(\emph{name-of-constructor-function} \\*
~~~~~~~~\emph{slot-keyword-1} \emph{form-1} \\*
~~~~~~~~\emph{slot-keyword-2} \emph{form-2} \\*
~~~~~~~~...)
\end{lisp}
All arguments are keyword arguments.  Each \emph{slot-keyword} should be a
keyword whose name matches the name of a slot of the structure
(\cdf{defstruct} determines the possible keywords simply by interning each
slot-name in the keyword package).  All the \emph{keywords} and \emph{forms}
are evaluated.  In short, it is just as if the constructor function
took all its arguments as \cd{\&key} parameters.  For example, the
\cdf{ship} structure shown in section~\ref{DEFSTRUCT-INTRO-SECTION}
has a constructor function that takes arguments roughly as if its definition
were
\begin{lisp}
(defun make-ship (\&key x-position y-position \\
~~~~~~~~~~~~~~~~~~~~~~~x-velocity y-velocity mass) \\
~~...)
\end{lisp}

\label{defstruct-initialization}
If \emph{slot-keyword-j} names a slot, then that element of
the created structure will be initialized to the value of \emph{form-j}.
If no pair \emph{slot-keyword-j} and \emph{form-j}
is present for a given slot, then the slot will be
initialized by evaluating the \emph{default-init} form specified
for that slot in the call to \cdf{defstruct}.
(In other words, the initialization specified in the \cdf{defstruct}
defers to any specified in a call to the constructor function.)
If the default initialization form is used, it is evaluated
at construction time, but
in the lexical environment of the \cdf{defstruct} form in which it appeared.
If the \cdf{defstruct} itself also did not
specify any initialization, the element's initial value is undefined.
You should always specify the initialization, either in the \cdf{defstruct}
or in the call to the constructor function,
if you care about the initial value of the slot.

Each initialization form specified for a \cdf{defstruct} component,
when used by the constructor function for an otherwise unspecified
component, is re-evaluated on every call to the
constructor function.  It is as if the initialization forms were
used as \emph{init} forms for the keyword parameters of the
constructor function.
For example, if the form \cd{(gensym)}
were used as an initialization form,
either in the constructor-function call or as the default initialization form
in the \cdf{defstruct} form,
then every call to the constructor
function would call \cdf{gensym} once to generate a new symbol.

\begin{newer}
X3J13 voted in October 1988 \issue{DEFSTRUCT-DEFAULT-VALUE-EVALUATION}
to clarify that the default value in a defstruct slot is not evaluated 
        unless it is needed in the creation of a particular structure
        instance.  If it is never needed, there can be no type-mismatch
        error, even if the type of the slot is specified, and no warning
        should be issued.


For example, in the following sequence only the last form is in error.
\begin{lisp}
(defstruct person (name .007 :type string)) \\*
\\*
(make-person :name "James") \\*
\\*
(make-person)~~~~~;\textrm{Error to give \cdf{name} the value \cd{.007}}
\end{lisp}
\end{newer}


\section{Defstruct Slot-Options}
\label{Defstruct-Slot-Options}

Each \emph{slot-description} in a \cdf{defstruct} form may specify one or more
slot-options.  A slot-option consists of a pair of a keyword and
a value (which is not a form to be evaluated, but the value itself).
For example:
\begin{lisp}
(defstruct ship \\
~~(x-position 0.0 \cd{:type} short-float) \\
~~(y-position 0.0 \cd{:type} short-float) \\
~~(x-velocity 0.0 \cd{:type} short-float) \\
~~(y-velocity 0.0 \cd{:type} short-float) \\
~~(mass *default-ship-mass* \cd{:type} short-float \cd{:read-only} t))
\end{lisp}
This specifies that each slot will always contain a
short-format floating-point number,
and that the last slot may not be altered once a ship is constructed.

The available slot-options are as follows.
\begin{flushdesc}
\item[\cd{:type}]
The option \cd{\cd{:type} \emph{type}} specifies that the contents of the
slot will always be of the specified data type.  This is entirely
analogous to the declaration of a variable or function; indeed, it
effectively declares the result type of the access function.  An
implementation may or may not choose to check the type of the new object
when initializing or assigning to a slot.
Note that the argument form \emph{type} is not evaluated;
it must be a valid type specifier.

\item[\cd{:read-only}]
The option \cd{\cd{:read-only} \emph{x}}, where \emph{x} is not {\false},
specifies that this slot may not be
altered; it will always contain the value specified at construction time.
\cdf{setf} will not accept the access function for this slot.
If \emph{x} is {\false}, this slot-option has no effect.
Note that the argument form \emph{x} is not evaluated.
\end{flushdesc}

Note that it is impossible to specify a slot-option unless
a default value is specified first.

\section{Defstruct Options}
\label{DEFSTRUCT-OPTIONS}
\label{Defstruct-Hairy-Stuff}

The preceding description of \cdf{defstruct} is all that the average
user will need (or want) to know in order to use structures.
The remainder of this chapter discusses more complex features of
the \cdf{defstruct} facility.

This section explains each of the options that can be given to \cdf{defstruct}.
A \cdf{defstruct} option may be either a keyword
or a list of a keyword and arguments for that keyword.
(Note that the syntax for \cdf{defstruct} options differs from
the pair syntax used for slot-options.  No part of any of these options
is evaluated.)

\begin{flushdesc}
\item[\cd{:conc-name}]
This provides for automatic prefixing of names of access functions.
It is conventional to begin the names of all the access functions of
a structure with a specific prefix,
the name of the structure followed by a hyphen.
This is the default behavior.

The argument to the \cd{:conc-name} option specifies an alternative
prefix to be used.  (If a hyphen is to be used as a separator,
it must be specified as part of the prefix.)
If {\false} is specified as an argument, then \emph{no} prefix is used;
then the names of the access functions
are the same as the slot-names, and it is up to the user
to name the slots reasonably.

Note that no matter what is specified for \cd{:conc-name},
with a constructor function one uses
slot keywords that match the slot-names, with no prefix attached.
On the other hand, one uses the access-function name
when using \cdf{setf}.  Here is an example:
\begin{lisp}
(defstruct door knob-color width material) \\
(setq my-door \\
~~~~~~(make-door :knob-color 'red :width 5.0)) \\
(door-width my-door) \EV\ 5.0 \\
(setf (door-width my-door) 43.7) \\
(door-width my-door) \EV\ 43.7 \\
(door-knob-color my-door) \EV\ red
\end{lisp}

\item[\cd{:constructor}]
This option takes one argument, a symbol,
which specifies the name of the constructor
function.  If the argument is not provided or if the option itself is not
provided, the name of the constructor is produced by concatenating the
string \cd{"MAKE-"} and the name of the structure, putting the name
in whatever package is current at the time the \cdf{defstruct}
form is processed (see \cdf{*package*}).
If the argument is
provided and is {\false}, no constructor function is defined.

This option actually has a more general syntax that is explained
in section~\ref{DEFSTRUCT-CONSTRUCTOR-SYNTAX}.

\item[\cd{:copier}]
This option takes one argument, a symbol,
which specifies the name of the copier
function.  If the argument is not provided or if the option itself is not
provided, the name of the copier is produced by concatenating the
string \cd{"COPY-"} and the name of the structure, putting the name
in whatever package is current at the time the \cdf{defstruct}
form is processed (see \cdf{*package*}).
If the argument is provided and is {\false}, no copier function is defined.

The automatically defined copier function simply makes a new structure
and transfers all components verbatim from the argument into the
newly created structure.  No attempt is made to make copies
of the components.  Corresponding components of the old and
new structures will therefore be \cdf{eql}.

\item[\cd{:predicate}]
This option takes one argument, which specifies the name of the type predicate.
If the argument is not provided or if the option itself is not
provided, the name of the predicate is made by concatenating the
name of the structure to the string \cd{"-P"}, putting the name
in whatever package is current at the time the \cdf{defstruct}
form is processed (see \cdf{*package*}).
If the argument is
provided and is {\false}, no predicate is defined.  A predicate can be defined
only if the structure is ``named'';
if the \cd{:type} option is specified
and the \cd{:named} option is
not specified, then the \cd{:predicate} option must either be unspecified
or have the value {\false}.

\item[\cd{:include}]
This option is used for building a new structure definition as
an extension of an old structure definition.  As an example,
suppose you have a structure called \cdf{person} that looks like this:
\begin{lisp}
(defstruct person name age sex)
\end{lisp}
Now suppose you want to make a new structure to represent an astronaut.
Since astronauts are people too, you would like them also to have the
attributes of name, age, and sex, and you would like Lisp functions
that operate on \cdf{person} structures to operate just as well on
\cdf{astronaut} structures.  You can do this by defining \cdf{astronaut}
with the \cd{:include} option, as follows:
\begin{lisp}
(defstruct (astronaut (:include person) \\
~~~~~~~~~~~~~~~~~~~~~~(:conc-name astro-)) \\
~~~helmet-size \\
~~~(favorite-beverage 'tang))
\end{lisp}

The \cd{:include} option causes the structure being defined
to have the same slots as the included structure.
This is done in such a way
that the access functions for the included
structure will also work on the structure being defined.
In this example, an
\cdf{astronaut} will therefore have five slots: the three defined in
\cdf{person} and the two defined in \cdf{astronaut}
itself.  The access functions defined by the \cdf{person} structure
can be applied to instances of the \cdf{astronaut} structure, and they
will work correctly.
Moreover, \cdf{astronaut} will have its own access functions for
components defined by the \cdf{person} structure.
The following examples illustrate how you can
use \cdf{astronaut} structures:
\begin{lisp}
(setq x (make-astronaut :name 'buzz \\
~~~~~~~~~~~~~~~~~~~~~~~~:age 45 \\
~~~~~~~~~~~~~~~~~~~~~~~~:sex t \\
~~~~~~~~~~~~~~~~~~~~~~~~:helmet-size 17.5)) \\
 \\
(person-name x) \EV\ buzz \\
(astro-name x) \EV\ buzz \\
\\
(astro-favorite-beverage x) \EV\ tang
\end{lisp}
The difference between the access functions \cdf{person-name} and \cdf{astro-name}
is that \cdf{person-name} may be correctly applied to any \cdf{person},
including an \cdf{astronaut}, while \cdf{astro-name} may be correctly
applied only to an \cdf{astronaut}.  (An implementation may or may not
check for incorrect use of access functions.)

At most one \cd{:include} option may be specified in a single
\cdf{defstruct} form.
The argument to the \cd{:include} option is required and must be the
name of some previously defined structure.  If the structure being
defined has no \cd{:type} option, then the included structure must
also have had no \cd{:type} option specified for it.
If the structure being defined has a \cd{:type} option,
then the included structure must have been declared with a \cd{:type}
option specifying the same representation type.

If no \cd{:type} option is involved, then
the structure name of the including structure definition
becomes the name of a data type, of course, and therefore
a valid type specifier recognizable by \cdf{typep}; moreover, it becomes
a subtype of the included structure.  In the above example,
\cdf{astronaut} is a subtype of \cdf{person}; hence
\begin{lisp}
(typep (make-astronaut) 'person)
\end{lisp}
is true, indicating that all operations on persons will also
work on astronauts.

The following is an advanced feature of the \cd{:include} option.
Sometimes, when one structure includes another, the default values or
slot-options for the slots that came from the included structure are not
what you want.  The new structure can specify default values or
slot-options for the included slots different from those the included
structure specifies, by giving the \cd{:include} option as
\begin{lisp}
(:include \emph{name} \emph{slot-description-1} \emph{slot-description-2} ...)
\end{lisp}
Each \emph{slot-description-j} must have a \emph{slot-name} or \emph{slot-keyword} that is the same
as that of some slot in the included structure.
If \emph{slot-description-j} has no \emph{default-init},
then in the new structure the slot will have no initial
value.  Otherwise its initial value form will be replaced by
the \emph{default-init} in \emph{slot-description-j}.
A normally writable slot may be made read-only.
If a slot is read-only in the included structure, then it
must also be so in the including structure.
If a type is specified for a slot, it must be the same as, or a subtype of, the
type specified in the included structure.  If it is a strict subtype,
the implementation may or may not choose to error-check assignments.

For example, if we had wanted to define \cdf{astronaut} so that the
default age for an astronaut is \cd{45}, then we could have said:
\begin{lisp}
(defstruct (astronaut (:include person (age 45))) \\
~~~helmet-size \\
~~~(favorite-beverage 'tang))
\end{lisp}

\begin{new}
X3J13 voted in June 1988
\issue{DATA-TYPES-HIERARCHY-UNDERSPECIFIED}
to require any structure type created by \cdf{defstruct}
(or \cdf{defclass}) to be disjoint from any of the types
\cdf{cons}, \cdf{symbol}, \cdf{array}, \cdf{number}, \cdf{character},
\cdf{hash-table}, \cdf{readtable}, \cdf{package}, \cdf{pathname},
\cdf{stream}, and \cdf{random-state}.  A consequence of this requirement
is that it is an error to specify any of these types, or any of their
subtypes, to the \cdf{defstruct} \cd{:include} option.
(The first edition said nothing explicitly about this.
Inasmuch as using such a type with the \cd{:include} option was
not defined to work, one might argue that such use was an error
in Common Lisp as defined by the first edition.)
\end{new}

\item[\cd{:print-function}]
This option may be used only if the \cd{:type}
option is not specified.
The argument to the \cd{:print-function} option
should be a function of three arguments,
in a form acceptable to the \cdf{function} special operator,
to be used to print structures of this type.
When a structure of this type is to be printed, the function
is called on three arguments:
the structure to be printed, a stream to print to,
and an integer indicating the current depth (to be compared against
\cdf{*print-level*}).
The printing function should observe the values of
such printer-control variables as \cdf{*print-escape*}
and \cdf{*print-pretty*}.

If the \cd{:print-function} option is not specified and the \cd{:type}
option also not specified, then a default printing function is
provided for the structure that will print out all its slots
using \cd{\#S} syntax (see section~\ref{SHARP-SIGN-MACRO-CHARACTER-SECTION}).

\begin{new}
X3J13 voted in January 1989
\issue{PRINT-CIRCLE-STRUCTURE}
to specify that user-defined printing functions for the \cdf{defstruct}
\cd{:print-function} option may print objects to the
supplied stream using \cdf{write}, \cd{print1}, \cdf{princ}, \cdf{format},
or \cdf{print-object} and expect circularities to be detected and printed
using \cd{\#\emph{n\/}\#} syntax (when \cdf{*print-circle*} is non-\cdf{nil}, of course).
See \cdf{*print-circle*}.
\end{new}


\begin{new}
X3J13 voted in January 1989
\issue{DEFSTRUCT-PRINT-FUNCTION-INHERITANCE}
to clarify that if the \cd{:print-function}
option is not specified but the \cd{:include} option \emph{is} specified,
then the print function is inherited from the included structure type.
Thus, for example, an \cdf{astronaut} will be printed by the same
printing function that is used for \cdf{person}.

X3J13 in the same vote extended the \cdf{print-function} option
as follows: If the \cdf{print-function} option is specified but with
no argument, then the standard default printing function (that uses
\cd{\#S} syntax) will be used.  This provides a means of overriding the
inheritance rule.  For example, if \cdf{person} and \cdf{astronaut}
had been defined as
\begin{lisp}
(defstruct (person \\*
~~~~~~~~~~~~~(:print-function~~~~~;\textrm{Special print function}\\*
~~~~~~~~~~~~~(lambda (p s k) \\*
~~~~~~~~~~~~~~~(format s "<{\Xtilde}A, age {\Xtilde}D>" \\*
~~~~~~~~~~~~~~~~~~~~~~~(person-name p) \\*
~~~~~~~~~~~~~~~~~~~~~~~(person-age p))))) \\*
~~name age sex) \\
\\
(defstruct (astronaut \\*
~~~~~~~~~~~~~(:include person) \\*
~~~~~~~~~~~~~(:conc-name astro-) \\*
~~~~~~~~~~~~~(:print-function))~~~~~;\textrm{Use default print function} \\*
~~~helmet-size \\*
~~~(favorite-beverage 'tang))
\end{lisp}
then an ordinary person would be printed as ``\cd{<Joe Schmoe, age 27>}''
but an astronaut would be printed as, for example,
\begin{lisp}
\#S(ASTRONAUT NAME BUZZ AGE 45 SEX T \\*
~~~HELMET-SIZE 17.5 FAVORITE-BEVERAGE TANG)
\end{lisp}
using the default \cd{\#S} syntax (yuk).

These changes make the behavior of \cdf{defstruct} with respect to the
\cd{:include} option a bit more like the behavior of classes in CLOS.
\end{new}

\item[\cd{:type}]
The \cd{:type} option explicitly specifies the representation to be used for
the structure.  It takes one argument, which must
be one of the types enumerated below.

Specifying this option has the effect of forcing
a specific representation and of forcing the components to be
stored in the order specified in the \cdf{defstruct} form
in corresponding successive elements of the specified representation.
It also \emph{prevents} the structure name from becoming a valid
type specifier recognizable by \cdf{typep}
(see section~\ref{EXPLICIT-TYPE-STRUCTURES}).

Normally this option is not specified, in which case the structure
is represented in an implementation-dependent manner.

\begin{quotation}    % Merely to advance the left margin
\begin{flushdesc}
\item[\cdf{vector}]
This produces the same result as specifying \cd{(vector t)}.
The structure is represented
as a general vector, storing components as vector elements.
The first component is vector
element 1 if the structure is \cd{:named}, and element 0 otherwise.

\item[\cd{(vector \emph{element-type})}]
The structure is represented as a (possibly specialized) vector, storing
components as vector elements.  Every component must be of a type that can be
stored in a vector of the type specified.  The first component is vector
element 1 if the structure is \cd{:named}, and element 0 otherwise.
The structure may be \cd{:named} only if the type \cdf{symbol} is a subtype of
the specified \cdf{element-type}.

\item[\cdf{list}]
The structure is represented as a list.
The first component is the \emph{cadr}
if the structure is \cd{:named}, and the \emph{car} if
it is \cd{:unnamed}.
\end{flushdesc}
\end{quotation}

\item[\cd{:named}]
The \cd{:named} option specifies that the structure is ``named''; this
option takes no argument.  If no \cd{:type} option is specified,
then the structure is always named; so this option is useful only in
conjunction with the \cd{:type} option.
See section~\ref{EXPLICIT-TYPE-STRUCTURES} for a further description of this
option.

\item[\cd{:initial-offset}]
This allows you to tell \cdf{defstruct} to skip over a certain
number of slots before it starts allocating the slots described in the
body.  This option requires an argument,
a non-negative integer,
which is the number of slots you want \cdf{defstruct} to skip.
The \cd{:initial-offset} option may be used only if the
\cd{:type} option is also specified.
See section~\ref{DEFSTRUCT-INITIAL-OFFSET} for a further description
of this option.
\end{flushdesc}

\section{By-Position Constructor Functions}
\label{DEFSTRUCT-CONSTRUCTOR-SYNTAX}

If the \cd{:constructor} option is given as
\cd{(\cd{:constructor} \emph{name} \emph{arglist})},
then instead of making a keyword-driven constructor function,
\cdf{defstruct} defines a ``positional'' constructor function,
taking arguments whose meaning is determined by the argument's position
rather than by a keyword.
The \emph{arglist} is used to describe what the arguments to the
constructor will be.  In the simplest case something like
\cd{(\cd{:constructor} make-foo (a b c))} defines \cdf{make-foo} to be
a three-argument constructor function whose arguments are used to initialize the
slots named \cdf{a}, \cdf{b}, and \cdf{c}.

In addition, the keywords \cd{\&optional}, \cd{\&rest}, and \cd{\&aux} are
recognized in the argument list.  They work in the way you might expect,
but there are a few fine points worthy of explanation.
Consider this example:
\begin{lisp}
(\cd{:constructor} create-foo \\
~~~~~~~~(a \&optional b (c 'sea) \&rest d \&aux e (f 'eff)))
\end{lisp}
This defines \cdf{create-foo} to be a constructor of one or more arguments.
The first argument is used to initialize the \cdf{a} slot.  The second
argument is used to initialize the \cdf{b} slot.  If there isn't any
second argument, then the default value given in the body of the
\cdf{defstruct} (if given) is used instead.  The third argument is used to
initialize the \cdf{c} slot.  If there isn't any third argument, then the
symbol \cdf{sea} is used instead.  Any arguments following the third
argument are collected into a list and used to initialize the \cdf{d}
slot.  If there are three or fewer arguments, then {\false} is placed in
the \cdf{d} slot.  The \cdf{e} slot \emph{is not initialized}; its initial
value is undefined.  Finally, the \cdf{f} slot is initialized to contain
the symbol \cdf{eff}.

The actions taken in the \cdf{b} and \cdf{e} cases were carefully
chosen to allow the user to specify all possible behaviors.  Note that
the \cd{\&aux} ``variables'' can be used to completely override the default
initializations given in the body.

With this definition, one can write
\begin{lisp}
(create-foo 1 2)
\end{lisp}
instead of
\begin{lisp}
(make-foo \cd{:a} 1 \cd{:b} 2)
\end{lisp}
and of course \cdf{create-foo} provides defaulting different
from that of \cdf{make-foo}.

It is permissible to use the
\cd{:constructor} option more than once, so that you can define several
different constructor functions, each taking different parameters.

Because a constructor of this type operates By Order of Arguments,
it is sometimes known as a BOA constructor.

\begin{new}
X3J13 voted in January 1989
\issue{DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE}
to allow \cd{\&key} and \cd{\&allow-other-keys}
in the
parameter list of a ``positional'' constructor.  The initialization of slots
corresponding to keyword parameters
is performed in the same manner as for \cd{\&optional} parameters.
A variant of the example shown above illustrates this:
\begin{lisp}
(\cd{:constructor} create-foo \\*
~~~~~~~~(a \&optional b (c 'sea) \\*
~~~~~~~~~\&key p (q 'cue) ((:why y)) ((:you u) 'ewe) \\*
~~~~~~~~~\&aux e (f 'eff)))
\end{lisp}
The treatment of slots \cdf{a}, \cdf{b}, \cdf{c}, \cdf{e}, and \cdf{f}
is the same as in the original example.  In addition,
if there is a \cd{:p} keyword argument, it is
used to initialize the \cdf{p} slot;  if there isn't any
\cd{:p} keyword argument, then the default value given in the body of the
\cdf{defstruct} (if given) is used instead.  Similarly,
if there is a \cd{:q} keyword argument, it is
used to initialize the \cdf{q} slot;  if there isn't any
\cd{:q} keyword argument, then
the symbol \cdf{cue} is used instead.

In order thoroughly to flog this presumably already dead horse,
we further observe that if there is a \cd{:why} keyword argument, it is
used to initialize the \cdf{y} slot; otherwise
the default value for slot \cdf{y} is used instead.  Similarly,
if there is a \cd{:you} keyword argument, it is
used to initialize the \cdf{u} slot;  otherwise
the symbol \cdf{ewe} is used instead.

If memory serves me correctly, \cdf{defstruct} was included in the original
design for Common Lisp some time before keyword arguments were approved.
The failure of positional constructors to accept keyword arguments may well
have been an oversight on my part; there is no logical reason to exclude
them.  I am grateful to X3J13 for rectifying this.

A remaining difficulty is that the possibility of keyword arguments
renders the term ``positional constructor'' a misnomer.  Worse yet,
it ruins the term ``BOA constructor.''  I suggest that
they continue to be called BOA constructors, as I refuse to abandon
a good pun.  (I regret appearing to have more compassion for puns than
for horses.)

As part of the same vote X3J13 also changed \cdf{defstruct}
to allow BOA constructors to have
parameters (including supplied-p parameters)
that do not correspond to any
slot.  Such parameters may be used in subsequent initialization forms in the
parameter list. Consider this example:
\begin{lisp}
(defstruct (ice-cream-factory \\*
~~~~~~~~~~~~~(:constructor fabricate-factory \\*
~~~~~~~~~~~~~~~(\&key (capacity 5) \\*
~~~~~~~~~~~~~~~~~~~~~~location \\
~~~~~~~~~~~~~~~~~~~~~~(local-flavors \\*
~~~~~~~~~~~~~~~~~~~~~~~~(case location \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~((hawaii) '(pineapple macadamia guava)) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~((massachusetts) '(lobster baked-bean)) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~((california) '(ginger lotus avocado \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bean-sprout garlic)) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~((texas) '(jalapeno barbecue)))) \\
~~~~~~~~~~~~~~~~~~~~~~(flavors (subseq (append local-flavors \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'(vanilla \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~chocolate \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~strawberry \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~pistachio \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~maple-walnut \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~peppermint)) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~0 capacity))))) \\*
~~(capacity 3) \\*
~~(flavors '(vanilla chocolate strawberry mango)))
\end{lisp}

The structure type \cdf{ice-cream-factory} has two constructors.
The standard constructor, \cdf{make-ice-cream-factory},
takes two keyword arguments named \cd{:capacity} and \cd{:flavors}.
For this constructor, the default for the \cdf{capacity} slot is \cd{3}
and the default list of \cdf{flavors} is America's favorite threesome
and a dark horse (not a dead one).
The BOA constructor \cdf{fabricate-factory}
accepts four different keyword arguments.  The \cd{:capacity}
argument defaults to \cd{5}, and the \cd{:flavors} argument
defaults in a complicated manner based on the other three.
The \cd{:local-flavors} argument may be specified directly,
or may be allowed to default based on the \cd{:location} of the factory.
Here are examples of various factories:

\vskip0pt plus 2pt%manual
\begin{lisp}
(setq houston (fabricate-factory :capacity 4 :location 'texas)) \\*
(setq cambridge (fabricate-factory :location 'massachusetts)) \\
(setq seattle (fabricate-factory :local-flavors '(salmon))) \\
(setq wheaton (fabricate-factory :capacity 4 :location 'illinois)) \\*
(setq pittsburgh (fabricate-factory :capacity 4)) \\*
(setq cleveland (make-factory :capacity 4)) \\
 \\
(ice-cream-factory-flavors houston) \\*
~\EV~(jalapeno barbecue vanilla chocolate)
\end{lisp}
\newpage%manual
\begin{lisp}
(ice-cream-factory-flavors cambridge) \\*
~\EV~(lobster baked-bean vanilla chocolate strawberry) \\
\\
(ice-cream-factory-flavors seattle) \\*
~\EV~(salmon vanilla chocolate strawberry pistachio) \\
\\
(ice-cream-factory-flavors wheaton) \\*
~\EV~(vanilla chocolate strawberry pistachio) \\
\\
(ice-cream-factory-flavors pittsburgh) \\*
~\EV~(vanilla chocolate strawberry pistachio) \\
\\
(ice-cream-factory-flavors cleveland) \\*
~\EV~(vanilla chocolate strawberry mango)
\end{lisp}
\end{new}


\section{Structures of Explicitly Specified Representational Type}
\label{EXPLICIT-TYPE-STRUCTURES}

Sometimes it is important to have explicit control
over the representation of a structure.  The \cd{:type}
option allows one to specify that a structure must be implemented
in a particular way, using a list or a specific kind of vector,
and to specify the exact allocation of structure slots to
components of the representation.
A structure may also be ``unnamed'' or ``named,'' according to whether
the structure name is stored in (and thus recoverable from) the structure.

\subsection{Unnamed Structures}

Sometimes a particular data representation is imposed by external requirements,
and yet it is desirable to document the data format as a \cdf{defstruct}-style
structure.  For example, consider expressions built up from numbers,
symbols, and binary operations such as \cdf{+} and \cdf{*}.  An operation
might be represented as it is in Lisp, as a list of the operator
and the two operands.  This fact can be expressed succinctly with \cdf{defstruct}
in this manner:
е\begin{lisp}
(defstruct (binop (:type list)) \\
~~(operator '? :type symbol) \\
~~operand-1 \\
~~operand-2)
\end{lisp}
This will define a constructor function \cdf{make-binop} and three
selector functions, namely \cdf{binop-operator}, \cd{binop-operand-1},
and \cd{binop-operand-2}.  (It will \emph{not}, however, define a predicate
\cdf{binop-p}, for reasons explained below.)

The effect of \cdf{make-binop} is simply to construct a list of length 3:
\begin{lisp}
(make-binop :operator '+ :operand-1 'x :operand-2 5) \\*
~~~\EV\ (+ x 5) \\
\\
(make-binop :operand-2 4 :operator '*) \\*
~~~\EV\ (* {\nil} 4)
\end{lisp}
It is just like the function \cdf{list} except that it takes
keyword arguments and performs slot defaulting appropriate to the \cdf{binop}
conceptual data type.  Similarly, the selector functions
\cdf{binop-operator}, \cd{binop-operand-1},
and \cd{binop-operand-2} are essentially equivalent to \cdf{car},
\cdf{cadr}, and \cdf{caddr}, respectively.  (They might not be
completely equivalent because,
for example, an implementation would be justified in adding error-checking
code to ensure that the argument to each selector function is a length-3
list.)

We speak of \cdf{binop} as being a ``conceptual'' data type because \cdf{binop}
is not made a part of the Common Lisp type system.  The predicate
\cdf{typep} will not recognize \cdf{binop} as a type specifier, and \cdf{type-of}
will return \cdf{list} when given a \cdf{binop} structure.  Indeed, there is
no way to distinguish a data structure constructed by \cdf{make-binop}
from any other list that happens to have the correct structure.

There is not even any way to recover the structure name \cdf{binop} from
a structure created by \cdf{make-binop}.  This can be done, however,
if the structure is ``named.''

\subsection{Named Structures}

A ``named'' structure has the property that, given an instance of the
structure, the structure name (that names the type) can be reliably
recovered.  For structures defined
with no \cd{:type} option, the structure name actually becomes part
of the Common Lisp data-type system.  The function \cdf{type-of},
when applied to such a structure, will return the structure name
as the type of the object; the predicate \cdf{typep} will recognize
the structure name as a valid type specifier.

For structures defined with a \cd{:type} option, \cdf{type-of} will
return a type specifier such as \cdf{list} or \cd{(vector t)},
depending on the type specified to the \cd{:type} option.
The structure name does not become a valid type specifier.
However,
if the \cd{:named} option is also specified, then the first component
of the structure (as created by a \cdf{defstruct} constructor function)
will always contain the structure name.  This allows the structure name
to be recovered from an instance of the structure and allows a reasonable
predicate for the conceptual type to be defined:
the automatically defined
\cd{\emph{name}-p} predicate for the structure operates by first
checking that its argument is of the proper type (\cdf{list}, \cd{(vector t)},
or whatever) and then checking whether the first component contains
the appropriate type name.

Consider the \cdf{binop} example shown above, modified only to
include the \cd{:named} option:
\begin{lisp}
(defstruct (binop (:type list) :named) \\
~~(operator '? :type symbol) \\
~~operand-1 \\
~~operand-2)
\end{lisp}
As before, this will define a constructor function \cdf{make-binop} and three
selector functions \cdf{binop-operator}, \cd{binop-operand-1},
and \cd{binop-operand-2}.  It will also define a predicate \cdf{binop-p}.

The effect of \cdf{make-binop} is now to construct a list of length 4:
\begin{lisp}
(make-binop :operator '+ :operand-1 'x :operand-2 5) \\*
~~~\EV\ (binop + x 5) \\
\\
(make-binop :operand-2 4 :operator '*) \\*
~~~\EV\ (binop * {\nil} 4)
\end{lisp}
The structure has the same layout as before except that the structure name
\cdf{binop} is included as the first list element.
The selector functions
\cdf{binop-operator}, \cd{binop-operand-1},
and \cd{binop-operand-2} are essentially equivalent to \cdf{cadr},
\cdf{caddr}, and \cdf{cadddr}, respectively.
The predicate \cdf{binop-p} is more or less equivalent to the following
definition.
\begin{lisp}
(defun binop-p (x) \\
~~(and (consp x) (eq (car x) 'binop)))
\end{lisp}
The name \cdf{binop} is still not a valid type specifier recognizable
to \cdf{typep}, but at least there is a way of distinguishing \cdf{binop}
structures from other similarly defined structures.

\subsection{Other Aspects of Explicitly Specified Structures}
\label{DEFSTRUCT-INITIAL-OFFSET}

The \cd{:initial-offset} option allows one
to specify that slots be allocated beginning at a representational
element other than the first.  For example, the form
\begin{lisp}
(defstruct (binop (:type list) (:initial-offset 2)) \\*
~~(operator '? :type symbol) \\*
~~operand-1 \\*
~~operand-2)
\end{lisp}
would result in the following behavior for \cdf{make-binop}:
\begin{lisp}
(make-binop :operator '+ :operand-1 'x :operand-2 5) \\*
~~~\EV\ (nil nil + x 5) \\
\\
(make-binop :operand-2 4 :operator '*) \\*
~~~\EV\ (nil nil * {\nil} 4)
\end{lisp}
The selectors
\cdf{binop-operator}, \cd{binop-operand-1},
and \cd{binop-operand-2} would be essentially equivalent to \cdf{caddr},
\cdf{cadddr}, and \cdf{car} of \cdf{cddddr}, respectively.
Similarly, the form
\begin{lisp}
(defstruct (binop (:type list) :named (:initial-offset 2)) \\*
~~(operator '? :type symbol) \\*
~~operand-1 \\*
~~operand-2)
\end{lisp}
would result in the following behavior for \cdf{make-binop}:
\begin{lisp}
(make-binop :operator '+ :operand-1 'x :operand-2 5) \\*
~~~\EV\ (nil nil binop + x 5) \\
\\
(make-binop :operand-2 4 :operator '*) \\*
~~~\EV\ (nil nil binop * {\nil} 4)
\end{lisp}

If the \cd{:include} is used with the \cd{:type}
option, then the effect is first to skip over as many representation
elements as needed to represent the included structure, then to
skip over any additional elements specified by the \cd{:initial-offset}
option, and then to begin allocation of elements from that point.
For example:
\begin{lisp}
(defstruct (binop (:type list) :named (:initial-offset 2)) \\
~~(operator '? :type symbol) \\
~~operand-1 \\
~~operand-2) \\
 \\
(defstruct (annotated-binop (:type list) \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(:initial-offset 3) \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(:include binop)) \\
~~commutative associative identity) \\
 \\
(make-annotated-binop :operator '* \\
~~~~~~~~~~~~~~~~~~~~~~:operand-1 'x \\
~~~~~~~~~~~~~~~~~~~~~~:operand-2 5 \\
~~~~~~~~~~~~~~~~~~~~~~:commutative t \\
~~~~~~~~~~~~~~~~~~~~~~:associative t \\
~~~~~~~~~~~~~~~~~~~~~~:identity 1) \\
~~~\EV\ (nil nil binop * x 5 nil nil nil t t 1)
\end{lisp}
The first two {\nil} elements stem from the \cd{:initial-offset} of \cd{2}
in the definition of \cdf{binop}.  The next four elements contain the
structure name and three slots for \cdf{binop}.  The next three {\nil} elements
stem from the \cd{:initial-offset} of \cd{3} in the definition of
\cdf{annotated-binop}.  The last three list elements contain the additional
slots for an \cdf{annotated-binop}.

%RUSSIAN
\else

\chapter{Структуры}

Common Lisp позволяет создавать структуры (почти такие же как в
других языках, с именем структуры, полями, и т.д.). Фактически,
пользователь может определить новый тип данных. Каждая структура данных
этого типа имеет компоненты с заданными именами. При создании
структуры автоматически создаются конструктор и функции доступа и
присваивания значений для полей.

Данная глава разделена на две части. Первая часть описывает основную
функциональность структур, которая очень проста и позволяет пользователю
воспользоваться проверкой типов, модульностью и удобством определённых им типов
данных. Вторая часть начинается с раздела~\ref{Defstruct-Hairy-Stuff},
описывающего специализированные возможности для сложных приложений. Эти
возможности совершенно необязательны к использованию, и вам даже не нужно о них
знать для того, чтобы делать хорошие программы.

\section{Введение в структуры}
\label{DEFSTRUCT-INTRO-SECTION}

Функциональность структур воплощена в макросе \cdf{defstruct}, который позволяет
пользователю создавать и использовать сгруппированные типы данных с именованными
элементами. Она похожа на функциональность <<структур (structures)>> в {PL/I}
или <<записей (records)>> в Pascal'е.

В качестве примера, предположим, что вы пишете программу на Lisp'е, которая
управляет космическими кораблями в двухмерном пространстве.
Вам необходимо представить космический корабль как некоторого
вида Lisp'овый объект. Интересующими свойствами корабля являются: его
позиция (представленная как \emph{x} и \emph{y} координаты), скорость
(представленная как отрезки по осям \emph{x} и \emph{y}) и масса.

Таким образом, корабль может быть представлен как запись структуры с пятью
компонентами: позиция-\emph{x}, позиция-\emph{y}, скорость-\emph{x},
скорость-\emph{y} и масса.
Эта структура может быть реализована как Lisp'овый объект несколькими способами.
Она может быть списком из пяти элементов; позиция-\emph{x} будет \emph{car}
элементом, позиция-\emph{y} будет \emph{cadr}, и так далее. Подобным образом
структура может быть вектором из пяти элементов: позиция-\emph{x} будет 0-ым
элементом, позиция-\emph{y} будет 1-ым, и так далее. Проблема данных
представлений состоит в том, что компоненты занимают совершенно случайные
позиции и их сложно запомнить. Кто-нибудь увидев где-то в коде
строки \cd{(cadddr~ship1)} или \cd{(aref~ship1~3)}, обнаружит сложность в
определении того, что это производится доступ к компоненту скорости-\emph{y}
структуры \cd{ship1}. Более того, если представление корабля должно быть
изменено, то будет очень сложно найти все места в коде для изменения в
соответствие с новым представлением (не все появления \cdf{cadddr} означают
доступ к скорости-\emph{y} корабля). 

Лучше было бы, если бы записи структур имели имена. Можно было бы написать что-то
вроде \cd{(ship-y-velocity ship1)} вместо \cd{(cadddr ship1)}. Кроме того было
бы неплохо иметь более информативную запись для создания структур, чем эта:
\begin{lisp}
(list 0 0 0 0 0)
\end{lisp}
Несомненно, хочется, чтобы \cdf{ship} был новым типом данных, как и любой другой
тип Lisp'овых данных, чтобы, например, осуществить проверку с помощью
\cdf{typep}.
\cdf{defstruct} предоставляет вам все, что необходимо.

\cdf{defstruct} является макросом, который определяет структуру. Например, для
космического корабля, можно определить структуру так:
\begin{lisp}
(defstruct ship \\
~~x-position \\
~~y-position \\
~~x-velocity \\
~~y-velocity \\
~~mass)
\end{lisp}
Запись декларирует, что каждый объект \cdf{ship} является объектом с пятью
именованными компонентами. Вычисление этой формы делает несколько вещей.

\begin{itemize}

\item Она определяет \cdf{ship-x-position} как функцию одного
  аргумента, а именно, корабля, которая возвращает позицию-\emph{x}
  корабля.  \cdf{ship-y-position} и другие компоненты получают такие
  же определения функций.  Эти функции называются \emph{функциями
    доступа или аксессорами}, так как используются для доступа к
  компонентам структуры.

\item Символ \cdf{ship} становится именем типа данных, к которому
  принадлежат экземпляры объектом кораблей. Например, это имя может
  использоваться в \cdf{typep}.  \cd{(typep x 'ship)} истинен, если
  \cd{x} является кораблём, и ложен, если \cdf{x} является любым
  другим объектом.

\item Определяется функция одного аргумента с именем \cdf{ship-p}. Она
  является предикатом, который истинен, если аргумент является
  кораблём, и ложен в противных случаях.

\item Определяется функция с именем \cdf{make-ship}, при вызове
  которой создаётся структура данных из пяти компонентов, готовая к
  использованию в \emph{функциях доступа}.  Так, выполнение
  \begin{lisp}
    (setq ship2 (make-ship))
  \end{lisp}
  устанавливает в ship2 свеже созданный объект \cdf{ship}.  Можно
  указать первоначальные значения для компонентов структуры используя
  именованные параметры:
  \begin{lisp}
    (setq ship2 (make-ship \cd{:mass} *default-ship-mass* \\
    ~~~~~~~~~~~~~~~~~~~~~~~\cd{:x-position} 0 \\
    ~~~~~~~~~~~~~~~~~~~~~~~\cd{:y-position} 0))
  \end{lisp}
  Форма создаёт новый корабль и инициализирует три его компонента.
  Эта функция называется \emph{функцией-конструктором}, потому что
  создаёт новую структуру.

\item Синтаксис \cd{\#S} может использоваться для чтения экземпляров
  структур \cdf{ship}, и также предоставляется функция вывода для
  печати структур кораблей.  Например, значение ранее упомянутой
  переменной \cd{ship2} может быть выведено как
  \begin{lisp}
    \#S(ship  x-position 0  y-position 0  x-velocity nil \\
    ~~~~~~~~~y-velocity nil mass 170000.0)
  \end{lisp}

\item Определяется функция одного аргумента с именем \cdf{copy-ship},
  которая получая объект \cdf{ship}, будет создавать новый объект
  \cdf{ship}, который является копией исходного.  Эта функция
  называется \emph{функцией копирования}.

\item Можно использовать \cdf{setf} для изменения компонентов объекта
  \cdf{ship}:
  \begin{lisp}
    (setf (ship-x-position ship2) 100)
  \end{lisp}
  Данная запись изменяет позицию-\emph{x} переменной \emph{ship2} в
  \cd{100}.  Она работает, потому что \cdf{defstruct} ведёт себя так,
  будто создаёт соответствующие \cdf{defsetf} формы для \emph{функций
    доступа}.
\end{itemize}

Этот простой пример отображает мощь и удобство \cdf{defstruct} для представления
записей структур.
\cdf{defstruct} имеет много других возможностей для специализированных целей.

\section{Как использовать defstruct}

Все структуры определяются с помощью конструкции \cdf{defstruct}.
Вызов \cdf{defstruct} определяет новый тип данных, экземпляры которого содержат
именованные слоты.

\begin{defmac}
defstruct name-and-options [doc-string] {slot-description}*

Этот макрос определяет структурный тип данных.
Обычно вызов \cdf{defstruct} выглядит как следующий пример.
\begin{lisp}
(defstruct (\emph{name} \emph{option-1} \emph{option-2} ... \emph{option-m}) \\
~~~~~~~~~~~\emph{doc-string} \\
~~~~~~~~~~~\emph{slot-description-1} \\
~~~~~~~~~~~\emph{slot-description-2} \\
~~~~~~~~~~~... \\
~~~~~~~~~~~\emph{slot-description-n}) \\
\end{lisp}
Имя структуры \emph{name} должно быть символом. Данный символ будет
обозначать новый тип данных, который включает в себя все экземпляры
данной структуры. Соответственно функция \cdf{typep} будет принимать
и использовать это имя. Имя структуры \emph{name} возвращается как
значение формы \emph{defstruct}.

Обычно параметры не нужны. Если они не заданы, то после слова
\cdf{defstruct} вместо \cd{(\emph{name})} можно записать просто
\emph{name} . Синтаксис параметров и их смысл раскрываются в
разделе~\ref{DEFSTRUCT-OPTIONS}.

Если присутствует необязательная строка документации
\emph{doc-string}, тогда она присоединяется к символу \emph{name}, как
документация для типа \cdf{structure}. Смотрите \cdf{documentation}.

Каждое описание слота \emph{slot-description-j} выглядит так:
\begin{lisp}
(\emph{slot-name} \emph{default-init} \\
~~~~~\emph{slot-option-name-1} \emph{slot-option-value-1} \\
~~~~~\emph{slot-option-name-2} \emph{slot-option-value-2} \\
~~~~~... \\
~~~~~\emph{slot-option-name-k${}_{j}$} \emph{slot-option-value-k${}_{j}$})
\end{lisp}
Каждое имя слота \emph{slot-name} должно быть символом. Для каждого
слота определяется функция доступа. Если параметры и первоначальные
значения не указаны, тогда в качестве описания слота вместо
\cd{(slot-name)} можно записать просто \emph{slot-name}.

Форма \emph{default-init} вычисляется, только если соответствующий аргумент не
указан при вызове функций-конструкторов.
\emph{default-init} вычисляется \emph{каждый раз}, когда необходимо получить
первоначальное значение для слота.

Если \emph{default-init} не указано, тогда первоначальное значение слота не
определено и зависит от реализации. Доступные параметры для слотов разобраны в
разделе~\ref{Defstruct-Slot-Options}.

Слоты не могут иметь одинаковые имена. Даже если символы для имён из
разных пакетов, всё равно нельзя.

Так нельзя:
\begin{lisp}
(defstruct lotsa-slots slot slot)
\end{lisp}

Так тоже нельзя:
\begin{lisp}
(defstruct no-dice coin:slot blot:slot)
\end{lisp}
А здесь первую структуру создать можно, а вторую нельзя:
\begin{lisp}
(defstruct one-slot slot) \\*
(defstruct (two-slots (:include one-slot)) slot)
\end{lisp}

\cdf{defstruct} не только определяет функции доступа к слотам, но также
выполняет интеграцию с \cdf{setf} для этих функций, определяет предикат с
именем \cd{\emph{name}-p}, определяет функцию-конструктор с именем
\cd{make-\emph{name}} и определяет функцию копирования с именем
\cd{copy-\emph{name}}.
Все имена автоматически создаваемых функций интернируются в текущий пакет на время
выполнения \cdf{defstruct} (смотрите \cdf{*package*}).
Кроме того, все эти функции могут быть задекларированы как \cdf{inline} на
усмотрение реализации для повышения производительности.
Если вы не хотите, чтобы функции были задекларированы как \cdf{inline}, укажите
декларацию \cdf{notinline} после формы \cdf{defstruct} для перезаписи декларации
\cdf{inline}.

При переопределении структуры современные реализации чаще всего
генерируют исключение с возможностью применить новое определение,
оставить старое, и т.д.
\end{defmac}

\section{Использование автоматически определяемого конструктора}

После того, как вы определили новую структуру с помощью
\cdf{defstruct}, вы можете создавать экземпляры данной структуры с
помощью функции-конструктора.  По-умолчанию \cdf{defstruct} сам
автоматически определяет эту функцию.  Для структуры с именем
\cdf{foo}, функция-конструктор обычно называется \cdf{make-foo}.
Вы можете указать другое имя, передав его в качестве аргумента для
параметра \cd{:constructor}, или, если вы вообще не хотите обычную
функцию-конструктор, указав в качества аргумента {\false}.  В
последнем случае должны быть запрошены один или более конструкторов с
<<позиционными>> аргументами, смотрите
раздел~\ref{DEFSTRUCT-CONSTRUCTOR-SYNTAX}.

Общая форма вызова функции-конструктора выглядит так:
\begin{lisp}
(\emph{name-of-constructor-function} \\*
~~~~~~~~\emph{slot-keyword-1} \emph{form-1} \\*
~~~~~~~~\emph{slot-keyword-2} \emph{form-2} \\*
~~~~~~~~...)
\end{lisp}
Все аргументы являются именованными. Каждый \emph{slot-keyword} должен
быть ключевым символом, имя которого совпадает со именем слота
структуры (\cdf{defstruct} определяет возможные ключевые символы
интернируя каждое имя слота в пакет ключевых символов (keyword). Все
ключевые символы \emph{keywords} и формы \emph{forms} вычисляются. В
целом, это выглядит как если функция-конструктор принимает все
аргументы как \cd{\&key} параметры. Например, структура \cd{ship}
упомянутая ранее в разделе~\ref{DEFSTRUCT-INTRO-SECTION} имеет
функцию-конструктор, которая принимает аргументы в соотвествие со
следующим определением:
\begin{lisp}
(defun make-ship (\&key x-position y-position \\
~~~~~~~~~~~~~~~~~~~~~~~x-velocity y-velocity mass) \\
~~...)
\end{lisp}

\label{defstruct-initialization}
Если \emph{slot-keyword-j} задаёт имя слота, тогда элемент созданной структуры
будет инициализирован значением \emph{form-j}.
Если пара \emph{slot-keyword-j} и \emph{form-j} для слота не указана, тогда слот
будет инициализирован результатом вычисления указанной в вызове \cdf{defstruct}
для этого слота формой \emph{default-init}.
(Другими словами, инициализация указанная в \cdf{defstruct} замещается
инициализацией указанной в вызове функции-конструктора.)
Если используется форма инициализации \emph{default-init}, она вычисляется в
время создания экземпляра структуры, но в лексическом окружении формы
\cdf{defstruct}, в которой она используется.
Если эта форма инициализации не указана, первоначальное значение слота не
определено.
Если вам необходимо инициализировать слоты некоторыми значениями, вы должны
всегда указывать первоначальное значение или в \cdf{defstruct}, или в 
вызове функции-конструктора. 

Каждая форма инициализации, указанная в компоненте формы \cdf{defstruct}, когда
используется функцией-конструктором, перевычисляется при каждом вызове
функции. Это, как если бы формы инициализации использовались как формы
\emph{init} для именованных параметров функции-конструктора.
Например, если форма \cd{(gensym)} используется как форма инициализации или в
вызове функции-конструктора, или форме инициализации слота в форме
\cdf{defstruct}, тогда каждый вызов функции-конструктора вызывал бы \cdf{gensym}
для создания нового символа.

\section{Параметры слотов для defstruct}
\label{Defstruct-Slot-Options}

Каждая форма \emph{slot-description} в форме \cdf{defstruct} может указывать
один или более параметров слота. \emph{slot-option} является парой ключевого
символа и значения (которое не является формой для вычисления, а является просто
значением).  Например:
\begin{lisp}
(defstruct ship \\
~~(x-position 0.0 \cd{:type} short-float) \\
~~(y-position 0.0 \cd{:type} short-float) \\
~~(x-velocity 0.0 \cd{:type} short-float) \\
~~(y-velocity 0.0 \cd{:type} short-float) \\
~~(mass *default-ship-mass* \cd{:type} short-float \cd{:read-only} t))
\end{lisp}
Этот пример содержит определение, что каждый слот будет всегда содержать
короткое с плавающей точкой число, и что последний слот не может быть изменён
после создания корабля \emph{ship}.
Доступные параметры для слотов \emph{slot-options}:
\begin{flushdesc}
\item[\cd{:type}] Параметр \cd{\cd{:type} \emph{type}} указывает, что
  содержимое слота будет всегда принадлежать указанному типу
  данных. Он похож на аналогичную декларацию для переменной или
  функции. И конечно же, он также декларирует возвращаемый
  \emph{функцией доступа} тип. Реализация может проверять или не
  проверять тип нового объекта при инициализации или присваивании
  слота.  Следует отметить, что форма аргумента \emph{type} не
  вычисляется, и следовательно должна быть корректным спецификатором
  типа.

\item[\cd{:read-only}] Параметр \cd{\cd{:read-only} \emph{x}}, при
  \emph{x} не {\false}, указывает , что этот слот не может быть
  изменён. Он будет всегда содержать значение, указанное во время
  создания экземпляра структуры.  \cdf{setf} не принимает
  \emph{функцию доступа} к данному слоту.  Если \emph{x} {\false},
  этот параметр ничего не меняет.  Следует отметить, что форма
  аргумента \emph{x} не вычисляется.
\end{flushdesc}

Следует отметить, что невозможно определить параметр для слота без указания
значение по-умолчанию.

\section{Параметры defstruct}
\label{DEFSTRUCT-OPTIONS}
\label{Defstruct-Hairy-Stuff}

Предыдущего описание \cdf{defstruct} достаточно для среднестатистического
использования. Оставшуюся часть этой главы занимает описание более сложных
возможностей функционала \cdf{defstruct}.

Данный раздел объясняет каждый параметр, который может быть
использован в \cdf{defstruct}. Параметр для \cdf{defstruct} может быть
или ключевым символом, или списком из ключевого символа и аргумента
для него. (Следует отметить, что синтаксис для параметров
\cdf{defstruct} отличается от синтаксиса пар, используемых для
параметров слота. Никакая часть этих параметров не вычисляется.)

\begin{flushdesc}
\item[\cd{:conc-name}] Данный параметр предоставляет префикс для имён функций
  доступа.  По соглашению, имена всех функций доступа к слотам структуры
  начинаются с префикса --- имени структуры с последующим дефисом. Это поведение
  по-умолчанию.

  Аргумент \cd{:conc-name} указывает альтернативный префикс. (Если в качестве
  разделителя используется дефис, он указывается как часть префикса.) Если в
  качестве аргумента указано {\false}, тогда префикс не устанавливается вообще.
  Тогда имена функций доступа совпадают с именами слотов, и это повод давать
  слотам информативные имена.

  Следует отметить, что не зависимо от того, что указано в \cd{:conc-name}, в
  функции-конструкторе используются ключевые символы, совпадающие с именами
  слотов без присоединяемого префикса. С другой стороны префикс используется в
  именах функций доступа. Например:
  \begin{lisp}
    (defstruct door knob-color width material) \\
    (setq my-door \\
    ~~~~~~(make-door :knob-color 'red :width 5.0)) \\
    (door-width my-door) \EV\ 5.0 \\
    (setf (door-width my-door) 43.7) \\
    (door-width my-door) \EV\ 43.7 \\
    (door-knob-color my-door) \EV\ red
  \end{lisp}

\item[\cd{:constructor}] Данный параметр принимает один аргумент,
  символ, который указывает имя функции-конструктора. Если аргумент не
  указан, или если не указан параметр, имя конструктора создаётся
  соединением строки \cd{"MAKE-"} и имени структуры, и помещается в
  текущий пакет во время выполнения формы \cdf{defstruct} (смотрите
  \cdf{*package*}).  Если аргумент указан и равен {\false}, то функция
  конструктор не создаётся.

  Этот параметр имеет более сложный синтаксис, описываемый в
  разделе~\ref{DEFSTRUCT-CONSTRUCTOR-SYNTAX}.

\item[\cd{:copier}] Данный параметр принимает один аргумент, символ, который
  указывает имя функции копирования. Если аргумент не указан, или если не указан
  весь параметр, имя функции копирования создаётся соединением строки
  \cd{"COPY-"} и имени структуры, и помещается в текущий пакет в время
  выполнения формы \cdf{defstruct} (смотрите \cdf{*package*}).  Если аргумент
  указан и равен {\false}, то функция копирования не создаётся.

  Автоматически создаваемая функция копирования просто создаёт новую структуру и
  переносит все компоненты из структуры аргумента в свеже создаваемую
  структуру. Копирование самих компонентов структуры не производится.
  Соответствующие элементы старой и новой структуры равны \cdf{eql} между собой.

\item[\cd{:predicate}] Этот параметр принимает один аргумент, который задаёт имя
  предиката типа.  Если аргумент не указан, или если не указан весь параметр, то
  имя предиката создаётся соединением имени структуры и строки \cd{"-P"},
  помещая имя в текущий пакет на момент вычисления формы \cdf{defstruct}
  (смотрите \cdf{*package*}).  Если указанный аргумент равен {\false}, предикат
  не создаётся.  Предикат может быть определён, только если структура имеет
  <<имя>>.  Если указан параметр \cd{:type} и не указан \cd{:named}, тогда
  параметр \cd{:predicate} не должен использоваться или должна иметь значение
  {\false}.

\item[\cd{:include}] Этот параметр используется для создания нового определения
  структуры как расширения для старого определения структуры. В качестве
  примера, предположим у вас есть структура, называемая \cdf{person}, которая
  выглядит так:
  \begin{lisp}
    (defstruct person name age sex)
  \end{lisp}
  Теперь, предположим, вы хотите создать новую структуру для представления
  астронавта.  Так как астронавт также человек, вы хотите, чтобы он также имел
  свойства имя, возраст и пол, и вы хотите чтобы Lisp'овые функции работали со
  структурами \cdf{astronaut} также как и с структурами \cdf{person}. Вы можете
  сделать это определив структуру \cdf{astronaut} с параметром \cd{:include},
  так:
  \begin{lisp}
    (defstruct (astronaut (:include person) \\
    ~~~~~~~~~~~~~~~~~~~~~~(:conc-name astro-)) \\
    ~~~helmet-size \\
    ~~~(favorite-beverage 'tang))
  \end{lisp}

  Параметр \cd{:include} заставляет структуру, будучи определённой, иметь те же
  слоты, что и включаемая в параметре структура.  Это реализуется с помощью
  того, что функции доступа включаемой структуры будут также работать с
  определяемой структурой.  Таким образом, в этом примере, \cdf{astronaut} будет
  иметь пять слотов: три определены в \cdf{person} и два в самом
  \cdf{astronaut}.  Функции доступа, определённые с помощью структуры
  \cdf{person}, могут применяться к экземплярам структуры \cdf{astronaut}, и
  будут корректно работать.  Более того, \cdf{astronaut} будет иметь свои
  функции доступа для компонентов унаследованных от структуры \cdf{person}.
  Следующий пример иллюстрирует то, как вы можете использовать структуры
  \cd{astronaut}:
  \begin{lisp}
    (setq x (make-astronaut :name 'buzz \\
    ~~~~~~~~~~~~~~~~~~~~~~~~:age 45 \\
    ~~~~~~~~~~~~~~~~~~~~~~~~:sex t \\
    ~~~~~~~~~~~~~~~~~~~~~~~~:helmet-size 17.5)) \\
    \\
    (person-name x) \EV\ buzz \\
    (astro-name x) \EV\ buzz \\
    \\
    (astro-favorite-beverage x) \EV\ tang
  \end{lisp}
  Различие между функциями доступа \cdf{person-name} и \cdf{astro-name} в том,
  что \cdf{person-name} может быть корректно применена к любому экземпляру
  \cdf{person}, включая \cdf{astronaut}, тогда как \cdf{astro-name} может
  работать только с \cdf{astronaut}. (Реализация может проверять или не
  проверять корректное использоваться таких функций доступа.)

  В одной форме \cdf{defstruct} не может использовать более одного параметра
  \cdf{:include}.  Аргумент для параметра \cd{:include} является обязательным и
  должен быть именем определённой ранее структуры. Если структура, будучи
  определённой, не содержала параметра \cd{:type}, тогда наследуемая структура
  также не должна содержать этот параметр.  Если структура, будучи определённой,
  содержала параметр \cd{:type}, тогда наследуемая структура должна содержать
  этот параметр с тем же типом.

  Если параметр \cd{:type} не указан, тогда имя структуры становиться именем
  типа данных. Более того, тип будет является подтипом типа структуры, от
  которой произошло наследование. В вышеприведённом примере, \cdf{astronaut}
  является подтипом \cdf{person}. Так,
  \begin{lisp}
    (typep (make-astronaut) 'person)
  \end{lisp}
  но и указывает, что все операции над \cdf{person} будут также работать для
  \cdf{astronaut}.

  Далее рассказывается чуть более сложные возможности параметра \cd{:include}.
  Иногда, когда одна структура включает другую, необходимо, чтобы значения
  по-умолчанию или параметры слотов из родительской структуры при наследовании
  стали слегка другими.  Новая структура может задать значения по-умолчанию или
  параметры для наследуемых слотов отличными от родительских, с помощью
  конструкции:
  \begin{lisp}
    (:include \emph{name} \emph{slot-description-1} \emph{slot-description-2}
    ...)
  \end{lisp}
  Каждая форма \emph{slot-description-j} должна иметь имя \emph{slot-name} или
  \emph{slot-keyword}, такое же как в родительской структуре.  Если
  \emph{slot-description-j} не имеет формы инициализации \emph{default-init},
  тогда в новой структуре слот также не будет иметь первоначального значения. В
  противном случае его первоначальное значение будет заменено формой
  \emph{default-init} из \emph{slot-description-j}.  Доступный для записи слот
  может быть переделан в слот только для чтения.  Если слот только для чтения в
  родительской структуре, тогда он также должен быть только для чтения в
  дочерней.  Если для слота указан тип, он должен быть таким же или подтипом в
  дочерней структуре. Если это строгий подтип, то реализация может проверять или
  не проверять ошибки несовпадения типов при присваивании значений слотам.

  Например, если мы хотели бы определить \cdf{astronaut} так, чтобы по-умолчанию
  возрастом астронавта было 45 лет, то мы могли бы сказать:
  \begin{lisp}
    (defstruct (astronaut (:include person (age 45))) \\
    ~~~helmet-size \\
    ~~~(favorite-beverage 'tang))
  \end{lisp}

\item[\cd{:print-function}] Этот параметр может использоваться, только
  если не параметр \cd{:type} не была указан.  Аргумент для параметра
  \cd{:print-function} должен быть функцией трёх аргументов, в форме
  принимаемой оператором \cdf{function}. Эта функция используется для
  вывода рассматриваемой структуры.  Когда структура выводится на
  консоль, данная функция вызывается с тремя аргументами: структура
  для печати, поток, в который производить вывод, и целое число,
  отображающее текущую глубину (можно сравнить с \cdf{*print-level*}).
  Функция вывода должна следить за значениями таких переменных
  настройки вывода, как \cdf{*print-escape*} и \cdf{*print-pretty*}.

  Если параметры \cd{:print-function} и \cd{:type} не указаны, тогда
  функция вывода по-умолчанию выводит все слоты используя синтаксис
  \cd{\#S} (смотрите раздел~\ref{SHARP-SIGN-MACRO-CHARACTER-SECTION}).

\item[\cd{:type}] Параметр \cd{:type} явно задаёт представление
  используемое для структуры. Он принимает один аргумент, который
  должен быть одним из перечисленных ниже.

  Этот параметр заставляет использовать указанное представление и заставляет
  компоненты быть размещёнными в порядке, предусмотренном в \cdf{defstruct}
  форме, в соответствующие последовательные элементы указанного представления.
  Параметр также отключает возможность имени структуры стать именем типа.
  (смотрите раздел~\ref{EXPLICIT-TYPE-STRUCTURES}).

  Обычно этот параметр не используется, и тогда структура представляется так,
  как предусмотрено в реализации.

  \begin{quotation} % Merely to advance the left margin
    \begin{flushdesc}

    \item[\cdf{vector}] Структура представляется как вектор \cd{(vector
        t)}. размещая компоненты как элементы вектора. Первый компонент
      находится в первом элементе вектора, если структура содержит параметр
      \cd{:named}, и в нулевом, если структура содержит \cd{:unnamed}.

    \item[\cd{(vector \emph{element-type})}] Структура представляется как
      (возможно специализированный) вектор, размещая компоненты как элементы
      вектора. Каждый компонент должен принадлежать типу, который мог быть
      указан для вектора. Первый компонент находится в первом элементе вектора,
      если структура содержит параметр \cd{:named}, и в нулевом, если структура
      содержит \cd{:unnamed}.  Структура может быть \cd{:named}, только если тип
      \cdf{symbol} является подтипом указанного в \cdf{element-type}.

    \item[\cdf{list}] Структура представляется как список.  Первый компонент
      является \emph{cadr} элементом, если структура содержит \cd{:named}, и
      является \emph{car} элементом, если структура содержит \cd{:unnamed}.
    \end{flushdesc}
  \end{quotation}

\item[\cd{:named}] Параметр \cd{:named} указывает, что структура будет иметь
  <<имя>>. Этот параметр не принимает аргументов. Если параметр \cd{:type} не
  указан, тогда структура имеет имя. Таким образом этот параметр полезен только
  при использовании вместе с \cd{:type}.  Смотрите
  раздел~\ref{EXPLICIT-TYPE-STRUCTURES} для подробного описания.

\item[\cd{:initial-offset}] Этот параметр позволяет вам указать \cdf{defstruct}
  пропустить указанное количество слотов, перед тем как начинать размещать
  указанные в теле слоты. Эта параметр требует аргумент, а именно,
  неотрицательное целое, обозначающее количество пропускаемых слотов. Параметр
  \cd{:initial-offset} может использоваться, только если также указан параметр
  \cd{:type}.  Смотрите раздел~\ref{DEFSTRUCTU-INIITAL-OFFSET} для подробного
  описания.
\end{flushdesc}

\section{Функции-конструкторы с позиционными аргументами}
\label{DEFSTRUCT-CONSTRUCTOR-SYNTAX}

Если параметр \cd{:constructor} указан: так \cd{(\cd{:constructor} \emph{name}
  \emph{arglist})}, тогда вместо создания конструктора с именованными
параметрами, \cdf{defstruct} определит конструктор с позиционными аргументами.
Форма \emph{arglist} используется для описания того, какие аргументы будет
принимать конструктор. В простейшем случае что-то вроде \cd{(\cd{:constructor}
  make-foo (a b c))} определяет функцию \cdf{make-foo} с тремя аргументами,
которые используются для инициализации слотов \cdf{a}, \cdf{b} и \cdf{c}.

Кроме того в списке аргументов могут использоваться \cd{\&optional}, \cd{\&rest}
и \cd{\&aux}. Они работают так, как и ожидается, но есть несколько тонкостей
требующих объяснения. Рассмотрим пример:
\begin{lisp}
(\cd{:constructor} create-foo \\
~~~~~~~~(a \&optional b (c 'sea) \&rest d \&aux e (f 'eff)))
\end{lisp}
Эта конструкция определяет конструктор \cdf{create-foo} для использования с
одним или более аргументами. Первый аргумент используется для инициализации
слота \cdf{a}. Если второй параметр не указан, используется значение (если
указано) по-умолчанию из тела \cdf{defstruct}. Третий аргумент используется для
инициализации слота \cdf{c}. Если третий параметр не указан, тогда используется
символ \cdf{sea}. Все параметры после третьего собираются в список и
используются для инициализации слота \cdf{d}. Если указано три и более
параметров, тогда в слот \cdf{d} помещается значение {\false}. Слот \cdf{e}
\emph{не инициализируется}. Его первоначальное значение не определено. Наконец,
слот \cdf{f} инициализируется символом \cdf{eff}.

Действия со слотами \cdf{b} и \cdf{e} выбраны не случайно, а для того чтобы
показать все возможные случаи использования аргументов.
Следует отметить, что \cd{\&aux} (вспомогательные) <<переменные>> могут
использоваться для перекрытия форм инициализации из тела \cdf{defstruct}.

Следуя этому определению можно записать
\begin{lisp}
(create-foo 1 2)
\end{lisp}
вместо
\begin{lisp}
(make-foo \cd{:a} 1 \cd{:b} 2)
\end{lisp}
и, конечно, \cdf{create-foo} предоставляет инициализацию отличную от
\cdf{make-foo}.

Использовать \cd{:constructor} можно более одного раза. Таким образом вы можете
определить несколько различных функций-конструкторов с различными аргументами.

\section{Структуры с явно заданным типом представления}
\label{EXPLICIT-TYPE-STRUCTURES}

Иногда необходимо явно контролировать представление структуры. Параметр
\cd{:type} позволяет выбрать представление между списком или некоторым видом
вектора и указать соотвествие для размещения слотов в выбранном представлении.
Структура также может быть <<безымянной>> или <<именованной>>. Это означает
может ли имя структуры быть сохранено в ней самой (и соответственно, прочитано
из неё).

\subsection{Безымянные структуры}

Иногда конкретное представление данных навязывается внешними требованиями и,
кроме того, формат данных прекрасно ложится в структурный стиль хранения.
Например, рассмотрим выражение созданное из чисел, символов и таких операций как
\cdf{+} и \cdf{*}. Операция может быть представлена, как в Lisp'е, списком из
оператора и двух операндов. Этот факт может быть выражен кратко в терминах
\cdf{defstruct}:
\begin{lisp}
(defstruct (binop (:type list)) \\
~~(operator '? :type symbol) \\
~~operand-1 \\
~~operand-2)
\end{lisp}

Результатом выполнения \cdf{make-binop} является 3-ёх элементный список:
\begin{lisp}
(make-binop :operator '+ :operand-1 'x :operand-2 5) \\*
~~~\EV\ (+ x 5) \\
\\
(make-binop :operand-2 4 :operator '*) \\*
~~~\EV\ (* {\nil} 4)
\end{lisp}
Выглядит как функция \cdf{list} за исключением того, что принимает именованные
параметры и выполняет инициализацию слотов соответствующую концептуальному типу
данных \cdf{binop}.
Таким же образом, селекторы \cdf{binop-operator}, \cdf{binop-operand-1} и
\cdf{binop-operand-2} эквивалентны соответственно \cdf{car}, \cdf{cadr} и
\cdf{caddr}. (Они, конечно, не полностью эквивалентны, так как реализация
может осуществлять проверки типов элементов, длины массивов при использовании
селекторов слотов структур.)

Мы говорим о \cdf{binop} как о <<концептуальном>> типе данных, потому что
\cdf{binop} не принадлежит Common Lisp'овой системе типов. Предикат \cdf{typep}
не может использовать \cdf{binop} как спецификатор типа, и \cdf{type-of} будет
возвращать \cdf{list} для заданной \cdf{binop} структуры. Несомненно, различий
между структурой данных, созданной с помощью \cdf{make-binop}, и простым
списком нет.

Невозможно даже получить имя структуры для объекта, созданного с помощью
\cdf{make-binop}. Однако имя может быть сохранено и получено, если структура
содержит <<имя>>.

\subsection{Именованные структуры}

Структура с <<именем>> имеет свойство, которое заключается в том, что для любого
экземпляра структуры можно получить имя этой структуры. Для структур
определённых без указания параметра \cd{:type}, имя структуры фактически становится
частью Common Lisp'овой системы типов. Функция \cdf{type-of} при применении к
экземпляру такой структуры будет возвращать имя структуры. Предикат \cdf{typep}
будет рассматривать имя структуры, как корректный спецификатор типа.

Для структур определённых с параметром \cd{:type}, \cdf{type-of} будет
возвращать спецификатор типа один из \cdf{list} или \cdf{(vector t)}, в
зависимости от указанного аргумента параметра \cd{:type}.  Имя структуры не
становится корректным спецификатором типа. Однако если также указан параметр
\cd{:named}, тогда первый компонент структуры всегда содержит её имя. Это
позволяет получить это имя, имея только экземпляр структуры. Это также позволяет
автоматически определить предикат для концептуального типа.  Предикат
\cd{\emph{name}-p} для структуры принимает в качестве первого аргумента объект и
истинен, если объект является экземпляром структуры, иначе ложен.

Рассмотрим вышеупомянутый пример \cdf{binop} и модифицируем его, добавив
параметр \cd{:named}:
\begin{lisp}
(defstruct (binop (:type list) :named) \\
~~(operator '? :type symbol) \\
~~operand-1 \\
~~operand-2)
\end{lisp}
Как и раньше, конструкция определить функцию-конструктор \cdf{make-binop} и три
функции-селектора  \cdf{binop-operator}, \cd{binop-operand-1} и
\cd{binop-operand-2}. Она также определит предикат \cdf{binop-p}.

Результатом \cdf{make-binop} теперь является список с 4-мя элементами:
\begin{lisp}
(make-binop :operator '+ :operand-1 'x :operand-2 5) \\*
~~~\EV\ (binop + x 5) \\
\\
(make-binop :operand-2 4 :operator '*) \\*
~~~\EV\ (binop * {\nil} 4)
\end{lisp}
Структура имеет такую же разметку как и раньше за исключением имени структуры в
первом элементе.
Функции-селекторы
\cdf{binop-operator}, \cd{binop-operand-1}и \cd{binop-operand-2} эквивалентны
соответственно \cdf{cadr}, \cdf{caddr} и \cdf{cadddr}.
Предикат \cdf{binop-p} примерно соответствует следующему определению.
\begin{lisp}
(defun binop-p (x) \\
~~(and (consp x) (eq (car x) 'binop)))
\end{lisp}
Имя \cdf{binop} не является корректным спецификатором типа, и не может
использоваться в \cdf{typep}. Но с помощью предиката структура теперь отличима 
от других структур. 

\subsection{Другие аспекты явно определённых типов для представления структур}
\label{DEFSTRUCT-INITIAL-OFFSET}

Параметр \cd{:initial-offset} позволяет указывать начало размещения слотов в
представлении структуры. Например, форма
\begin{lisp}
(defstruct (binop (:type list) (:initial-offset 2)) \\*
~~(operator '? :type symbol) \\*
~~operand-1 \\*
~~operand-2)
\end{lisp}
создаст конструктор \cdf{make-binop} со следующим поведением:
\begin{lisp}
(make-binop :operator '+ :operand-1 'x :operand-2 5) \\*
~~~\EV\ (nil nil + x 5) \\
\\
(make-binop :operand-2 4 :operator '*) \\*
~~~\EV\ (nil nil * {\nil} 4)
\end{lisp}
Селекторы
\cdf{binop-operator}, \cd{binop-operand-1} и \cd{binop-operand-2} 
будут эквивалентны соответственно \cdf{caddr},
\cdf{cadddr}, и \cdf{car} от \cdf{cddddr}.
Таким же образом, форма
\begin{lisp}
(defstruct (binop (:type list) :named (:initial-offset 2)) \\*
~~(operator '? :type symbol) \\*
~~operand-1 \\*
~~operand-2)
\end{lisp}
создаст конструктор \cdf{make-binop} со следующим поведением:
\begin{lisp}
(make-binop :operator '+ :operand-1 'x :operand-2 5) \\*
~~~\EV\ (nil nil binop + x 5) \\
\\
(make-binop :operand-2 4 :operator '*) \\*
~~~\EV\ (nil nil binop * {\nil} 4)
\end{lisp}

Если вместе с параметром \cd{:type} используется \cd{:include}, тогда в
представлении выделяется столько места, сколько необходимо для родительской
структуры, затем пропускается столько места, сколько указано в параметре
\cd{:initial-offset}, и затем начинается расположение элементов определяемой
структуры.  Например:
\begin{lisp}
(defstruct (binop (:type list) :named (:initial-offset 2)) \\
~~(operator '? :type symbol) \\
~~operand-1 \\
~~operand-2) \\
 \\
(defstruct (annotated-binop (:type list) \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(:initial-offset 3) \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(:include binop)) \\
~~commutative associative identity) \\
 \\
(make-annotated-binop :operator '* \\
~~~~~~~~~~~~~~~~~~~~~~:operand-1 'x \\
~~~~~~~~~~~~~~~~~~~~~~:operand-2 5 \\
~~~~~~~~~~~~~~~~~~~~~~:commutative t \\
~~~~~~~~~~~~~~~~~~~~~~:associative t \\
~~~~~~~~~~~~~~~~~~~~~~:identity 1) \\
~~~\EV\ (nil nil binop * x 5 nil nil nil t t 1)
\end{lisp}
Первые два {\nil} элемента пропущены по причине параметра \cd{:initial-offset}
со значением \cd{2} в определении \cdf{binop}. Следующие четыре элемента
содержат имя и три слота структуры \cdf{binop}. Следующие три {\nil} элементы
пропущено по причине параметра \cd{:initial-offset} за значением \cd{3} в
определении структуры \cdf{annotated-binop}. Последние три элемента содержат три
слота, определённых в структуре \cdf{annotated-binop}.
\fi