<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Generalized Variables</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2013-03-12 14:37:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Main Page</a>&gt; &lt;<a href="symbols.html">Symbols</a>&gt; <br> &#x003C;<a 
href="clmse37.html" >Next</a>&#x003E;&#x003C;<a 
href="clmse35.html" >Prev</a>&#x003E;&#x003C;<a 
href="clmse35.html#tailclmse35.html" >PrevTail</a>&#x003E;&#x003C;<a 
href="#tailclmse36.html">Tail</a>&#x003E;&#x003C;<a 
href="contrl.html#clmse36.html" >Up</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">7.2   </span> <a 
href="clm.html#QQ2-48-86" id="x48-780007.2">Generalized Variables</a></h3>
<!--l. 619--><p class="noindent" >In Lisp, a variable can remember one piece of data, that is, one Lisp object. The
main operations on a variable are to recover that object and to alter the variable
to remember a new object; these operations are often called <em>access</em> and
<em>update</em> operations. The concept of variables named by symbols can be
generalized to any storage location that can remember one piece of data, no
matter how that location is named. Examples of such storage locations are
the <em>car</em> and <em>cdr</em> of a cons, elements of an array, and components of a
structure.
<!--l. 629--><p class="indent" >   For each kind of generalized variable, typically there are two functions that
implement the conceptual <em>access</em> and <em>update</em> operations. For a variable, merely
mentioning the name of the variable accesses it, while the <b><a 
href="symbols.html#x200-396846r846">setq</a></b> special operator
can be used to update it. The function <b><a 
href="symbols.html#x200-396191r191">car</a></b> accesses the <em>car</em> of a cons, and the
function <b><a 
href="symbols.html#x200-396825r825">rplaca</a></b> updates it. The function <b><a 
href="symbols.html#x200-396950r950">symbol-value</a></b> accesses the dynamic
value of a variable named by a given symbol, and the function <b><a 
href="symbols.html#x200-396837r837">set</a></b> updates
it.
<!--l. 638--><p class="indent" >   Rather than thinking about two distinct functions that respectively access and
update a storage location somehow deduced from their arguments, we can instead
simply think of a call to the access function with given arguments as a <em>name</em> for
the storage location. Thus, just as <b>x</b> may be considered a name for a
storage location (a variable), so <b>(car x)</b> is a name for the <em>car</em> of some cons
(which is in turn named by <b>x</b>). Now, rather than having to remember two
functions for each kind of generalized variable (having to remember, for
example, that <b><a 
href="symbols.html#x200-396825r825">rplaca</a></b> corresponds to <b><a 
href="symbols.html#x200-396191r191">car</a></b>), we adopt a uniform syntax for
updating storage locations named in this way, using the <b><a 
href="symbols.html#x200-396845r845">setf</a></b> macro. This is
analogous to the way we use the <b><a 
href="symbols.html#x200-396846r846">setq</a></b> special operator to convert the
name of a variable (which is also a form that accesses it) into a form that
updates it. The uniformity of this approach is illustrated in the following
table.
<div class="flushleft" 
>
<!--l. 653--><p class="noindent" >
                                                                          

                                                                          
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Access Function     </td><td align="left" >Update Function   </td><td align="left" >Update Using <b><a 
href="symbols.html#x200-396845r845">setf</a></b>                  </td>
</tr><tr><td align="left" ><b>x</b>                     </td><td align="left" ><b>(setq x datum)</b>   </td><td align="left" ><b>(setf x datum)</b>                    </td>
</tr><tr><td align="left" ><b>(car x)</b>              </td><td align="left" ><b>(rplaca x datum)</b></td><td align="left" ><b>(setf (car x) datum)</b>             </td>
</tr><tr><td align="left" ><b>(symbol-value x)</b> </td><td align="left" ><b>(set x datum)</b>    </td><td align="left" ><b>(setf (symbol-value x) datum)</b></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" >  </td></tr></table>
</div></div>
<b>
<!--l. 663--><p class="noindent" ><a 
href="symbols.html#x200-396845r845">setf</a></b> is actually a macro that examines an access form and produces a call to the
corresponding update function.
<!--l. 666--><p class="indent" >   Given the existence of <b><a 
href="symbols.html#x200-396845r845">setf</a></b> in Common Lisp, it is not necessary to have <b><a 
href="symbols.html#x200-396846r846">setq</a></b>,
<b><a 
href="symbols.html#x200-396825r825">rplaca</a></b>, and <b><a 
href="symbols.html#x200-396837r837">set</a></b>; they are redundant. They are retained in Common Lisp because
of their historical importance in Lisp. However, most other update functions (such
as <b>putprop</b>, the update function for <b><a 
href="symbols.html#x200-396462r462">get</a></b>) have been eliminated from
Common Lisp in the expectation that <b><a 
href="symbols.html#x200-396845r845">setf</a></b> will be uniformly used in their
place.
<div class="defmac">
<div class="defmacheader">
<!--l. 674--><p class="indent" >   <div class="tabbing">
 <em>[Macro]</em> <b>setf</b> <a 
 id="dx48-78001"></a>{place newvalue}*
   <br>
<!--l. 675--><p class="noindent" ></div>
</div>
<b>
<!--l. 676--><p class="indent" >   (setf <em>place</em> <em>newvalue</em>)</b> takes a form <em>place</em> that when evaluated <em>accesses</em> a
data object in some location and “inverts” it to produce a corresponding form to
<em>update</em> the location. A call to the <b><a 
href="symbols.html#x200-396845r845">setf</a></b> macro therefore expands into an update
form that stores the result of evaluating the form <em>newvalue</em> into the place referred
to by the access form.
<!--l. 683--><p class="indent" >   If more than one <em>place</em>-<em>newvalue</em> pair is speciﬁed, the pairs are processed
sequentially; that is, <div class="lisp"><tt><div class="tabbing">
(setf <em>place1</em> <em>newvalue1</em>
   <br>                             <em>place2</em> <em>newvalue2</em>)<br>                               ...<br>
      <em>placen</em> <em>newvaluen</em>)<br>
<!--l. 690--><p class="noindent" ></div>
                                                                          

                                                                          
</tt>
</div>
<!--l. 691--><p class="indent" >   is precisely equivalent to <div class="lisp"><tt><div class="tabbing">
(progn (setf <em>place1</em> <em>newvalue1</em>)
   <br>                           (setf <em>place2</em> <em>newvalue2</em>)<br>                           ...<br>
       (setf <em>placen</em> <em>newvaluen</em>))<br>
<!--l. 697--><p class="noindent" ></div>
</tt>
</div>
<!--l. 698--><p class="indent" >   For consistency, it is legal to write <b>(setf)</b>, which simply returns <b><a 
href="symbols.html#x200-396670r670">nil</a></b>.
<!--l. 700--><p class="indent" >   The form <em>place</em> may be any one of the following:
      <ul class="itemize1">
      <li class="itemize">The name of a variable (either lexical or dynamic).
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of any one of the
      following functions:
      <div class="flushleft" 
>
<!--l. 709--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" ><b><a 
href="symbols.html#x200-396105r105">aref</a></b>               </td><td align="left" ><b><a 
href="symbols.html#x200-396191r191">car</a></b>                            </td><td align="left" ><b><a 
href="symbols.html#x200-396943r943">svref</a></b>             </td><td align="left" >                     </td></tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396693r693">nth</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396209r209">cdr</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396462r462">get</a></b> </td> <td align="left" ></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396367r367">elt</a></b>                </td><td align="left" ><b><a 
href="symbols.html#x200-396180r180">caar</a></b>                           </td><td align="left" ><b><a 
href="symbols.html#x200-396473r473">getf</a></b>               </td><td align="left" ><b><a 
href="symbols.html#x200-396950r950">symbol-value</a></b>    </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396812r812">rest</a></b>               </td><td align="left" ><b><a 
href="symbols.html#x200-396187r187">cadr</a></b>                          </td><td align="left" ><b><a 
href="symbols.html#x200-396474r474">gethash</a></b>         </td><td align="left" ><b><a 
href="symbols.html#x200-396945r945">symbol-function</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396424r424">ﬁrst</a></b>              </td><td align="left" ><b><a 
href="symbols.html#x200-396201r201">cdar</a></b>                          </td><td align="left" ><b><a 
href="symbols.html#x200-396352r352">documentation</a></b></td><td align="left" ><b><a 
href="symbols.html#x200-396949r949">symbol-plist</a></b>     </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396835r835">second</a></b>           </td><td align="left" ><b><a 
href="symbols.html#x200-396208r208">cddr</a></b>                          </td><td align="left" ><b><a 
href="symbols.html#x200-396410r410">ﬁll-pointer</a></b>      </td><td align="left" ><b><a 
href="symbols.html#x200-396584r584">macro-function</a></b> </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396962r962">third</a></b>             </td><td align="left" ><b><a 
href="symbols.html#x200-396176r176">caaar</a></b>                         </td><td align="left" ><b><a 
href="symbols.html#x200-396174r174">caaaar</a></b>           </td><td align="left" ><b><a 
href="symbols.html#x200-396195r195">cdaaar</a></b>            </td></tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396440r440">fourth</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396179r179">caadr</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396175r175">caaadr</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396196r196">cdaadr</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396400r400">ﬁfth</a></b>              </td><td align="left" ><b><a 
href="symbols.html#x200-396183r183">cadar</a></b>                         </td><td align="left" ><b><a 
href="symbols.html#x200-396177r177">caadar</a></b>           </td><td align="left" ><b><a 
href="symbols.html#x200-396198r198">cdadar</a></b>            </td></tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396870r870">sixth</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396186r186">caddr</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396178r178">caaddr</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396199r199">cdaddr</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396847r847">seventh</a></b>          </td><td align="left" ><b><a 
href="symbols.html#x200-396197r197">cdaar</a></b>                         </td><td align="left" ><b><a 
href="symbols.html#x200-396181r181">cadaar</a></b>           </td><td align="left" ><b><a 
href="symbols.html#x200-396202r202">cddaar</a></b>            </td></tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396366r366">eighth</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396200r200">cdadr</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396182r182">cadadr</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396203r203">cddadr</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396672r672">ninth</a></b>             </td><td align="left" ><b><a 
href="symbols.html#x200-396204r204">cddar</a></b>                         </td><td align="left" ><b><a 
href="symbols.html#x200-396184r184">caddar</a></b>           </td><td align="left" ><b><a 
href="symbols.html#x200-396205r205">cdddar</a></b>            </td></tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396958r958">tenth</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396207r207">cdddr</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396185r185">cadddr</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396206r206">cddddr</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396824r824">row-major-aref</a></b></td><td align="left" ><b><a 
href="symbols.html#x200-396264r264">compiler-macro-function</a></b></td><td align="left" >                   </td><td align="left" >                     </td></tr></table>
</div></div>
      <!--l. 729--><p class="noindent" >This rule applies only when the function name refers to a global function
      deﬁnition and not to a locally deﬁned function or macro.
                                                                          

                                                                          
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of a selector function
      constructed by <b><a 
href="symbols.html#x200-396325r325">defstruct</a></b>.
      <!--l. 737--><p class="noindent" >This rule applies only when the function name refers to a global function
      deﬁnition and not to a locally deﬁned function or macro.
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of any one of the
      following functions, provided that the new value
      <!--l. 745--><p class="noindent" >is of the speciﬁed type so that it can be used to replace the speciﬁed
      “location” (which is in each of these cases not truly a generalized
      variable):
<div class="obsolete">
      <div class="flushleft" 
>
<!--l. 750--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Function Name</td><td align="left" >Required Type</td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396215r215">char</a></b>            </td><td align="left" ><b>string-char</b>   </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396833r833">schar</a></b>           </td><td align="left" ><b>string-char</b>   </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396135r135">bit</a></b>              </td><td align="left" ><b><a 
href="symbols.html#x200-396135r135">bit</a></b>             </td></tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396831r831">sbit</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x200-396135r135">bit</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396931r931">subseq</a></b>         </td><td align="left" ><b>sequence</b>     </td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
</div>
<div class="newer">
      <!--l. 766--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-78002"></a>to eliminate the type <b>string-char</b> and to
      redeﬁne <b><a 
href="symbols.html#x200-396910r910">string</a></b> to be the union of one or more specialized vector types, the
      types of whose elements are subtypes of the type <b><a 
href="symbols.html#x200-396234r234">character</a></b>. In the
      preceding table, the type <b>string-char</b> should be replaced by some such
      phrase as “the element-type of the argument vector.”
      </div>
<div class="newer">
      <!--l. 775--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-78003"></a>to clarify that this rule applies only when the
      function name refers to a global function deﬁnition and not to a locally
      deﬁned function or macro.
      </div>
                                                                          

                                                                          
      <!--l. 780--><p class="noindent" >In the case of <b><a 
href="symbols.html#x200-396931r931">subseq</a></b>, the replacement value must be a sequence whose
      elements may be contained by the sequence argument to <b><a 
href="symbols.html#x200-396931r931">subseq</a></b>. (Note that
      this is not so stringent as to require that the replacement value be a
      sequence of the same type as the sequence of which the subsequence is
      speciﬁed.) If the length of the replacement value does not equal the
      length of the subsequence to be replaced, then the shorter length
      determines the number of elements to be stored, as for the function
      <b><a 
href="symbols.html#x200-396811r811">replace</a></b>.
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of any one of the
      following functions, provided that the speciﬁed argument to that function is
      in turn a <em>place</em> form; in this case the new <em>place</em> has stored back into it the
      result of applying the speciﬁed “update” function (which is in each of these
      cases not a true update function):
      <div class="flushleft" 
>
<!--l. 797--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Function Name</td><td align="left" >Argument That Is a <em>place</em></td><td align="left" >Update Function Used</td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396523r523">ldb</a></b>             </td><td align="left" >second                         </td><td align="left" ><b><a 
href="symbols.html#x200-396358r358">dpb</a></b>                     </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x200-396623r623">mask-ﬁeld</a></b>    </td><td align="left" >second                         </td><td align="left" ><b><a 
href="symbols.html#x200-396336r336">deposit-ﬁeld</a></b>          </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
      <!--l. 807--><p class="noindent" >This rule applies only when the function name refers to a global function
      deﬁnition and not to a locally deﬁned function or macro.
      </li>
      <li class="itemize">A <b><a 
href="symbols.html#x200-396960r960">the</a></b> type declaration form, in which case the declaration is transferred to
      the <em>newvalue</em> form, and the resulting <b><a 
href="symbols.html#x200-396845r845">setf</a></b> form is analyzed. For example,
      <div class="lisp"><tt><div class="tabbing">
      (setf (the integer (cadr x)) (+ y 3))
      <br>
      <!--l. 817--><p class="noindent" ></div>
                                                                          

                                                                          
</tt>
</div>
      <!--l. 818--><p class="noindent" >is processed as if it were <div class="lisp"><tt><div class="tabbing">
      (setf (cadr x) (the integer (+ y 3)))
      <br>
      <!--l. 821--><p class="noindent" ></div>
</tt>
</div>
      </li>
      <li class="itemize">A call to <b><a 
href="symbols.html#x200-396101r101">apply</a></b> where the ﬁrst argument form is of the form <b>#&#x2019;<em>name</em></b>, that
      is, <b>(function <em>name</em>)</b>, where <em>name</em> is the name of a function, calls to which
      are recognized as places by <b><a 
href="symbols.html#x200-396845r845">setf</a></b>. Suppose that the use of <b><a 
href="symbols.html#x200-396845r845">setf</a></b> with <b><a 
href="symbols.html#x200-396101r101">apply</a></b>
      looks like this: <div class="lisp"><tt><div class="tabbing">
      (setf (apply #&#x2019;<em>name</em> <em>x1</em> <em>x2</em> ... <em>xn</em> <em>rest</em>) <em>x0</em>)
      <br>
      <!--l. 830--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 831--><p class="noindent" >The <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method for the function <em>name</em> must be such that <div class="lisp"><tt><div class="tabbing">
      (setf (<em>name</em> <em>z1</em> <em>z2</em> ... <em>zm</em>) <em>z0</em>)
      <br>
                                                                          

                                                                          
      <!--l. 834--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 835--><p class="noindent" >expands into a store form <div class="lisp"><tt><div class="tabbing">
      (<em>storefn</em> <em>zi<span class="math"><sub>1</sub></span></em> <em>zi<span class="math"><sub>2</sub></span></em> ... <em>zi<span class="math"><sub>k</sub></span></em> <em>zm</em>)
      <br>
      <!--l. 838--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 839--><p class="noindent" >That is, it must expand into a function call such that all arguments but the
      last may be any permutation or subset of the new value <em>z0</em> and
      the arguments of the access form, but the <em>last</em> argument of the
      storing call must be the same as the last argument of the access call.
      See <b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b> for more details on accessing and storing
      forms.
      <!--l. 846--><p class="noindent" >Given this, the <b><a 
href="symbols.html#x200-396845r845">setf</a></b>-of-<b><a 
href="symbols.html#x200-396101r101">apply</a></b> form shown above expands into <div class="lisp"><tt><div class="tabbing">
      (apply #&#x2019;<em>storefn</em> <em>xi<span class="math"><sub>1</sub></span></em> <em>xi<span class="math"><sub>2</sub></span></em> ... <em>xi<span class="math"><sub>k</sub></span></em> <em>rest</em>)
      <br>
      <!--l. 849--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 850--><p class="noindent" >As an example, suppose that the variable <b>indexes</b> contains a list of
      subscripts for a multidimensional array <em>foo</em> whose rank is not known until
      run time. One may access the indicated element of the array by writing
      <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
      (apply #&#x2019;aref foo indexes)
      <br>
      <!--l. 856--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 857--><p class="noindent" >and one may alter the value of the indicated element to that of <b>newvalue</b>
      by writing <div class="lisp"><tt><div class="tabbing">
      (setf (apply #&#x2019;aref foo indexes) newvalue)
      <br>
      <!--l. 861--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 863--><p class="noindent" >This rule applies only when the function name <b><a 
href="symbols.html#x200-396101r101">apply</a></b> refers to the global
      function deﬁnition and not to a locally deﬁned function or macro named
      <b><a 
href="symbols.html#x200-396101r101">apply</a></b>.
      </li>
      <li class="itemize">A macro call, in which case <b><a 
href="symbols.html#x200-396845r845">setf</a></b> expands the macro call and then analyzes
      the resulting form.
      <!--l. 871--><p class="noindent" >This step uses <b><a 
href="symbols.html#x200-396586r586">macroexpand-1</a></b>, not <b><a 
href="symbols.html#x200-396585r585">macroexpand</a></b>. This allows the
      chance to apply any of the rules preceding this one to any of the
      intermediate expansions.
      </li>
      <li class="itemize">Any form for which a <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> or <b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b> declaration has been
      made.
      <!--l. 879--><p class="noindent" >This rule applies only when the function name in the form refers to a
      global function deﬁnition and not to a locally deﬁned function or
      macro.
      </li></ul>
                                                                          

                                                                          
<div class="newer">
<!--l. 886--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-78004"></a>to add one more rule to the preceding list, coming
after all those listed above:
      <ul class="itemize1">
      <li class="itemize">Any other list whose ﬁrst element is a symbol (call it <em>f </em>). In this case, the
      call to <b><a 
href="symbols.html#x200-396845r845">setf</a></b> expands into a call to the function named by the list
      <b>(setf <em>f </em>)</b> (see section <a 
href="clmse35.html#x47-750007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). The ﬁrst argument is the new value and the
      remaining arguments are the values of the remaining elements of <em>place</em>.
      This expansion occurs regardless of whether either <em>f </em> or <b>(setf <em>f </em>)</b> is
      deﬁned as a function locally, globally, or not at all. For example,
      <div class="lisp"><tt><div class="tabbing">
      (setf (<em>f </em> <em>arg1</em> <em>arg2</em> ...) <em>newvalue</em>)
      <br>
      <!--l. 900--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 901--><p class="noindent" >expands into a form with the same eﬀect and value as <div class="lisp"><tt><div class="tabbing">
      (let ((#:temp1 <em>arg1</em>)     ;Force correct order of evaluation
      <br>                               (#:temp2 <em>arg2</em>)<br>                               ...<br>
                 (#:temp0 newvalue))<br>         (funcall (function (setf <em>f </em>))<br>
                      #:temp0<br>                               #:temp1<br>
                      #:temp2 ...))<br>
      <!--l. 911--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 912--><p class="noindent" >By convention, any function named <b>(setf <em>f </em>)</b> should return its ﬁrst argument
      as its only value, in order to preserve the speciﬁcation that <b><a 
href="symbols.html#x200-396845r845">setf</a></b> returns its
      <em>newvalue</em>.</li></ul>
                                                                          

                                                                          
</div>
<div class="new">
<!--l. 919--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-78005"></a>to add this case as well:
      <ul class="itemize1">
      <li class="itemize">A variable reference that refers to a symbol macro deﬁnition made by
      <b><a 
href="symbols.html#x200-396946r946">symbol-macrolet</a></b>, in which case <b><a 
href="symbols.html#x200-396845r845">setf</a></b> expands the reference and then
      analyzes the resulting form.</li></ul>
</div>
<b>
<!--l. 928--><p class="indent" >   <a 
href="symbols.html#x200-396845r845">setf</a></b> carefully arranges to preserve the usual left-to-right order in which the
various subforms are evaluated. On the other hand, the exact expansion for any
particular form is not guaranteed and may even be implementation-dependent; all
that is guaranteed is that the expansion of a <b><a 
href="symbols.html#x200-396845r845">setf</a></b> form will be an update form
that works for that particular implementation, and that the left-to-right
evaluation of subforms is preserved.
<!--l. 937--><p class="indent" >   The ultimate result of evaluating a <b><a 
href="symbols.html#x200-396845r845">setf</a></b> form is the value of <em>newvalue</em>.
Therefore <b>(setf (car x) y)</b> does not expand into precisely <b>(rplaca x y)</b>, but into
something more like <div class="lisp"><tt><div class="tabbing">
(let ((G1 x) (G2 y)) (rplaca G1 G2) G2)
   <br>
<!--l. 942--><p class="noindent" ></div>
</tt>
</div>
<!--l. 943--><p class="indent" >   the precise expansion being implementation-dependent.
<!--l. 945--><p class="indent" >   The user can deﬁne new <b><a 
href="symbols.html#x200-396845r845">setf</a></b> expansions by using <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b>.
<div class="newer">
<!--l. 948--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-78006"></a>to extend the speciﬁcation of <b><a 
href="symbols.html#x200-396845r845">setf</a></b> to allow a <em>place</em>
whose <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method has more than one store variable (see <b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b>).
In such a case as many values are accepted from the <em>newvalue</em> form as there are
store variables; extra values are ignored and missing values default to <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, as is
usual in situations involving multiple values.
<!--l. 956--><p class="indent" >   A proposal was submitted to X3J13 in September 1989 to add a <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method
for <b><a 
href="symbols.html#x200-397001r1001">values</a></b> so that one could in fact write, for example, <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(setf (values quotient remainder)
   <br>                                                     (truncate linewidth tabstop))<br>
<!--l. 962--><p class="noindent" ></div>
</tt>
</div>
<!--l. 963--><p class="indent" >   but unless this proposal is accepted users will have to deﬁne a <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method for
<b><a 
href="symbols.html#x200-397001r1001">values</a></b> themselves (not a diﬃcult task).
</div>
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 969--><p class="indent" >   <div class="tabbing">
 <em>[Macro]</em> <b>psetf</b> <a 
 id="dx48-78007"></a>{place newvalue}*
   <br>
<!--l. 970--><p class="noindent" ></div>
</div>
<b>
<!--l. 971--><p class="indent" >   <a 
href="symbols.html#x200-396765r765">psetf</a></b> is like <b><a 
href="symbols.html#x200-396845r845">setf</a></b> except that if more than one <em>place</em>-<em>newvalue</em> pair is speciﬁed,
then the assignments of new values to places are done in parallel. More
precisely, all subforms that are to be evaluated are evaluated from left to
right; after all evaluations have been performed, all of the assignments are
performed in an unpredictable order. (The unpredictability matters only if
more than one <em>place</em> form refers to the same place.) <b><a 
href="symbols.html#x200-396765r765">psetf</a></b> always returns
<b><a 
href="symbols.html#x200-396670r670">nil</a></b>.
<div class="newer">
<!--l. 981--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-78008"></a>to extend the speciﬁcation of <b><a 
href="symbols.html#x200-396765r765">psetf</a></b> to allow a <em>place</em>
whose <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method has more than one store variable (see <b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b>).
In such a case as many values are accepted from the <em>newvalue</em> form as there are
store variables; extra values are ignored and missing values default to <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, as is
usual in situations involving multiple values.
</div>
<hr></div>
<div class="defmac">
                                                                          

                                                                          
<div class="defmacheader">
<!--l. 992--><p class="indent" >   <div class="tabbing">
 <em>[Macro]</em> <b>shiftf</b> <a 
 id="dx48-78009"></a>{place}+ newvalue
   <br>
<!--l. 993--><p class="noindent" ></div>
</div>
<!--l. 994--><p class="indent" >   Each <em>place</em> form may be any form acceptable as a generalized variable to <b><a 
href="symbols.html#x200-396845r845">setf</a></b>.
In the form <b>(shiftf <em>place1</em> <em>place2</em> ... <em>placen</em> <em>newvalue</em>)</b>, the values in <em>place1</em>
through <em>placen</em> are accessed and saved, and <em>newvalue</em> is evaluated, for a total of
<span class="math"><em>n</em> + 1</span> values in all. Values 2 through <span class="math"><em>n</em> + 1</span> are then stored into <em>place1</em> through
<em>placen</em>, and value 1 (the original value of <em>place1</em>) is returned. It is as if all the
places form a shift register; the <em>newvalue</em> is shifted in from the right, all values
shift over to the left one place, and the value shifted out of <em>place1</em> is returned. For
example: <div class="lisp"><tt><div class="tabbing">
(setq x (list &#x2019;a &#x2019;b &#x2019;c)) <span class="math"> ⇒</span> (a b c)
   <br>                                                                                               <br>
(shiftf (cadr x) &#x2019;z) <span class="math"> ⇒</span> b<br>                             and now x <span class="math"> ⇒</span> (a z c)<br>
<br>                                          (shiftf (cadr x) (cddr x) &#x2019;q) <span class="math"> ⇒</span> z<br>
   and now x <span class="math"> ⇒</span> (a (c) . q)<br>
<!--l. 1012--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1013--><p class="indent" >   The eﬀect of <b>(shiftf <em>place1</em> <em>place2</em> ... <em>placen</em> <em>newvalue</em>)</b> is equivalent to
<div class="lisp"><tt><div class="tabbing">
(let ((<em>var1</em> <em>place1</em>)
   <br>                                                                          (<em>var2</em> <em>place2</em>)<br>
      ...<br>                                                  (<em>varn</em> <em>placen</em>))<br>
  (setf <em>place1</em> <em>var2</em>)<br>                                     (setf <em>place2</em> <em>var3</em>)<br>
  ...<br>                                                (setf <em>placen</em> <em>newvalue</em>)<br>
  <em>var1</em>)<br>
                                                                          

                                                                          
<!--l. 1025--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1026--><p class="indent" >   except that the latter would evaluate any subforms of each <em>place</em> twice,
whereas <b><a 
href="symbols.html#x200-396851r851">shiftf</a></b> takes care to evaluate them only once. For example: <div class="lisp"><tt><div class="tabbing">
(setq n 0)
   <br>         (setq x &#x2019;(a b c d))<br>         (shiftf (nth (setq n (+ n 1)) x) &#x2019;z) <span class="math"> ⇒</span> b<br>
   and now x <span class="math"> ⇒</span> (a z c d)<br>
<em>but</em>
   <br>
(setq n 0)
   <br>               (setq x &#x2019;(a b c d))<br>               (prog1 (nth (setq n (+ n 1)) x)<br>
       (setf (nth (setq n (+ n 1)) x) &#x2019;z)) <span class="math"> ⇒</span> b<br>   and now x <span class="math"> ⇒</span> (a b z d)<br>
<!--l. 1040--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1041--><p class="indent" >   Moreover, for certain <em>place</em> forms <b><a 
href="symbols.html#x200-396851r851">shiftf</a></b> may be signiﬁcantly more eﬃcient
than the <b><a 
href="symbols.html#x200-396760r760">prog1</a></b> version.
<div class="newer">
<!--l. 1045--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-78010"></a>to extend the speciﬁcation of <b><a 
href="symbols.html#x200-396851r851">shiftf</a></b> to
allow a <em>place</em> whose <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method has more than one store variable (see
<b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b>). In such a case as many values are accepted from the
<em>newvalue</em> form as there are store variables; extra values are ignored and
missing values default to <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, as is usual in situations involving multiple
values.
</div>
__________________________________________________________________________<div class="rationale">
<!--l. 1055--><p class="noindent" ><b>Rationale:</b> <b><a 
href="symbols.html#x200-396851r851">shiftf</a></b> and <b><a 
href="symbols.html#x200-396822r822">rotatef</a></b> have been included in Common Lisp as generalizations of
two-argument versions formerly called <b>swapf</b> and <b>exchf</b>. The two-argument versions
have been found to be very useful, but the names were easily confused. The
generalization to many argument forms and the change of names were both inspired by
the work of Suzuki <span class="cite">[<a 
href="bib.html#XSUZUKI-POINTER-ROTATION">47</a>]</span>, which indicates that use of these primitives can make
certain complex pointer-manipulation programs clearer and easier to prove
correct.
                                                                          

                                                                          
</div>
__________________________________________________________________________
<hr>
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1069--><p class="indent" >     <div class="tabbing">
  <em>[Macro]</em> <b>rotatef</b> <a 
 id="dx48-78011"></a>{place}*
     <br>
<!--l. 1070--><p class="noindent" ></div>
</div>
<!--l. 1071--><p class="indent" >     Each <em>place</em> form may be any form acceptable as a generalized variable to <b><a 
href="symbols.html#x200-396845r845">setf</a></b>.
In the form <b>(rotatef <em>place1</em> <em>place2</em> ... <em>placen</em>)</b>, the values in <em>place1</em>
through <em>placen</em> are accessed and saved. Values 2 through <em>n</em> and value
1 are then stored into <em>place1</em> through <em>placen</em>. It is as if all the places
form an end-around shift register that is rotated one place to the left,
with the value of <em>place1</em> being shifted around the end to <em>placen</em>. Note
that <b>(rotatef <em>place1</em> <em>place2</em>)</b> exchanges the contents of <em>place1</em> and
<em>place2</em>.
<!--l. 1082--><p class="indent" >     The eﬀect of <b>(rotatef <em>place1</em> <em>place2</em> ... <em>placen</em>)</b> is roughly equivalent to
<div class="lisp"><tt><div class="tabbing">
(psetf <em>place1</em> <em>place2</em>
    <br>                                <em>place2</em> <em>place3</em><br>                                ...<br>
       <em>placen</em> <em>place1</em>)<br>
<!--l. 1089--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1090--><p class="indent" >     except that the latter would evaluate any subforms of each <em>place</em> twice,
whereas <b><a 
href="symbols.html#x200-396822r822">rotatef</a></b> takes care to evaluate them only once. Moreover, for certain
<em>place</em> forms <b><a 
href="symbols.html#x200-396822r822">rotatef</a></b> may be signiﬁcantly more eﬃcient.
<b>
<!--l. 1095--><p class="indent" >     <a 
href="symbols.html#x200-396822r822">rotatef</a></b> always returns <b><a 
href="symbols.html#x200-396670r670">nil</a></b>.
<div class="newer">
                                                                          

                                                                          
<!--l. 1098--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-78012"></a>to extend the speciﬁcation of <b><a 
href="symbols.html#x200-396822r822">rotatef</a></b> to
allow a <em>place</em> whose <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method has more than one store variable (see
<b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b>). In such a case as many values are accepted from the
<em>newvalue</em> form as there are store variables; extra values are ignored and
missing values default to <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, as is usual in situations involving multiple
values.
</div>
<hr></div>
<!--l. 1108--><p class="indent" >   Other macros that manipulate generalized variables include <b><a 
href="symbols.html#x200-396473r473">getf</a></b>, <b><a 
href="symbols.html#x200-396797r797">remf</a></b>, <b><a 
href="symbols.html#x200-396494r494">incf</a></b>,
<b><a 
href="symbols.html#x200-396304r304">decf</a></b>, <b><a 
href="symbols.html#x200-396767r767">push</a></b>, <b><a 
href="symbols.html#x200-396731r731">pop</a></b>, <b><a 
href="symbols.html#x200-396127r127">assert</a></b>, <b><a 
href="symbols.html#x200-396303r303">ctypecase</a></b>, and <b><a 
href="symbols.html#x200-396194r194">ccase</a></b>.
<!--l. 1113--><p class="indent" >   Macros that manipulate generalized variables must guarantee the “obvious”
semantics: subforms of generalized-variable references are evaluated exactly as
many times as they appear in the source program, and they are evaluated in
exactly the same order as they appear in the source program.
<!--l. 1119--><p class="indent" >   In generalized-variable references such as <b><a 
href="symbols.html#x200-396851r851">shiftf</a></b>, <b><a 
href="symbols.html#x200-396494r494">incf</a></b>, <b><a 
href="symbols.html#x200-396767r767">push</a></b>, and <b><a 
href="symbols.html#x200-396845r845">setf</a></b> of <b><a 
href="symbols.html#x200-396523r523">ldb</a></b>,
the generalized variables are both read and written in the same reference.
Preserving the source program order of evaluation and the number of evaluations
is particularly important.
<!--l. 1124--><p class="indent" >   As an example of these semantic rules, in the generalized-variable reference
<b>(setf <em>reference</em> <em>value</em>)</b> the <em>value</em> form must be evaluated <em>after</em> all the
subforms of the reference because the <em>value</em> form appears to the right of
them.
<!--l. 1129--><p class="indent" >   The expansion of these macros must consist of code that follows these rules or
has the same eﬀect as such code. This is accomplished by introducing temporary
variables bound to the subforms of the reference. As an optimization in
the implementation, temporary variables may be eliminated whenever it
can be proved that removing them has no eﬀect on the semantics of the
program. For example, a constant need never be saved in a temporary
variable. A variable, or for that matter any form that does not have side
eﬀects, need not be saved in a temporary variable if it can be proved
that its value will not change within the scope of the generalized-variable
reference.
<!--l. 1140--><p class="indent" >   Common Lisp provides built-in facilities to take care of these semantic
complications and optimizations. Since the required semantics can be guaranteed
by these facilities, the user does not have to worry about writing correct code for
them, especially in complex cases. Even experts can become confused and make
mistakes while writing this sort of code.
<div class="newer">
                                                                          

                                                                          
<!--l. 1148--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-78013"></a>to clarify the preceding discussion about the order
of evaluation of subforms in calls to <b><a 
href="symbols.html#x200-396845r845">setf</a></b> and related macros. The general
intent is clear: evaluation proceeds from left to right whenever possible.
However, the left-to-right rule does not remove the obligation on writers of
macros and <b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b> to work to ensure left-to-right order of
evaluation.
<!--l. 1156--><p class="indent" >   Let it be emphasized that, in the following discussion, a <em>form</em> is something
whose syntactic use is such that it will be evaluated. A <em>subform</em> means a form
that is nested inside another form, not merely any Lisp object nested inside a
form regardless of syntactic context.
<!--l. 1161--><p class="indent" >   The evaluation ordering of subforms within a generalized variable
reference is determined by the order speciﬁed by the second value returned by
<b><a 
href="symbols.html#x200-396470r470">get-setf-method</a></b>. For all predeﬁned generalized variable references (<b><a 
href="symbols.html#x200-396473r473">getf</a></b>,
<b><a 
href="symbols.html#x200-396523r523">ldb</a></b>), this order of evaluation is exactly left-to-right. When a generalized
variable reference is derived from a macro expansion, this rule is applied
<em>after</em> the macro is expanded to ﬁnd the appropriate generalized variable
reference.
<!--l. 1170--><p class="indent" >   This is intended to make it clear that if the user writes a <b><a 
href="symbols.html#x200-396320r320">defmacro</a></b> or
<b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b> macro that doesn&#x2019;t preserve left-to-right evaluation
order, the order speciﬁed in the user&#x2019;s code holds. For example, given
<div class="lisp"><tt><div class="tabbing">
(defmacro wrong-order (x y) ‘(getf ,y ,x))
   <br>
<!--l. 1176--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1177--><p class="indent" >   then <div class="lisp"><tt><div class="tabbing">
(push <em>value</em> (wrong-order <em>place1</em> <em>place2</em>))
   <br>
<!--l. 1180--><p class="noindent" ></div>
</tt>
                                                                          

                                                                          
</div>
<!--l. 1181--><p class="indent" >   will evaluate <em>place2</em> ﬁrst and then <em>place1</em> because that is the order they are
evaluated in the macro expansion.
<!--l. 1184--><p class="indent" >   For the macros that manipulate generalized variables (<b><a 
href="symbols.html#x200-396767r767">push</a></b>, <b><a 
href="symbols.html#x200-396768r768">pushnew</a></b>, <b><a 
href="symbols.html#x200-396473r473">getf</a></b>,
<b><a 
href="symbols.html#x200-396797r797">remf</a></b>, <b><a 
href="symbols.html#x200-396494r494">incf</a></b>, <b><a 
href="symbols.html#x200-396304r304">decf</a></b>, <b><a 
href="symbols.html#x200-396851r851">shiftf</a></b>, <b><a 
href="symbols.html#x200-396822r822">rotatef</a></b>, <b><a 
href="symbols.html#x200-396765r765">psetf</a></b>, <b><a 
href="symbols.html#x200-396845r845">setf</a></b>, <b><a 
href="symbols.html#x200-396731r731">pop</a></b>, and those deﬁned with
<b><a 
href="symbols.html#x200-396317r317">deﬁne-modify-macro</a></b>) the subforms of the macro call are evaluated exactly once
in left-to-right order, with the subforms of the generalized variable references
evaluated in the order speciﬁed above.
<!--l. 1191--><p class="indent" >   Each of <b><a 
href="symbols.html#x200-396767r767">push</a></b>, <b><a 
href="symbols.html#x200-396768r768">pushnew</a></b>, <b><a 
href="symbols.html#x200-396473r473">getf</a></b>, <b><a 
href="symbols.html#x200-396797r797">remf</a></b>, <b><a 
href="symbols.html#x200-396494r494">incf</a></b>, <b><a 
href="symbols.html#x200-396304r304">decf</a></b>, <b><a 
href="symbols.html#x200-396851r851">shiftf</a></b>, <b><a 
href="symbols.html#x200-396822r822">rotatef</a></b>, <b><a 
href="symbols.html#x200-396765r765">psetf</a></b>, and
<b><a 
href="symbols.html#x200-396731r731">pop</a></b> evaluates all subforms before modifying any of the generalized variable
locations. Moreover, <b><a 
href="symbols.html#x200-396845r845">setf</a></b> itself, in the case when a call on it has more than two
arguments, performs its operation on each pair in sequence. That is, in
<div class="lisp"><tt><div class="tabbing">
(setf <em>place1</em> <em>value1</em> <em>place2</em> <em>value2</em> ...)
   <br>
<!--l. 1200--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1201--><p class="indent" >   the subforms of <em>place1</em> and <em>value1</em> are evaluated, the location speciﬁed by
<em>place1</em> is modiﬁed to contain the value returned by <em>value1</em>, and then the rest of
the <b><a 
href="symbols.html#x200-396845r845">setf</a></b> form is processed in a like manner.
<!--l. 1205--><p class="indent" >   For the macros <b><a 
href="symbols.html#x200-396236r236">check-type</a></b>, <b><a 
href="symbols.html#x200-396303r303">ctypecase</a></b>, and <b><a 
href="symbols.html#x200-396194r194">ccase</a></b>, subforms of the
generalized variable reference are evaluated once per test of a generalized variable,
but they may be evaluated again if the type check fails (in the case of
<b><a 
href="symbols.html#x200-396236r236">check-type</a></b>) or if none of the cases holds (in <b><a 
href="symbols.html#x200-396303r303">ctypecase</a></b> or <b><a 
href="symbols.html#x200-396194r194">ccase</a></b>).
<!--l. 1211--><p class="indent" >   For the macro <b><a 
href="symbols.html#x200-396127r127">assert</a></b>, the order of evaluation of the generalized variable
references is not speciﬁed.
</div>
<!--l. 1215--><p class="indent" >   Another reason for building in these functions is that the appropriate
optimizations will diﬀer from implementation to implementation. In some
implementations most of the optimization is performed by the compiler, while in
others a simpler compiler is used and most of the optimization is performed in the
macros. The cost of binding a temporary variable relative to the cost of other Lisp
operations may diﬀer greatly between one implementation and another, and some
                                                                          

                                                                          
implementations may ﬁnd it best never to remove temporary variables except in
the simplest cases.
<!--l. 1225--><p class="indent" >   A good example of the issues involved can be seen in the following
generalized-variable reference: <div class="lisp"><tt><div class="tabbing">
(incf (ldb byte-ﬁeld variable))
   <br>
<!--l. 1229--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1230--><p class="indent" >   This ought to expand into something like <div class="lisp"><tt><div class="tabbing">
(setq variable
   <br>           (dpb (1+ (ldb byte-ﬁeld variable))<br>                byte-ﬁeld<br>
           variable))<br>
<!--l. 1236--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1237--><p class="indent" >   In this expansion example we have ignored the further complexity
of returning the correct value, which is the incremented byte, not the
new value of <b>variable</b>. Note that the variable <b>byte-ﬁeld</b> is evaluated
twice, and the variable <b>variable</b> is referred to three times: once as the
location in which to store a value, and twice during the computation of that
value.
<!--l. 1245--><p class="indent" >   Now consider this expression: <div class="lisp"><tt><div class="tabbing">
(incf (ldb (aref byte-ﬁelds (incf i))
   <br>                                            (aref (determine-words-array) i)))<br>
<!--l. 1249--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1250--><p class="indent" >   It ought to expand into something like this: <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(let ((temp1 (aref byte-ﬁelds (incf i)))
   <br>            (temp2 (determine-words-array)))<br>        (setf (aref temp2 i)<br>
        (dpb (1+ (ldb temp1 (aref temp2 i)))<br>                    temp1<br>
             (aref temp2 i))))<br>
<!--l. 1258--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1259--><p class="indent" >   Again we have ignored the complexity of returning the correct value. What is
important here is that the expressions <b>(incf i)</b> and <b>(determine-words-array)</b>
must not be duplicated because each may have a side eﬀect or be aﬀected by side
eﬀects.
<div class="newer">
<!--l. 1266--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx48-78014"></a>to specify more precisely the order of evaluation
of subforms when <b><a 
href="symbols.html#x200-396845r845">setf</a></b> is used with an access function that itself takes a <em>place</em> as
an argument, for example, <b><a 
href="symbols.html#x200-396523r523">ldb</a></b>, <b><a 
href="symbols.html#x200-396623r623">mask-ﬁeld</a></b>, and <b><a 
href="symbols.html#x200-396473r473">getf</a></b>. (The vote also discussed
the function <b>char-bit</b>, but another vote <a 
 id="dx48-78015"></a>removed that function from the
language.) The <b><a 
href="symbols.html#x200-396845r845">setf</a></b> methods for such accessors produce expansions that
eﬀectively require explicit calls to <b><a 
href="symbols.html#x200-396470r470">get-setf-method</a></b>.
<!--l. 1275--><p class="indent" >   The code produced as the macro expansion of a <b><a 
href="symbols.html#x200-396845r845">setf</a></b> form that itself admits a
generalized variable as an argument must essentially do the following major
steps:
      <ul class="itemize1">
      <li class="itemize">It evaluates the value-producing subforms, in left-to-right order, and
      binds  the  temporary  variables  to  them;  this  is  called  <em>binding  the
      temporaries</em>.
      </li>
      <li class="itemize">It reads the value from the generalized variable, using the supplied
      accessing form, to get the old value; this is called <em>doing the access</em>.
      Note that this is done after all the evaluations of the preceding step,
      including any side eﬀects they may have.
      </li>
      <li class="itemize">It binds the store variable to a new value, and then installs this new
      value into the generalized variable using the supplied storing form; this
      is called <em>doing the store</em>.</li></ul>
                                                                          

                                                                          
<!--l. 1291--><p class="noindent" >Doing the access for a generalized variable reference is not part of the series of
evaluations that must be done in left-to-right order.
<!--l. 1294--><p class="indent" >   The place-speciﬁer forms <b><a 
href="symbols.html#x200-396523r523">ldb</a></b>, <b><a 
href="symbols.html#x200-396623r623">mask-ﬁeld</a></b>, and <b><a 
href="symbols.html#x200-396473r473">getf</a></b> admit (other) <em>place</em>
speciﬁers as arguments. During the <b><a 
href="symbols.html#x200-396845r845">setf</a></b> expansion of these forms, it is necessary
to call <b><a 
href="symbols.html#x200-396470r470">get-setf-method</a></b> to determine how the inner, nested generalized variable
must be treated.
<!--l. 1299--><p class="indent" >   In a form such as <div class="lisp"><tt><div class="tabbing">
(setf (ldb <em>byte-spec</em> <em>place-form</em>) <em>newvalue-form</em>)
   <br>
<!--l. 1302--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1303--><p class="indent" >   the place referred to by the <em>place-form</em> must always be both accessed and
updated; note that the update is to the generalized variable speciﬁed by
<em>place-form</em>, not to any object of type <b>integer</b>.
<!--l. 1307--><p class="indent" >   Thus this call to <b><a 
href="symbols.html#x200-396845r845">setf</a></b> should generate code to do the following:
      <ul class="itemize1">
      <li class="itemize">Evaluate <em>byte-spec</em> and bind into a temporary
      </li>
      <li class="itemize">Bind the temporaries for <em>place-form</em>
      </li>
      <li class="itemize">Evaluate <em>newvalue-form</em> and bind into the store variable
      </li>
      <li class="itemize">Do the access to <em>place-form</em>
      </li>
      <li class="itemize">Do the store into <em>place-form</em> with the given bit-ﬁeld of the accessed
      integer replaced with the value in the store variable</li></ul>
<!--l. 1316--><p class="noindent" >If the evaluation of <em>newvalue-form</em> alters what is found in the given <em>place</em>—such as
setting a diﬀerent bit-ﬁeld of the integer—then the change of the bit-ﬁeld denoted
by <em>byte-spec</em> will be to that altered integer, because the access step must be
                                                                          

                                                                          
done after the <em>newvalue-form</em> evaluation. Nevertheless, the evaluations
required for binding the temporaries are done before the evaluation of the
<em>newvalue-form</em>, thereby preserving the required left-to-right evaluation
order.
<!--l. 1326--><p class="indent" >   The treatment of <b><a 
href="symbols.html#x200-396623r623">mask-ﬁeld</a></b> is similar to that of <b><a 
href="symbols.html#x200-396523r523">ldb</a></b>.
<!--l. 1328--><p class="indent" >   In a form such as: <div class="lisp"><tt><div class="tabbing">
(setf (getf <em>place-form</em> <em>ind-form</em>) <em>newvalue-form</em>)
   <br>
<!--l. 1331--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1332--><p class="indent" >   the place referred to by the <em>place-form</em> must always be both accessed and
updated; note that the update is to the generalized variable speciﬁed by
<em>place-form</em>, not necessarily to the particular list which is the property list in
question.
<!--l. 1337--><p class="indent" >   Thus this call to <b><a 
href="symbols.html#x200-396845r845">setf</a></b> should generate code to do the following:
      <ul class="itemize1">
      <li class="itemize">Bind the temporaries for <em>place-form</em>
      </li>
      <li class="itemize">Evaluate <em>ind-form</em> and bind into a temporary
      </li>
      <li class="itemize">Evaluate the <em>newvalue-form</em> and bind into the store variable
      </li>
      <li class="itemize">Do the access to <em>place-form</em>
      </li>
      <li class="itemize">Do the store into <em>place-form</em> with a possibly new property list obtained
      by combining the results of the evaluations and the access</li></ul>
<!--l. 1347--><p class="indent" >   If the evaluation of <em>newvalue-form</em> alters what is found in the given
<em>place</em>—such as setting a diﬀerent named property in the list—then the change of
the property denoted by <em>ind-form</em> will be to that altered list, because the access
                                                                          

                                                                          
step is done after the <em>newvalue-form</em> evaluation. Nevertheless, the evaluations
required for binding the temporaries are done before the evaluation of the
<em>newvalue-form</em>, thereby preserving the required left-to-right evaluation
order.
<!--l. 1356--><p class="indent" >   Note that the phrase “possibly new property list” treats the implementation of
property lists as a “black box”; it can mean that the former property list is
somehow destructively re-used, or it can mean partial or full copying of it. A side
eﬀect may or may not occur; therefore <b><a 
href="symbols.html#x200-396845r845">setf</a></b> must proceed as if the resultant
property list were a diﬀerent copy needing to be stored back into the generalized
variable.
</div>
<!--l. 1365--><p class="indent" >   The Common Lisp facilities provided to deal with these semantic issues
include:
      <ul class="itemize1">
      <li class="itemize">Built-in macros such as <b><a 
href="symbols.html#x200-396845r845">setf</a></b> and <b><a 
href="symbols.html#x200-396767r767">push</a></b> that follow the semantic rules.
      </li>
      <li class="itemize">The     <b><a 
href="symbols.html#x200-396317r317">deﬁne-modify-macro</a></b>     macro,     which     allows     new
      generalized-variable manipulating macros (of a certain restricted kind)
      to be deﬁned easily. It takes care of the semantic rules automatically.
      </li>
      <li class="itemize">The  <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> macro,  which  allows  new  types  of  generalized-variable
      references  to  be  deﬁned  easily.  It  takes  care  of  the  semantic  rules
      automatically.
      </li>
      <li class="itemize">The <b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b> macro and the <b><a 
href="symbols.html#x200-396470r470">get-setf-method</a></b> function,
      which provide access to the internal mechanisms when it is necessary
      to deﬁne a complicated new type of generalized-variable reference or
      generalized-variable-manipulating macro.</li></ul>
<div class="newer">
<!--l. 1387--><p class="indent" >   Also important are the changes that allow lexical environments to be used in
appropriate ways in <b><a 
href="symbols.html#x200-396845r845">setf</a></b> methods.
</div>
<div class="defmac">
<div class="defmacheader">
                                                                          

                                                                          
<!--l. 1392--><p class="indent" >   <div class="tabbing">
 <em>[Macro]</em> <b>deﬁne-modify-macro</b> <a 
 id="dx48-78016"></a>name lambda-list function [doc-string]
   <br>
<!--l. 1393--><p class="noindent" ></div>
</div>
<!--l. 1394--><p class="indent" >   This macro deﬁnes a read-modify-write macro named <em>name</em>. An example of
such a macro is <b><a 
href="symbols.html#x200-396494r494">incf</a></b>. The ﬁrst subform of the macro will be a generalized-variable
reference. The <em>function</em> is literally the function to apply to the old contents of the
generalized-variable to get the new contents; it is not evaluated. <em>lambda-list</em>
describes the remaining arguments for the <em>function</em>; these arguments come
from the remaining subforms of the macro after the generalized-variable
reference. <em>lambda-list</em> may contain <b>&#x0026;optional</b> and <b>&#x0026;rest</b> markers. (The
<b>&#x0026;key</b> marker is not permitted here; <b>&#x0026;rest</b> suﬃces for the purposes of
<b><a 
href="symbols.html#x200-396317r317">deﬁne-modify-macro</a></b>.) <em>doc-string</em> is documentation for the macro <em>name</em> being
deﬁned.
<!--l. 1407--><p class="indent" >   The expansion of a <b><a 
href="symbols.html#x200-396317r317">deﬁne-modify-macro</a></b> is equivalent to the following,
except that it generates code that follows the semantic rules outlined above.
<div class="lisp"><tt><div class="tabbing">
(defmacro <em>name</em> (<em>reference</em> . <em>lambda-list</em>)
   <br>                              <em>doc-string</em><br>                            ‘(setf ,<em>reference</em><br>
         (<em>function</em> ,<em>reference</em> ,<em>arg1</em> ,<em>arg2</em> ...)))<br>
<!--l. 1414--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1415--><p class="indent" >   where <em>arg1</em>, <em>arg2</em>, ..., are the parameters appearing in <em>lambda-list</em>; appropriate
provision is made for a <b>&#x0026;rest</b> parameter.
<!--l. 1418--><p class="indent" >   As an example, <b><a 
href="symbols.html#x200-396494r494">incf</a></b> could have been deﬁned by: <div class="lisp"><tt><div class="tabbing">
(deﬁne-modify-macro incf (&#x0026;optional (delta 1)) +)
   <br>
                                                                          

                                                                          
<!--l. 1421--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1423--><p class="indent" >   An example of a possibly useful macro not predeﬁned in Common Lisp is
<div class="lisp"><tt><div class="tabbing">
(deﬁne-modify-macro unionf (other-set &#x0026;rest keywords) union)
   <br>
<!--l. 1426--><p class="noindent" ></div>
</tt>
</div>
<div class="newer">
<!--l. 1429--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-78017"></a>to specify that <b><a 
href="symbols.html#x200-396317r317">deﬁne-modify-macro</a></b> creates
macros that take <b>&#x0026;environment</b> arguments and perform the equivalent of
correctly passing such lexical environments to <b><a 
href="symbols.html#x200-396470r470">get-setf-method</a></b> in order to
correctly maintain lexical references.
</div>
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1439--><p class="indent" >   <div class="tabbing">
 <em>[Macro]</em> <b>defsetf</b> <a 
 id="dx48-78018"></a>access-fn {update-fn [doc-string] | lambda-list (store-variable) [[{declaration}* | doc-string]] {form}*}
   <br>
<!--l. 1440--><p class="noindent" ></div>
</div>
<!--l. 1441--><p class="indent" >   This deﬁnes how to <b><a 
href="symbols.html#x200-396845r845">setf</a></b> a generalized-variable reference of the form
<b>(<em>access-fn</em> ...)</b>. The value of a generalized-variable reference can always be
obtained simply by evaluating it, so <em>access-fn</em> should be the name of a function or
a macro.
<!--l. 1446--><p class="indent" >   The user of <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> provides a description of how to store into the
generalized-variable reference and return the value that was stored (because <b><a 
href="symbols.html#x200-396845r845">setf</a></b>
is deﬁned to return this value). The implementation of <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> takes care of
ensuring that subforms of the reference are evaluated exactly once and
                                                                          

                                                                          
in the proper left-to-right order. In order to do this, <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> requires
that <em>access-fn</em> be a function or a macro that evaluates its arguments,
behaving like a function. Furthermore, a <b><a 
href="symbols.html#x200-396845r845">setf</a></b> of a call on <em>access-fn</em> will also
evaluate all of <em>access-fn</em>&#x2019;s arguments; it cannot treat any of them specially.
This means that <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> cannot be used to describe how to store into a
generalized variable that is a byte, such as <b>(ldb ﬁeld reference)</b>. To
handle situations that do not ﬁt the restrictions imposed by <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b>, use
<b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b>, which gives the user additional control at the cost of
increased complexity.
<!--l. 1462--><p class="indent" >   A <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> declaration may take one of two forms. The simple form is
<div class="lisp"><tt><div class="tabbing">
(defsetf <em>access-fn</em> <em>update-fn</em> [<i><em>doc-string</em></i>] )
   <br>
<!--l. 1466--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1467--><p class="indent" >   The <em>update-fn</em> must name a function (or macro) that takes one more argument
than <em>access-fn</em> takes. When <b><a 
href="symbols.html#x200-396845r845">setf</a></b> is given a <em>place</em> that is a call on <em>access-fn</em>, it
expands into a call on <em>update-fn</em> that is given all the arguments to <em>access-fn</em> and
also, as its last argument, the new value (which must be returned by <em>update-fn</em> as
its value). For example, the eﬀect of <div class="lisp"><tt><div class="tabbing">
(defsetf symbol-value set)
   <br>
<!--l. 1476--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1477--><p class="indent" >   is built into the Common Lisp system. This causes the expansion
<div class="lisp"><tt><div class="tabbing">
(setf (symbol-value foo) fu) <span class="math"> →</span> (set foo fu)
   <br>
                                                                          

                                                                          
<!--l. 1481--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1482--><p class="indent" >   for example. Note that <div class="lisp"><tt><div class="tabbing">
(defsetf car rplaca)
   <br>
<!--l. 1485--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1486--><p class="indent" >   would be incorrect because <b><a 
href="symbols.html#x200-396825r825">rplaca</a></b> does not return its last argument.
<!--l. 1488--><p class="indent" >   The complex form of <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> looks like <div class="lisp"><tt><div class="tabbing">
(defsetf <em>access-fn</em> <em>lambda-list</em> (<em>store-variable</em>) . <em>body</em>)
   <br>
<!--l. 1491--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1492--><p class="indent" >   and resembles <b><a 
href="symbols.html#x200-396320r320">defmacro</a></b>. The <em>body</em> must compute the expansion of a <b><a 
href="symbols.html#x200-396845r845">setf</a></b> of a
call on <em>access-fn</em>.
<!--l. 1495--><p class="indent" >   The <em>lambda-list</em> describes the arguments of <em>access-fn</em>. <b>&#x0026;optional</b>, <b>&#x0026;rest</b>, and
<b>&#x0026;key</b> markers are permitted in <em>lambda-list</em>. Optional arguments may have
defaults and “supplied-p” ﬂags. The <em>store-variable</em> describes the value to be stored
into the generalized-variable reference.
_____________________________________<div class="rationale">
<!--l. 1502--><p class="noindent" ><b>Rationale:</b> The <em>store-variable</em> is enclosed in parentheses to provide for an extension to
multiple store variables that would receive multiple values from the second subform of
<b><a 
href="symbols.html#x200-396845r845">setf</a></b>. The rules given below for coding <b><a 
href="symbols.html#x200-396845r845">setf</a></b> methods discuss the proper handling of
multiple store variables to allow for the possibility that this extension may be
incorporated into Common Lisp in the future.
</div>___________________________________________________________________________________________________________
                                                                          

                                                                          
<!--l. 1514--><p class="indent" >   The <em>body</em> forms can be written as if the variables in the <em>lambda-list</em> were
bound to subforms of the call on <em>access-fn</em> and the <em>store-variable</em> were bound to
the second subform of <b><a 
href="symbols.html#x200-396845r845">setf</a></b>. However, this is not actually the case. During the
evaluation of the <em>body</em> forms, these variables are bound to names of temporary
variables, generated as if by <b><a 
href="symbols.html#x200-396460r460">gensym</a></b> or <b><a 
href="symbols.html#x200-396461r461">gentemp</a></b>, that will be bound by the
expansion of <b><a 
href="symbols.html#x200-396845r845">setf</a></b> to the values of those subforms. This binding permits the
<em>body</em> forms to be written without regard for order-of-evaluation issues.
<b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> arranges for the temporary variables to be optimized out of the
ﬁnal result in cases where that is possible. In other words, an attempt
is made by <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> to generate the best code possible in a particular
implementation.
<!--l. 1529--><p class="indent" >   Note that the code generated by the <em>body</em> forms must include provision for
returning the correct value (the value of <em>store-variable</em>). This is handled by the
<em>body</em> forms rather than by <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> because in many cases this value can be
returned at no extra cost, by calling a function that simultaneously stores into the
generalized variable and returns the correct value.
<!--l. 1536--><p class="indent" >   An example of the use of the complex form of <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b>: <div class="lisp"><tt><div class="tabbing">
(defsetf subseq (sequence start &#x0026;optional end) (new-sequence)
   <br>                                        ‘(progn (replace ,sequence ,new-sequence<br>
                   :start1 ,start :end1 ,end)<br>           ,new-sequence))<br>
<!--l. 1542--><p class="noindent" ></div>
</tt>
</div>
<div class="newer">
<!--l. 1545--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-78019"></a>to specify that the body of the expander function
deﬁned by the complex form of <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> is implicitly enclosed in a <b><a 
href="symbols.html#x200-396148r148">block</a></b> construct
whose name is the same as the <em>name</em> of the <em>access-fn</em>. Therefore <b><a 
href="symbols.html#x200-396818r818">return-from</a></b>
may be used to exit from the function.
</div>
<div class="newer">
<!--l. 1553--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-78020"></a>to clarify that, while deﬁning forms normally
appear at top level, it is meaningful to place them in non-top-level contexts; the
complex form of <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> must deﬁne the expander function within the enclosing
lexical environment, not within the global environment.
</div>
                                                                          

                                                                          
<hr></div>
<!--l. 1562--><p class="indent" >   The underlying theory by which <b><a 
href="symbols.html#x200-396845r845">setf</a></b> and related macros arrange to conform
to the semantic rules given above is that from any generalized-variable reference
one may derive its “<b><a 
href="symbols.html#x200-396845r845">setf</a></b> method,” which describes how to store into that reference
and which subforms of it are evaluated.
<!--l. 1568--><p class="indent" >   Given knowledge of the subforms of the reference, it is possible to avoid
evaluating them multiple times or in the wrong order. A <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method for a given
access form can be expressed as ﬁve values:
      <ul class="itemize1">
      <li class="itemize">A list of <em>temporary variables</em>
      </li>
      <li class="itemize">A list of <em>value forms</em> (subforms of the given form) to whose values the
      temporary variables are to be bound
      </li>
      <li class="itemize">A second list of temporary variables, called <em>store variables</em>
      </li>
      <li class="itemize">A <em>storing form</em>
      </li>
      <li class="itemize">An <em>accessing form</em></li></ul>
<!--l. 1590--><p class="indent" >   The temporary variables will be bound to the values of the value forms as if by
<b><a 
href="symbols.html#x200-396544r544">let*</a></b>; that is, the value forms will be evaluated in the order given and
may refer to the values of earlier value forms by using the corresponding
variables.
<!--l. 1596--><p class="indent" >   The store variables are to be bound to the values of the <em>newvalue</em> form,
that is, the values to be stored into the generalized variable. In almost
all cases only a single value is to be stored, and there is only one store
variable.
<!--l. 1601--><p class="indent" >   The storing form and the accessing form may contain references to the
temporary variables (and also, in the case of the storing form, to the store
variables). The accessing form returns the value of the generalized variable. The
storing form modiﬁes the value of the generalized variable and guarantees to
return the values of the store variables as its values; these are the correct
values for <b><a 
href="symbols.html#x200-396845r845">setf</a></b> to return. (Again, in most cases there is a single store
variable and thus a single value to be returned.) The value returned by the
                                                                          

                                                                          
accessing form is, of course, aﬀected by execution of the storing form, but
either of these forms may be evaluated any number of times and therefore
should be free of side eﬀects (other than the storing action of the storing
form).
<!--l. 1615--><p class="indent" >   The temporary variables and the store variables are generated names, as if by
<b><a 
href="symbols.html#x200-396460r460">gensym</a></b> or <b><a 
href="symbols.html#x200-396461r461">gentemp</a></b>, so that there is never any problem of name clashes among
them, or between them and other variables in the program. This is necessary to
make the special operators that do more than one <b><a 
href="symbols.html#x200-396845r845">setf</a></b> in parallel work properly;
these are <b><a 
href="symbols.html#x200-396765r765">psetf</a></b>, <b><a 
href="symbols.html#x200-396851r851">shiftf</a></b>, and <b><a 
href="symbols.html#x200-396822r822">rotatef</a></b>. Computation of the <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method must
always create new variable names; it may not return the same ones every
time.
<!--l. 1624--><p class="indent" >   Some examples of <b><a 
href="symbols.html#x200-396845r845">setf</a></b> methods for particular forms:
      <ul class="itemize1">
      <li class="itemize">For a variable <b>x</b>: <div class="lisp"><tt><div class="tabbing">
      ()
      <br>                                                                                          ()<br>
           (g0001)<br>                                          (setq x g0001)<br>
           x<br>
      <!--l. 1634--><p class="noindent" ></div>
</tt>
</div>
      </li>
      <li class="itemize">For <b>(car <em>exp</em>)</b>: <div class="lisp"><tt><div class="tabbing">
      (g0002)
      <br>                                                                                     (<em>exp</em>)<br>
           (g0003)<br>                     (progn (rplaca g0002 g0003) g0003)<br>
           (car g0002)<br>
                                                                          

                                                                          
      <!--l. 1644--><p class="noindent" ></div>
</tt>
</div>
      </li>
      <li class="itemize">For <b>(subseq <em>seq</em> <em>s</em> <em>e</em>)</b>: <div class="lisp"><tt><div class="tabbing">
      (g0004 g0005 g0006)
      <br>                                   (<em>seq</em> <em>s</em> <em>e</em>)<br>                                   (g0007)<br>
           (progn (replace g0004 g0007 :start1 g0005 :end1 g0006)<br>
                  g0007)<br>                     (subseq g0004 g0005 g0006)<br>
      <!--l. 1655--><p class="noindent" ></div>
</tt>
</div>
      </li></ul>
<div class="defmac">
<div class="defmacheader">
<!--l. 1659--><p class="indent" >   <div class="tabbing">
 <em>[Macro]</em> <b>deﬁne-setf-method</b> <a 
 id="dx48-78021"></a>access-fn lambda-list [[{declaration}* | doc-string]] {form}*
   <br>
<!--l. 1660--><p class="noindent" ></div>
</div>
<!--l. 1661--><p class="indent" >   This deﬁnes how to <b><a 
href="symbols.html#x200-396845r845">setf</a></b> a generalized-variable reference that is of the form
<b>(<em>access-fn</em>...)</b>. The value of a generalized-variable reference can always be
obtained simply by evaluating it, so <em>access-fn</em> should be the name of a function or
a macro.
<!--l. 1667--><p class="indent" >   The <em>lambda-list</em> describes the subforms of the generalized-variable reference, as
with <b><a 
href="symbols.html#x200-396320r320">defmacro</a></b>. The result of evaluating the <em>forms</em> in the body must be
ﬁve values representing the <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method, as described above. Note that
<b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b> diﬀers from the complex form of <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b> in that while the
body is being executed the variables in <em>lambda-list</em> are bound to parts of
                                                                          

                                                                          
the generalized-variable reference, not to temporary variables that will
be bound to the values of such parts. In addition, <b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b>
does not have <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b>&#x2019;s restriction that <em>access-fn</em> must be a function or a
function-like macro; an arbitrary <b><a 
href="symbols.html#x200-396320r320">defmacro</a></b> destructuring pattern is permitted in
<em>lambda-list</em>.
<!--l. 1680--><p class="indent" >   By deﬁnition there are no good small examples of <b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b>
because the easy cases can all be handled by <b><a 
href="symbols.html#x200-396324r324">defsetf</a></b>. A typical use is to deﬁne
the <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method for <b><a 
href="symbols.html#x200-396523r523">ldb</a></b>: <div class="obsolete"> <div class="lisp"><tt><div class="tabbing">
;;; SETF method for the form (LDB bytespec int).
   <br>                ;;; Recall that the int form must itself be suitable for SETF.<br>
(deﬁne-setf-method ldb (bytespec int)<br>  (multiple-value-bind (temps vals stores<br>
                        store-form access-form)<br>
      (get-setf-method int)         ;Get SETF method for int<br>
    (let ((btemp (gensym))          ;Temp var for byte speciﬁer<br>
          (store (gensym))          ;Temp var for byte to store<br>
          (stemp (ﬁrst stores)))   ;Temp var for int to store<br>
      ;; Return the SETF method for LDB as ﬁve values.<br>
      (values (cons btemp temps)    ;Temporary variables<br>
              (cons bytespec vals)  ;Value forms<br>
              (list store)          ;Store variables<br>
              ‘(let ((,stemp (dpb ,store ,btemp ,access-form)))<br>
                 ,store-form<br>                 ,store)                     ;Storing form<br>
              ‘(ldb ,btemp ,access-form)     ;Accessing form<br>
              ))))<br>
<!--l. 1703--><p class="noindent" ></div>
</tt>
</div>
</div>
<div class="newer">
<!--l. 1707--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-78022"></a>to specify that the <b>&#x0026;environment</b> lambda-list
keyword may appear in the <em>lambda-list</em> in the same manner as for <b><a 
href="symbols.html#x200-396320r320">defmacro</a></b> in
order to obtain the lexical environment of the call to the <b><a 
href="symbols.html#x200-396845r845">setf</a></b> macro. The
preceding example should be modiﬁed to take advantage of this new feature. The
<b><a 
href="symbols.html#x200-396845r845">setf</a></b> method must accept an <b>&#x0026;environment</b> parameter, which will receive the
lexical environment of the call to <b><a 
href="symbols.html#x200-396845r845">setf</a></b>; this environment must then be given to
                                                                          

                                                                          
<b><a 
href="symbols.html#x200-396470r470">get-setf-method</a></b> in order that it may correctly use any locally bound <b><a 
href="symbols.html#x200-396845r845">setf</a></b>
method that might be applicable to the <em>place</em> form that appears as the second
argument to <b><a 
href="symbols.html#x200-396523r523">ldb</a></b> in the call to <b><a 
href="symbols.html#x200-396845r845">setf</a></b>.
<div class="lisp">
<tt>
<!--l. 1719--><p class="indent" >   <div class="tabbing">
;;; SETF method for the form (LDB bytespec int).
   <br>                ;;; Recall that the int form must itself be suitable for SETF.<br>
;;; Note the use of an &#x0026;environment parameter to receive the<br>
;;; lexical environment of the call for use with GET-SETF-METHOD.<br>
(deﬁne-setf-method ldb (bytespec int &#x0026;environment env)<br>
  (multiple-value-bind (temps vals stores<br>                        store-form access-form)<br>
      (get-setf-method int env)     ;Get SETF method for int<br>
    (let ((btemp (gensym))          ;Temp var for byte speciﬁer<br>
          (store (gensym))          ;Temp var for byte to store<br>
          (stemp (ﬁrst stores)))   ;Temp var for int to store<br>
      ;; Return the SETF method for LDB as ﬁve values.<br>
      (values (cons btemp temps)    ;Temporary variables<br>
              (cons bytespec vals)  ;Value forms<br>
              (list store)          ;Store variables<br>
              ‘(let ((,stemp (dpb ,store ,btemp ,access-form)))<br>
                 ,store-form<br>                 ,store)                     ;Storing form<br>
              ‘(ldb ,btemp ,access-form)     ;Accessing form<br>
              ))))<br>
<!--l. 1740--><p class="noindent" ></div>
</tt>
</div>
</div>
<div class="newer">
<!--l. 1744--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-78023"></a>to specify that the body of the expander function
deﬁned by <b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b> is implicitly enclosed in a <b><a 
href="symbols.html#x200-396148r148">block</a></b> construct whose
name is the same as the <em>name</em> of the <em>access-fn</em>. Therefore <b><a 
href="symbols.html#x200-396818r818">return-from</a></b> may be
used to exit from the function.
</div>
<div class="newer">
                                                                          

                                                                          
<!--l. 1752--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-78024"></a>to clarify that, while deﬁning forms normally
appear at top level, it is meaningful to place them in non-top-level contexts;
<b><a 
href="symbols.html#x200-396318r318">deﬁne-setf-method</a></b> must deﬁne the expander function within the enclosing
lexical environment, not within the global environment.
</div>
<hr></div>
<div class="newer">
<!--l. 1762--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-78025"></a>to add an optional environment argument to
<b><a 
href="symbols.html#x200-396470r470">get-setf-method</a></b>. The revised deﬁnition and example are as follows.
<div class="defun">
<div class="defunheader">
<a 
 id="dx48-78026"></a>
<em>
<!--l. 1767--><p class="noindent" >[Function]</em> <b>get-setf-method</b> <i>form</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>env</i>
</div>
<b>
<!--l. 1769--><p class="indent" >   <a 
href="symbols.html#x200-396470r470">get-setf-method</a></b> returns ﬁve values constituting the <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method for <em>form</em>.
The <em>form</em> must be a generalized-variable reference. The <em>env</em> must be an
environment of the sort obtained through the <b>&#x0026;environment</b> lambda-list
keyword; if <em>env</em> is <b><a 
href="symbols.html#x200-396670r670">nil</a></b> or omitted, the null lexical environment is assumed.
<b><a 
href="symbols.html#x200-396470r470">get-setf-method</a></b> takes care of error checking and macro expansion and
guarantees to return exactly one store variable.
<!--l. 1780--><p class="indent" >   As an example, an extremely simpliﬁed version of <b><a 
href="symbols.html#x200-396845r845">setf</a></b>, allowing no more and
no fewer than two subforms, containing no optimization to remove unnecessary
variables, and not allowing storing of multiple values, could be deﬁned by:
<div class="lisp"><tt><div class="tabbing">
(defmacro setf (reference value &#x0026;environment env)
   <br>              (multiple-value-bind (vars vals stores store-form access-form)<br>
      (get-setf-method reference env)     ;Note use of environment<br>
    (declare (ignore access-form))<br>
    ‘(let* ,(mapcar #&#x2019;list<br>                         (append vars stores)<br>
                    (append vals (list value)))<br>           ,store-form)))<br>
<!--l. 1793--><p class="noindent" ></div>
                                                                          

                                                                          
</tt>
</div>
<hr>
</div>
</div>
<div class="newer">
<!--l. 1798--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-78027"></a>to add an optional environment argument to
<b><a 
href="symbols.html#x200-396470r470">get-setf-method</a></b>. The revised deﬁnition is as follows.
<div class="defun">
<div class="defunheader">
<a 
 id="dx48-78028"></a>
<em>
<!--l. 1803--><p class="noindent" >[Function]</em> <b>get-setf-method-multiple-value</b> <i>form</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>env</i>
</div>
<b>
<!--l. 1805--><p class="indent" >   <a 
href="symbols.html#x200-396471r471">get-setf-method-multiple-value</a></b> returns ﬁve values constituting the <b><a 
href="symbols.html#x200-396845r845">setf</a></b>
method for <em>form</em>. The <em>form</em> must be a generalized-variable reference. The <em>env</em>
must be an environment of the sort obtained through the <b>&#x0026;environment</b>
lambda-list keyword; if <em>env</em> is <b><a 
href="symbols.html#x200-396670r670">nil</a></b> or omitted, the null lexical environment is
assumed.
<!--l. 1813--><p class="indent" >   This is the same as <b><a 
href="symbols.html#x200-396470r470">get-setf-method</a></b> except that it does not check the
number of store variables; use this in cases that allow storing multiple values into
a generalized variable. There are no such cases in standard Common Lisp, but this
function is provided to allow for possible extensions.
<hr></div>
</div>
<div class="newer">
<!--l. 1823--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-78029"></a>to clarify that a <b><a 
href="symbols.html#x200-396845r845">setf</a></b> method for a functional
name is applicable only when the global binding of that name is lexically
visible. If such a name has a local binding introduced by <b><a 
href="symbols.html#x200-396425r425">ﬂet</a></b>, <b><a 
href="symbols.html#x200-396515r515">labels</a></b>, or
<b><a 
href="symbols.html#x200-396587r587">macrolet</a></b>, then global deﬁnitions of <b><a 
href="symbols.html#x200-396845r845">setf</a></b> methods for that name do not
apply and are not visible. All of the standard Common Lisp macros that
modify a <b><a 
href="symbols.html#x200-396845r845">setf</a></b> <em>place</em> (for example, <b><a 
href="symbols.html#x200-396494r494">incf</a></b>, <b><a 
href="symbols.html#x200-396304r304">decf</a></b>, <b><a 
href="symbols.html#x200-396731r731">pop</a></b>, and <b><a 
href="symbols.html#x200-396822r822">rotatef</a></b>) obey this
convention.
</div>
                                                                          

                                                                          
<!--l. 1833--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse37.html" >Next</a>&#x003E;&#x003C;<a 
href="clmse35.html" >Prev</a>&#x003E;&#x003C;<a 
href="clmse35.html#tailclmse35.html" >PrevTail</a>&#x003E;&#x003C;<a 
href="clmse36.html" >Front</a>&#x003E;&#x003C;<a 
href="contrl.html#clmse36.html" >Up</a>&#x003E;<br>&lt;<a href="../index.html">Main Page</a>&gt; &lt;<a href="symbols.html">Symbols</a>&gt; </div><a 
 id="tailclmse36.html"></a>  
</body></html> 
