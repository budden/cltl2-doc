<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Concepts</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2013-01-10 13:48:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Main Page</a>&gt; &lt;<a href="symbols.html">Symbols</a>&gt; <br> &#x003C;<a 
href="clmse151.html" >Next</a>&#x003E;&#x003C;<a 
href="amop.html" >Prev</a>&#x003E;&#x003C;<a 
href="amop.html#tailamop.html" >PrevTail</a>&#x003E;&#x003C;<a 
href="#tailclmse150.html">Tail</a>&#x003E;&#x003C;<a 
href="amop.html#clmse150.html" >Up</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">29.1   </span> <a 
href="clm.html#QQ2-184-382" id="x184-33900029.1">Concepts</a></h3>
<!--l. 16--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.1.1   </span> <a 
href="frontmatter.html#QQ2-184-383" id="x184-34000029.1.1">Introduction</a></h4>
<!--l. 17--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.1.2   </span> <a 
href="frontmatter.html#QQ2-184-384" id="x184-34100029.1.2">Введение</a></h4>
                                                                          

                                                                          
<!--l. 20--><p class="noindent" >The CLOS Speciﬁcation <a 
href="clos.html#x174-25100027">27<!--tex4ht:ref: CLOS --></a> describes the standard Programmer Interface
for the Common Lisp Object System (CLOS). This document extends
that speciﬁcation by deﬁning a metaobject protocol for CLOS—that is, a
description of CLOS itself as an extensible CLOS program. In this description,
the fundamental elements of CLOS programs (classes, slot deﬁnitions,
generic functions, methods, specializers and method combinations) are
represented by ﬁrst-class objects. The behavior of CLOS is provided by these
objects, or, more precisely, by methods specialized to the classes of these
objects.
<!--l. 29--><p class="indent" >   Because these objects represent pieces of CLOS programs, and because their
behavior provides the behavior of the CLOS language itself, they are considered
meta-level objects or metaobjects. The protocol followed by the metaobjects to
provide the behavior of CLOS is called the CLOS Metaobject Protocol
(MOP).
<!--l. 34--><p class="indent" >   CLOS спецификация <a 
href="clos.html#x174-25100027">27<!--tex4ht:ref: CLOS --></a> описывает API для Common Lisp&#x2019;овой
объектной системы. Данная глава дополняет эту спецификацию описанием
метаобъектного протокола для CLOS — то. В этом описании, базовые
элементы CLOS&#x2019;а (классы, определения слотов, обобщённые функции,
методы, специализаторы и комбинации методов) представлены в качестве
представлены как объекты первого класса. Поведение CLOS&#x2019;а регулируется
этими объектами, или, если быть точнее, методами, специализированным для
объектов этих классов.
<!--l. 42--><p class="indent" >   Так как эти объекты представляют части CLOS программы, и так как их
поведение задаёт поведение языка CLOS, они рассматриваются как объекты
метауровня или метаобъекты. Протокол определения методов для
метаобъектов называется Метаобъектным Протоколом CLOS (на английском
MOP).
<!--l. 47--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-34200029.1.2" id="x184-34200029.1.2">Metaobjects</a></h5>
<!--l. 49--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-34300029.1.2" id="x184-34300029.1.2">Метаобъекты</a></h5>
<!--l. 51--><p class="noindent" >For each kind of program element there is a corresponding basic metaobject class.
These are the classes: <b>class</b>, <b>slot-deﬁnition</b>, <b><a 
href="symbols.html#x188-380452r452">generic-function</a></b>, <b>method</b> and
                                                                          

                                                                          
<b>method-combination</b>. A metaobject class is a subclass of exactly one of these
classes. The results are undeﬁned if an attempt is made to deﬁne a class that is a
subclass of more than one basic metaobject class. A metaobject is an instance of a
metaobject class.
<!--l. 59--><p class="indent" >   Для каждого элемента CLOS программы существует соответствующий
базовый метаобъектный класс. Все классы: <b>class</b>, <b>slot-deﬁnition</b>,
<b><a 
href="symbols.html#x188-380452r452">generic-function</a></b>, <b>method</b> и <b>method-combination</b>. Метаобъектный
класс является подклассом только одного из вышеперечисленных. При
попытке определить класс, которые наследует более одного базового
метакласса поведение непресказуемо. Метаобъект является экземпляром
метакласса.
<!--l. 67--><p class="indent" >   Each metaobject represents one program element. Associated with each
metaobject is the information required to serve its role. This includes information
that might be provided directly in a user interface macro such as <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> or
<b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>. It also includes information computed indirectly from other
metaobjects such as that computed from class inheritance or the full set of
methods associated with a generic function.
<!--l. 74--><p class="indent" >   Каждый метаобъект представляет один элемент CLOS программы. С
каждым метаобъектом связана информация, которая необходима для
выполнения им своей роли. Она включает информацию, которая может быть
предоставлена напрямую в пользовательский макрос, такой, например,
как <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> или <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>. Она также включает информацию,
вычисляемую ненапрямую от других метаобъектов, так, например,
вычисление информации из иерархии классов или полного множества
методов связанных с обобщённой функцией.
<!--l. 82--><p class="indent" >   Much of the information associated with a metaobject is in the form of
connections to other metaobjects. This interconnection means that the role of a
metaobject is always based on that of other metaobjects. As an introduction to
this interconnected structure, this section presents a partial enumeration of the
kinds of information associated with each kind of metaobject. More detailed
information is presented later.
<!--l. 89--><p class="indent" >   Много информации связанной с метаобъектом находится в виде виде
связи с другими метаобъектами. Такая взаимосвязь означает, что роль
метаобъекта всегда основана на других метаобъектах. В качестве
введения структуру данных взаимосвязей, данный раздел предоставляет
частичное перечисление типов информации связанной с каждым типов
метаобъектов. Более подробная информация будет предоставлена
позже.
                                                                          

                                                                          
<!--l. 95--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-34400029.1.2" id="x184-34400029.1.2">Classes</a></h5>
<!--l. 97--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-34500029.1.2" id="x184-34500029.1.2">Классы</a></h5>
<!--l. 99--><p class="noindent" >A <em>class metaobject</em> determines the structure and the default behavior of its
instances. The following information is associated with class metaobjects:
<em>
<!--l. 102--><p class="indent" >   Классовые метаобъекты</em> определяют структуру и поведение по-умолчанию
для их экземпляров. С классовыми метаобъектами связана следующая
информация:
      <ul class="itemize1">
      <li class="itemize">The name, if there is one, is available as an object.
      </li>
      <li class="itemize">Имя, если оно существует, доступно как объект.
      </li>
      <li class="itemize">The direct subclasses, direct superclasses and class precedence list are
      available as lists of class metaobjects.
      </li>
      <li class="itemize">Прямые                                                                  подклассы,
      прямые суперклассы и список предшествования классов доступны
      как списки классовых метаобъектов.
      </li>
      <li class="itemize">The slots deﬁned directly in the class are available as a list of direct slot
      deﬁnition metaobjects. The slots which are accessible in instances of
      the class are available as a list of eﬀective slot deﬁnition metaobjects.
      </li>
      <li class="itemize">Слоты   прямо   определённые   в   классе   доступны   как   список
      прямых   слотовых   метаобъектов.   Слоты,   которые   доступны
                                                                          

                                                                          
      в   экземплярах   класса   доступны   как   список   действительных
      слотовых метаобъектов. FIXME
      </li>
      <li class="itemize">The documentation is available as a string or <b><a 
href="symbols.html#x188-380670r670">nil</a></b>.
      </li>
      <li class="itemize">Документация доступна как строка или <b><a 
href="symbols.html#x188-380670r670">nil</a></b>.
      </li>
      <li class="itemize">The  methods  which  use  the  class  as  a  specializer,  and  the  generic
      functions associated with those methods are available as lists of method
      and generic function metaobjects respectively.
      </li>
      <li class="itemize">Методы,  которые  используют  класс  в  качестве  специализатора,
      и обобщённые функции, связанные с этими методами, доступны
      как   списки   методовых   или   функциональных   метаобъектов
      соответственно.</li></ul>
<!--l. 147--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-34600029.1.2" id="x184-34600029.1.2">Slot Deﬁnitions</a></h5>
<!--l. 149--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-34700029.1.2" id="x184-34700029.1.2">Определения слотов</a></h5>
<!--l. 151--><p class="noindent" >A <em>slot deﬁnition metaobject</em> contains information about the deﬁnition of a slot.
There are two kinds of slot deﬁnition metaobjects. A direct slot deﬁnition
metaobject is used to represent the direct deﬁnition of a slot in a class. This
corresponds roughly to the slot speciﬁers found in <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> forms. An eﬀective
slot deﬁnition metaobject is used to represent information, including inherited
information, about a slot which is accessible in instances of a particular
class.
<em>
<!--l. 159--><p class="indent" >   Слотовый метаобъект</em> содержит информацию об определении
слота. Существуют два вида этих метаобъектов. Прямой слотовой
метаобъект используется для представления определённых слотов
                                                                          

                                                                          
напрямую в классе. Он приблизительно отвечает за спецификаторы слотов,
указанные в формах <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>. Метаобъект действующего слота отображает
информацию, которая включает информацию об унаследованных свойствах
слота, о слотах, которые доступны в экземплярах отдельно взятого
класса.
<!--l. 167--><p class="indent" >   Associated with each class metaobject is a list of direct slot deﬁnition
metaobjects representing the slots deﬁned directly in the class. Also associated
with each class metaobject is a list of eﬀective slot deﬁnition metaobjects
representing the set of slots accessible in instances of that class.
<!--l. 173--><p class="indent" >   The following information is associated with both direct and eﬀective slot
deﬁnitions metaobjects:
      <ul class="itemize1">
      <li class="itemize">The name, allocation, and type are available as forms that could appear
      in a <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form.
      </li>
      <li class="itemize">The initialization form, if there is one, is available as a form that could
      appear in a <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form. The initialization form together with its
      lexical environment is available as a function of no arguments which,
      when called, returns the result of evaluating the initialization form in
      its lexical environment. This is called the <em>initfunction</em> of the slot.
      </li>
      <li class="itemize">The slot ﬁlling initialization arguments are available as a list of symbols.
      </li>
      <li class="itemize">The documentation is available as a string or <b><a 
href="symbols.html#x188-380670r670">nil</a></b>.
      </li></ul>
<!--l. 198--><p class="indent" >   Certain other information is only associated with direct slot deﬁnition
metaobjects. This information applies only to the direct deﬁnition of the slot in
the class (it is not inherited).
      <ul class="itemize1">
      <li class="itemize">The  function  names  of  those  generic  functions  for  which  there  are
      automatically generated reader and writer methods. This information
                                                                          

                                                                          
      is available as lists of function names. Any accessors speciﬁed in the
      <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form are broken down into their equivalent readers and writers
      in the direct slot deﬁnition.</li></ul>
<!--l. 213--><p class="indent" >   Information, including inherited information, which applies to the deﬁnition of
a slot in a particular class in which it is accessible is associated only with eﬀective
slot deﬁnition metaobjects.
      <ul class="itemize1">
      <li class="itemize">For certain slots, the location of the slot in instances of the class is
      available.</li></ul>
<!--l. 225--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-34800029.1.2" id="x184-34800029.1.2">Generic Functions</a></h5>
<!--l. 227--><p class="noindent" >A <em>generic function metaobject</em> contains information about a generic function over
and above the information associated with each of the generic function&#x2019;s
methods.
      <ul class="itemize1">
      <li class="itemize">The name is available as a function name.
      </li>
      <li class="itemize">The methods associated with the generic function are available as a list
      of method metaobjects.
      </li>
      <li class="itemize">The  default  class  for  this  generic  function&#x2019;s  method  metaobjects  is
      available as a class metaobject.
      </li>
      <li class="itemize">The lambda list is available as a list.
      </li>
      <li class="itemize">The  method  combination  is  available  as  a  method  combination
      metaobject.
                                                                          

                                                                          
      </li>
      <li class="itemize">The documentation is available as a string or <b><a 
href="symbols.html#x188-380670r670">nil</a></b>.
      </li>
      <li class="itemize">The argument precedence order is available as a permutation of those
      symbols from the lambda list which name the required arguments of
      the generic function.
      </li>
      <li class="itemize">The declarations are available as a list of declarations.
<b>
      <!--l. 261--><p class="noindent" >Terminology Note:</b> There is some ambiguity in Common Lisp about
      the terms used to identify the various parts of <b><a 
href="symbols.html#x188-380307r307">declare</a></b> special forms.
      In this document, the term <em>declaration</em> is used to refer to an object
      that could be an argument to a <b><a 
href="symbols.html#x188-380307r307">declare</a></b> special form. For example, in
      the special form <b>(declare (special *g1*))</b>, the list <b>(special *g1*)</b> is
      a declaration.</li></ul>
<!--l. 269--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-34900029.1.2" id="x184-34900029.1.2">Methods</a></h5>
<!--l. 271--><p class="noindent" >A <em>method metaobject</em> contains information about a speciﬁc method.
      <ul class="itemize1">
      <li class="itemize">The qualiﬁers are available as a list of of non-null atoms.
      </li>
      <li class="itemize">The lambda list is available as a list.
      </li>
      <li class="itemize">The specializers are available as a list of specializer metaobjects.
      </li>
      <li class="itemize">The function is available as a function. This function can be applied to
      arguments and a list of next methods using <em>apply</em> or <em>funcall</em>.
                                                                          

                                                                          
      </li>
      <li class="itemize">When the method is associated with a generic function, that generic
      function metaobject is available. A method can be associated with at
      most one generic function at a time.
      </li>
      <li class="itemize">The documentation is available as a string or <b><a 
href="symbols.html#x188-380670r670">nil</a></b>.</li></ul>
<!--l. 298--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-35000029.1.2" id="x184-35000029.1.2">Specializers</a></h5>
<!--l. 300--><p class="noindent" >A <em>specializer metaobject</em> represents the specializers of a method. Class
metaobjects are themselves specializer metaobjects. A special kind of specializer
metaobject is used for <em>eql</em> specializers.
<!--l. 304--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-35100029.1.2" id="x184-35100029.1.2">Method Combinations</a></h5>
<!--l. 306--><p class="noindent" >A <em>method combination metaobject</em> represents the information about the method
combination being used by a generic function.
<b>
<!--l. 309--><p class="indent" >   Note:</b> This document does not specify the structure of method combination
metaobjects.
<!--l. 312--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.1.3   </span> <a 
href="frontmatter.html#QQ2-184-395" id="x184-35200029.1.3">Inheritance Structure of Metaobject Classes</a></h4>
<!--l. 314--><p class="noindent" >The inheritance structure of the speciﬁed metaobject classes is shown in the
table <a 
href="#x184-3520011">29.1<!--tex4ht:ref: MOP-CLASSES --></a>.
   <div class="table">
                                                                          

                                                                          
<!--l. 317--><p class="indent" >   <a 
 id="x184-3520011"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 29.1: </span><span  
class="content">Direct superclass relationships among the speciﬁed metaobject
classes</span></div><!--tex4ht:label?: x184-3520011 -->
<div class="flushleft" 
>
<!--l. 320--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" ><b>Metaobject Class</b>              </td><td align="left" ><b>Direct Superclasses</b>                              </td>
</tr><tr><td align="left" >standard-object                      </td><td align="left" >(t)                                                            </td>
</tr><tr><td align="left" >funcallable-standard-object      </td><td align="left" >(standard-object function)                             </td>
</tr><tr><td align="left" >metaobject                            </td><td align="left" >(standard-object)                                         </td>
</tr><tr><td align="left" >generic-function                     </td><td align="left" >(metaobject funcallable-standard-object)          </td>
</tr><tr><td align="left" >standard-generic-function         </td><td align="left" >(generic-function)                                        </td>
</tr><tr><td align="left" >method                                </td><td align="left" >(metaobject)                                               </td>
</tr><tr><td align="left" >standard-method                    </td><td align="left" >(method)                                                   </td>
</tr><tr><td align="left" >standard-accessor-method        </td><td align="left" >(standard-method)                                       </td>
</tr><tr><td align="left" >standard-reader-method           </td><td align="left" >(standard-accessor-method)                           </td>
</tr><tr><td align="left" >standard-writer-method           </td><td align="left" >(standard-accessor-method)                           </td>
</tr><tr><td align="left" >method-combination               </td><td align="left" >(metaobject)                                               </td>
</tr><tr><td align="left" >slot-deﬁnition                        </td><td align="left" >(metaobject)                                               </td>
</tr><tr><td align="left" >direct-slot-deﬁnition                </td><td align="left" >(slot-deﬁnition)                                           </td>
</tr><tr><td align="left" >eﬀective-slot-deﬁnition             </td><td align="left" >(slot-deﬁnition)                                           </td>
</tr><tr><td align="left" >standard-slot-deﬁnition            </td><td align="left" >(slot-deﬁnition)                                           </td>
</tr><tr><td align="left" >standard-direct-slot-deﬁnition   </td><td align="left" >(standard-slot-deﬁnition direct-slot-deﬁnition)   </td>
</tr><tr><td align="left" >standard-eﬀective-slot-deﬁnition</td><td align="left" >(standard-slot-deﬁnition eﬀective-slot-deﬁnition)</td>
</tr><tr><td align="left" >specializer                             </td><td align="left" >(metaobject)                                               </td>
</tr><tr><td align="left" >eql-specializer                        </td><td align="left" >(specializer)                                                </td>
</tr><tr><td align="left" >class                                    </td><td align="left" >(specializer)                                                </td>
</tr><tr><td align="left" >built-in-class                         </td><td align="left" >(class)                                                       </td>
</tr><tr><td align="left" >forward-referenced-class           </td><td align="left" >(class)                                                       </td>
</tr><tr><td align="left" >standard-class                        </td><td align="left" >(class)                                                       </td>
</tr><tr><td align="left" >funcallable-standard-class        </td><td align="left" >(class)                                                       </td></tr></table>
</div></div>
<!--l. 352--><p class="noindent" >The class of every class shown is <b>standard-class</b> except for the class <b><a 
href="symbols.html#x188-380953r953">t</a></b> which is
an instance of the class <b>built-in-class</b> and the classes <b><a 
href="symbols.html#x188-380452r452">generic-function</a></b>
and <b>standard-generic-function</b> which are instances of the class
<b>funcallable-standard-class</b>.
<!--l. 359--><p class="noindent" >[Each class marked with a “*” is an abstract class and is not intended to be
instantiated. The results are undeﬁned if an attempt is made to make an instance
of one of these classes with <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>.]
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<!--l. 364--><p class="indent" >   The classes <b>standard-class</b>, <b>standard-direct-slot-deﬁnition</b>,
<b>standard-eﬀective-slot-deﬁnition</b>, <b>standard-method</b>, <b>standard-reader-method</b>,
<b>standard-writer-method</b> and <b>standard-generic-function</b> are called
<em>standard metaobject classes</em>. For each kind of metaobject, this is the class
the user interface macros presented in the CLOS Speciﬁcation use by
default. These are also the classes on which user specializations are normally
based.
<!--l. 373--><p class="indent" >   The classes <b>built-in-class</b>, <b>funcallable-standard-class</b> and
<b>forward-referenced-class</b> are special-purpose class metaobject classes.
Built-in classes are instances of the class <b>built-in-class</b>. The class
<b>funcallable-standard-class</b> provides a special kind of instances described in the
section <a 
href="#x184-36600029.1.5">29.1.5<!--tex4ht:ref: FUNCALLABLE-INSTANCES --></a>. When the deﬁnition of a class references another class which has
not yet been deﬁned, an instance of <b>forward-referenced-class</b> is used as a
stand-in until the class is actually deﬁned.
<!--l. 382--><p class="indent" >   The class <b>standard-object</b> is the <em>default direct superclass</em> of the class
<b>standard-class</b>. When an instance of the class <b>standard-class</b> is created,
and no direct superclasses are explicitly speciﬁed, it defaults to the class
<b>standard-object</b>. In this way, any behavior associated with the class
<b>standard-object</b> will be inherited, directly or indirectly, by all instances of the
class <b>standard-class</b>. A subclass of <b>standard-class</b> may have a diﬀerent class as
its default direct superclass, but that class must be a subclass of the class
<b>standard-object</b>.
<!--l. 394--><p class="indent" >   The same is true for <b>funcallable-standard-class</b> and <b>funcallable-standard-object</b>.
<!--l. 397--><p class="indent" >   The class <b>specializer</b> captures only the most basic behavior of method
specializers, and is not itself intended to be instantiated. The class <b>class</b> is a
direct subclass of <b>specializer</b> reﬂecting the property that classes by themselves
can be used as method specializers. The class <b>eql-specializer</b> is used for <b><a 
href="symbols.html#x188-380379r379">eql</a></b>
specializers.
   <h5 class="subsubsectionHead"><a 
href="#x184-35300029.1.3" id="x184-35300029.1.3">Implementation and User Specialization</a></h5>
<!--l. 406--><p class="noindent" >The purpose of the Metaobject Protocol is to provide users with a powerful
mechanism for extending and customizing the basic behavior of the Common Lisp
Object System. As an object-oriented description of the basic CLOS behavior, the
Metaobject Protocol makes it possible to create these extensions by deﬁning
                                                                          

                                                                          
specialized subclasses of existing metaobject classes.
<!--l. 412--><p class="indent" >   The Metaobject Protocol provides this capability without interfering with the
implementor&#x2019;s ability to develop high-performance implementations. This balance
between user extensibility and implementor freedom is mediated by placing
explicit restrictions on each. Some of these restrictions are general—they apply to
the entire class graph and the applicability of all methods. These are presented in
this section.
<!--l. 419--><p class="indent" >   The following additional terminology is used to present these restrictions:
      <ul class="itemize1">
      <li class="itemize">Metaobjects are divided into three categories. Those deﬁned in this
      document are called <em>speciﬁed</em>; those deﬁned by an implementation but
      not mentioned in this document are called <em>implementation-speciﬁc</em>; and
      those deﬁned by a portable program are called <em>portable</em>.
      </li>
      <li class="itemize">A class <span class="math">I</span> is <em>interposed</em> between two other classes <span class="math">C<sub>1</sub></span> and <span class="math">C<sub>2</sub></span> if and only
      if there is some path, following direct superclasses, from the class <span class="math">C<sub>1</sub></span>
      to the class <span class="math">C<sub>2</sub></span> which includes <span class="math">I</span>.
      </li>
      <li class="itemize">A method is <em>specialized</em> to a class if and only if that class is in the list
      of specializers associated with the method; and the method is in the
      list of methods associated with some generic function.
      </li>
      <li class="itemize">In a given implementation, a speciﬁed method is said to have been
      promoted  if  and  only  if  the  specializers  of  the  method,  <span class="math">S<sub>1</sub>…S<sub>n</sub></span>,
      are  deﬁned  in  this  speciﬁcation  as  the  classes  <span class="math">C<sub>1</sub>…C<sub>n</sub></span>,  but  in  the
      implementation, one or more of the specializers <span class="math">S<sub>i</sub></span>, is a superclass of
      the class given in the speciﬁcation <span class="math">C<sub>i</sub></span>.
      </li>
      <li class="itemize">For a given generic function and set of arguments, a method <span class="math">M<sub>2</sub></span> extends
      a method <span class="math">M<sub>1</sub></span> if and only if:
           <ul class="itemize2">
           <li class="itemize">(i) <span class="math">M<sub>1</sub></span> and <span class="math">M<sub>2</sub></span> are both associated with the given generic function,
                                                                          

                                                                          
           </li>
           <li class="itemize">(ii) <span class="math">M<sub>1</sub></span> and <span class="math">M<sub>2</sub></span> are both applicable to the given arguments,
           </li>
           <li class="itemize">(iii) the specializers and qualiﬁers of the methods are such that
           when the generic function is called, <span class="math">M<sub>2</sub></span> is executed before <span class="math">M<sub>1</sub></span>,
           </li>
           <li class="itemize">(iv)  <span class="math">M<sub>1</sub></span>  will  be  executed  if  and  only  if  <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> is
           invoked from within the body of <span class="math">M<sub>2</sub></span> and
           </li>
           <li class="itemize">(v)<b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> is invoked from within the body of <span class="math">M<sub>2</sub></span>,
           thereby causing <span class="math">M<sub>1</sub></span> to be executed.</li></ul>
      </li>
      <li class="itemize">For a given generic function and set of arguments, a method <span class="math">M<sub>2</sub></span>
      overrides a method <span class="math">M<sub>1</sub></span> if and only if conditions i through iv above hold
      and
           <ul class="itemize2">
           <li class="itemize">(v&#x2019;) <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> is not invoked from within the body of
           <span class="math">M<sub>2</sub></span>, thereby preventing <span class="math">M<sub>1</sub></span> from being executed.</li></ul>
      </li></ul>
<!--l. 475--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-35400029.1.3" id="x184-35400029.1.3">Restrictions on Implementations</a></h5>
<!--l. 477--><p class="noindent" >Implementations are allowed latitude to modify the structure of speciﬁed classes
and methods. This includes: the interposition of implementation-speciﬁc
classes; the promotion of speciﬁed methods; and the consolidation of two or
more speciﬁed methods into a single method specialized to interposed
classes.
<!--l. 482--><p class="indent" >   Any such modiﬁcations are permitted only so long as for any portable class Cp
that is a subclass of one or more speciﬁed classes <span class="math">C<sub>0</sub>…C<sub>i</sub></span>, the following conditions
are met:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">In the actual class precedence list of <span class="math">C<sub>p</sub></span>, the classes <span class="math">C<sub>0</sub>…C<sub>i</sub></span> must appear
      in the same order as they would have if no implementation-speciﬁc
      modiﬁcations had been made.
      </li>
      <li class="itemize">The  method  applicability  of  any  speciﬁed  generic  function  must
      be  the  same  in  terms  of  behavior  as  it  would  have  been  had  no
      implementation-speciﬁc  changes  been  made.  This  includes  speciﬁed
      generic  functions  that  have  had  portable  methods  added.  In  this
      context, the expression “the same in terms of behavior”  means that
      methods with the same behavior as those speciﬁed are applicable, and
      in the same order.
      </li>
      <li class="itemize">No  portable  class  <span class="math">C<sub>p</sub></span>  may  inherit,  by  virtue  of  being  a  direct  or
      indirect subclass of a speciﬁed class, any slot for which the name is a
      symbol accessible in the <b>common-lisp-user</b> package or exported by
      any package deﬁned in the ANSI Common Lisp standard.
      </li>
      <li class="itemize">Implementations are free to deﬁne implementation-speciﬁc before- and
      after-methods on speciﬁed generic functions. Implementations are also
      free to deﬁne implementation-speciﬁc around-methods with extending
      behavior.</li></ul>
<!--l. 511--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-35500029.1.3" id="x184-35500029.1.3">Restrictions on Portable Programs</a></h5>
<!--l. 513--><p class="noindent" >Portable programs are allowed to deﬁne subclasses of speciﬁed classes, and
are permitted to deﬁne methods on speciﬁed generic functions, with the
following restrictions. The results are undeﬁned if any of these restrictions is
violated.
      <ul class="itemize1">
      <li class="itemize">Portable  programs  must  not  redeﬁne  any  speciﬁed  classes,  generic
      functions, methods or method combinations. Any method deﬁned by
                                                                          

                                                                          
      a portable program on a speciﬁed generic function must have at least
      one specializer that is neither a speciﬁed class nor an <b><a 
href="symbols.html#x188-380379r379">eql</a></b> specializer
      whose associated value is an instance of a speciﬁed class.
      </li>
      <li class="itemize">Portable programs may deﬁne methods that extend speciﬁed methods
      unless the description of the speciﬁed method explicitly prohibits this.
      Unless there is a speciﬁc statement to the contrary, these extending
      methods  must  return  whatever  value  was  returned  by  the  call  to
      <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>.
      </li>
      <li class="itemize">Portable programs may deﬁne methods that override speciﬁed methods
      only when the description of the speciﬁed method explicitly allows this.
      Typically, when a method is allowed to be overridden, a small number
      of related methods will need to be overridden as well.
      </li>
      <li class="itemize">An example of this is the speciﬁed methods on the generic functions
      <b><a 
href="symbols.html#x188-380087r87">add-dependent</a></b>,                                         <b><a 
href="symbols.html#x188-380800r800">remove-dependent</a></b>
      and <b><a 
href="symbols.html#x188-380613r613">map-dependents</a></b>. Overriding a speciﬁed method on one of these
      generic functions requires that the corresponding method on the other
      two generic functions be overridden as well.
      </li>
      <li class="itemize">Portable methods on speciﬁed generic functions specialized to portable
      metaobject classes must be deﬁned before any instances of those classes
      (or any subclasses) are created, either directly or indirectly by a call
      to <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>. Methods can be deﬁned after instances are created
      by <b><a 
href="symbols.html#x188-380094r94">allocate-instance</a></b> however. Portable metaobject classes cannot be
      redeﬁned.
<b>
      <!--l. 550--><p class="noindent" >Implementation  Note:</b> The  purpose  of  this  last  restriction  is  to
      permit  implementations  to  provide  performance  optimizations  by
      analyzing,  at  the  time  the  ﬁrst  instance  of  a  metaobject  class  is
      initialized, what portable methods will be applicable to it. This can
      make it possible to optimize calls to those speciﬁed generic functions
      which would have no applicable portable methods.
<b>
                                                                          

                                                                          
      <!--l. 557--><p class="noindent" >Note:</b> The speciﬁcation technology used in this document needs further
      development. The concepts of object-oriented protocols and subclass
      specialization are intuitively familiar to programmers of object-oriented
      systems;  the  protocols  presented  here  ﬁt  quite  naturally  into  this
      framework. Nonetheless, in preparing this document, we have found it
      diﬃcult to give speciﬁcation-quality descriptions of the protocols in a
      way that makes it clear what extensions users can and cannot write.
      Object-oriented  protocol  speciﬁcation  is  inherently  about  specifying
      leeway, and this seems diﬃcult using current technology.</li></ul>
<!--l. 569--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.1.4   </span> <a 
href="frontmatter.html#QQ2-184-400" id="x184-35600029.1.4">Processing of the User Interface Macros</a></h4>
<!--l. 571--><p class="noindent" >A list in which the ﬁrst element is one of the symbols <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>, <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>,
<b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>, or <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>, and which has proper syntax for
that macro is called a <em>user interface macro form</em>. This document provides
an extended speciﬁcation of the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>, <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> and <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>
macros.
<!--l. 576--><p class="indent" >   The user interface macros <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>, <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> and <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> can be used
not only to deﬁne metaobjects that are instances of the corresponding standard
metaobject class, but also to deﬁne metaobjects that are instances of appropriate
portable metaobject classes. To make it possible for portable metaobject classes
to properly process the information appearing in the macro form, this
document provides a limited speciﬁcation of the processing of these macro
forms.
<!--l. 584--><p class="indent" >   User interface macro forms can be <em>evaluated</em> or <em>compiled</em> and later
<em>executed</em>. The eﬀect of evaluating or executing a user interface macro form is
speciﬁed in terms of calls to speciﬁed functions and generic functions which
provide the actual behavior of the macro. The arguments received by these
functions and generic functions are derived in a speciﬁed way from the macro
form.
<!--l. 591--><p class="indent" >   Converting a user interface macro form into the arguments to the appropriate
functions and generic functions has two major aspects: the conversion of the
macro argument syntax into a form more suitable for later processing, and the
processing of macro arguments which are forms to be evaluated (including method
bodies).
<!--l. 597--><p class="indent" >   In the syntax of the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> macro, the <em>initform</em> and <em>default-initarg-initial-value-form</em>
                                                                          

                                                                          
arguments are forms which will be evaluated one or more times after the
macro form is evaluated or executed. Special processing must be done on
these arguments to ensure that the lexical scope of the forms is captured
properly. This is done by building a function of zero arguments which,
when called, returns the result of evaluating the form in the proper lexical
environment.
<!--l. 605--><p class="indent" >   In the syntax of the <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> macro the <em>form*</em> argument is a list of forms
that comprise the body of the method deﬁnition. This list of forms must be
processed specially to capture the lexical scope of the macro form. In addition, the
lexical functions available only in the body of methods must be introduced. To
allow this and any other special processing (such as slot access optimization), a
specializable protocol is used for processing the body of methods. This is
discussed in the section <a 
href="#x184-36000029.1.4">29.1.4<!--tex4ht:ref: PROCESSING-METHOD-BODIES --></a>.
<!--l. 613--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-35700029.1.4" id="x184-35700029.1.4">Compile-ﬁle Processing of the User Interface Macros</a></h5>
<!--l. 615--><p class="noindent" >It is common practice for Common Lisp compilers, while processing a ﬁle or set of
ﬁles, to maintain information about the deﬁnitions that have been compiled so
far. Among other things, this makes it possible to ensure that a global macro
deﬁnition (<b><a 
href="symbols.html#x188-380320r320">defmacro</a></b> form) which appears in a ﬁle will aﬀect uses of the macro
later in that ﬁle. This information about the state of the compilation is called the
<em>compile-ﬁle environment</em>.
<!--l. 623--><p class="indent" >   When compiling ﬁles containing CLOS deﬁnitions, it is useful to maintain
certain additional information in the compile-ﬁle environment. This can make it
possible to issue various kinds of warnings (e.g., lambda list congruence) and
to do various performance optimizations that would not otherwise be
possible.
<!--l. 628--><p class="indent" >   At this time, there is such signiﬁcant variance in the way existing Common
Lisp implementations handle compile-ﬁle environments that it would be
premature to specify this mechanism. Consequently, this document speciﬁes only
the behavior of evaluating or executing user interface macro forms. What
functions and generic functions are called during compile-ﬁle processing of
a user interface macro form is not speciﬁed. Implementations are free
to deﬁne and document their own behavior. Users may need to check
implementation-speciﬁc behavior before attempting to compile certain portable
programs.
                                                                          

                                                                          
<!--l. 637--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-35800029.1.4" id="x184-35800029.1.4">The <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> Macro</a></h5>
<!--l. 639--><p class="noindent" >A <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form with standard slot and class options and an expansion of it that
would result in the proper call to <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>.
<div class="lisp">
<tt>
<!--l. 642--><p class="indent" >   <div class="tabbing">
(defclass plane (moving-object graphics-object)
   <br>                                ((altitude :initform 0 :accessor plane-altitude)<br>
      (speed))<br>                            (:default-initargs :engine *jet*))<br>
<br>                                                              (ensure-class<br>
  &#x2019;plane<br>                                              &#x2019;:direct-superclasses<br>
  &#x2019;(moving-object graphics-object)<br>   &#x2019;:direct-slots (list (list &#x2019;:name &#x2019;altitude<br>
                             &#x2019;:initform &#x2019;0<br>
                             &#x2019;:initfunction #&#x2019;(lambda () 0)<br>
                             &#x2019;:readers &#x2019;(plane-altitude)<br>
                             &#x2019;:writers &#x2019;((setf plane-altitude)))<br>
                       (list &#x2019;:name &#x2019;speed))<br>
  &#x2019;:direct-default-initargs (list (list &#x2019;:engine &#x2019;*jet*<br>
                                        #&#x2019;(lambda () *jet*))))<br>     <br>
<!--l. 660--><p class="noindent" ></div>
</tt>
</div>
<!--l. 662--><p class="indent" >   A <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form with non-standard class and slot options, and an expansion of
it which results in the proper call to <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>.
<!--l. 665--><p class="indent" >   Note that the order of the slot options has not aﬀected the order of the
properties in the canonicalized slot speciﬁcation, but has aﬀected the order of the
elements in the lists which are the values of those properties.
<div class="lisp">
<tt>
<!--l. 669--><p class="indent" >   <div class="tabbing">
                                                                          

                                                                          
(defclass sst (plane)
   <br>                ((mach mag-step 2<br>                       locator sst-mach<br>
            locator mach-location<br>                  :reader mach-speed<br>
            :reader mach))<br>                      (:metaclass faster-class)<br>
  (another-option foo bar))<br>                                               <br>
(ensure-class &#x2019;sst<br>                                      &#x2019;:direct-superclasses<br>
  &#x2019;(plane)<br>                             &#x2019;:direct-slots (list (list &#x2019;:name &#x2019;mach<br>
                             &#x2019;:readers &#x2019;(mach-speed mach)<br>
                             &#x2019;mag-step &#x2019;2<br>
                             &#x2019;locator &#x2019;(sst-mach mach-location)))<br>
  &#x2019;:metaclass &#x2019;faster-class<br>                       &#x2019;another-option &#x2019;(foo bar))<br>
<br>
<!--l. 688--><p class="noindent" ></div>
</tt>
</div>
<!--l. 690--><p class="indent" >   The evaluation or execution of a <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form results in a call to the
ensure-class function. The arguments received by <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b> are derived from
the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form in a deﬁned way. The exact macro-expansion of the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>
form is not deﬁned, only the relationship between the arguments to the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>
macro and the arguments received by the <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b> function. Examples of
typical <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> forms and sample expansions are shown in precedence
examples.
      <ul class="itemize1">
      <li class="itemize">The  <em>name</em>  argument  to  <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>  becomes  the  value  of  the  ﬁrst
      argument  to  <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>.  This  is  the  only  positional  argument
      accepted by <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>; all other arguments are keyword arguments.
      </li>
      <li class="itemize">The <em>direct-superclasses</em> argument to <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> becomes the value of the
      <b>:direct-superclasses</b> keyword argument to <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>.
      </li>
      <li class="itemize">The  <em>direct  slots</em>  argument  to  <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>  becomes  the  value  of  the
      :direct-slots keyword argument to <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>. Special processing of
                                                                          

                                                                          
      this value is done to regularize the form of each slot speciﬁcation and
      to properly capture the lexical scope of the initialization forms. This
      is done by converting each slot speciﬁcation to a property list called a
      <em>canonicalized slot speciﬁcation</em>. The resulting list of canonicalized slot
      speciﬁcations is the value of the <b>:direct-slots</b> keyword argument.
      <!--l. 715--><p class="noindent" >Canonicalized  slot  speciﬁcations  are  later  used  as  the  keyword
      arguments  to  a  generic  function  which  will,  in  turn,  pass  them  to
      <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b> for  use  as  a  set  of  initialization  arguments.  Each
      canonicalized slot speciﬁcation is formed from the corresponding slot
      speciﬁcation as follows:
           <ul class="itemize2">
           <li class="itemize">The name of the slot is the value of the <b>:name</b> property. This
           property appears in every canonicalized slot speciﬁcation.
           </li>
           <li class="itemize">When the <b>:initform</b> slot option is present in the slot speciﬁcation,
           then both the <b>:initform</b> and <b>:initfunction</b> properties are present
           in the canonicalized slot speciﬁcation. The value of the <b>:initform</b>
           property is the initialization form. The value of the <b>:initfunction</b>
           property  is  a  function  of  zero  arguments  which,  when  called,
           returns the result of evaluating the initialization form in its proper
           lexical environment.
           </li>
           <li class="itemize">If the <b>:initform</b> slot option is not present in the slot speciﬁcation,
           then either the <b>:initfunction</b> property will not appear, or its value
           will be false. In such cases, the value of the <b>:initform</b> property,
           or whether it appears, is unspeciﬁed.
           </li>
           <li class="itemize">The value of the <b>:initargs</b> property is a list of the values of each
           <b>:initarg</b> slot option. If there are no <b>:initarg</b> slot options, then
           either the <b>:initargs</b> property will not appear or its value will be
           the empty list.
           </li>
           <li class="itemize">The value of the <b>:readers</b> property is a list of the values of each
           <b>:reader</b> and <b>:accessor</b> slot option. If there are no <b>:reader</b> or
                                                                          

                                                                          
           <b>:accessor</b> slot options, then either the <b>:readers</b> property will not
           appear or its value will be the empty list.
           </li>
           <li class="itemize">The value of the <b>:writers</b> property is a list of the values speciﬁed
           by each <b>:writer</b> and <b>:accessor</b> slot option. The value speciﬁed by
           a <b>:writer</b> slot option is just the value of the slot option. The value
           speciﬁed by an <b>:accessor</b> slot option is a two element list: the
           ﬁrst element is the symbol setf, the second element is the value of
           the slot option. If there are no <b>:writer</b> or <b>:accessor</b> slot options,
           then either the <b>:writers</b> property will not appear or its value will
           be the empty list.
           </li>
           <li class="itemize">The value of the <b>:documentation</b> property is the value of the
           <b>:documentation</b> slot option. If there is no <b>:documentation</b> slot
           option, then either the <b>:documentation</b> property will not appear
           or its value will be false.
           </li>
           <li class="itemize">All other slot options appear as the values of properties with the
           same name as the slot option. Note that this includes not only the
           remaining standard slot options (<b>:allocation</b> and <b>:type</b>), but also
           any other options and values appearing in the slot speciﬁcation.
           If one of these slot options appears more than once, the value of
           the property will be a list of the speciﬁed values.
           </li>
           <li class="itemize">An  implementation  is  free  to  add  additional  properties  to  the
           canonicalized  slot  speciﬁcation  provided  these  are  not  symbols
           accessible in the common-lisp-user package, or exported by any
           package deﬁned in the ANSI Common Lisp standard.</li></ul>
      <!--l. 777--><p class="noindent" >Returning to the correspondence between arguments to the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> macro
      and the arguments received by the <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b> function:
      </li>
      <li class="itemize">The <em>default initargs</em> class option, if it is present in the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form,
      becomes the value of the <b>:direct-default-initargs</b> keyword argument to
      <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>. Special processing of this value is done to properly
      capture the lexical scope of the default value forms. This is done by
                                                                          

                                                                          
      converting each default initarg in the class option into a canonicalized
      default initarg. The resulting list of canonicalized default initargs is
      the value of the <b>:direct-default-initargs</b> keyword argument to
      <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>.
      <!--l. 789--><p class="noindent" >A canonicalized default initarg is a list of three elements. The ﬁrst
      element is the name; the second is the actual form itself; and the
      third is a function of zero arguments which, when called, returns
      the result of evaluating the default value form in its proper lexical
      environment.
      </li>
      <li class="itemize">The <em>metaclass</em> class option, if it is present in the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form, becomes
      the value of the <b>:metaclass</b> keyword argument to <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>.
      </li>
      <li class="itemize">The <em>documentation</em> class option, if it is present in the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form,
      becomes the value of the <b>:documentation</b> keyword argument to
      <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>.
      </li>
      <li class="itemize">Any other class options become the value of keyword arguments with the
      same name. The value of the keyword argument is the tail of the class
      option. An error is signaled if any class option appears more than once in
      the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form.</li></ul>
<!--l. 810--><p class="indent" >   In the call to <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>, every element of its arguments appears in the
same left-to-right order as the corresponding element of the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form, except
that the order of the properties of canonicalized slot speciﬁcations is unspeciﬁed.
The values of properties in canonicalized slot speciﬁcations do follow this ordering
requirement. Other ordering relationships in the keyword arguments to
<b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b> are unspeciﬁed.
<!--l. 817--><p class="indent" >   The result of the call to <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b> is returned as the result of evaluating or
executing the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> form.
<!--l. 820--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-35900029.1.4" id="x184-35900029.1.4">The <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> Macro</a></h5>
                                                                          

                                                                          
<!--l. 822--><p class="noindent" >The evaluation or execution of a <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> form requires ﬁrst that the body of
the method be converted to a method function. This process is described in the
next section. The result of this process is a method function and a set of
additional initialization arguments to be used when creating the new method.
Given these two values, the evaluation or execution of a <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> form
proceeds in three steps.
<!--l. 829--><p class="indent" >   The ﬁrst step ensures the existence of a generic function with the speciﬁed
name. This is done by calling the function ensure-generic-function. The ﬁrst
argument in this call is the generic function name speciﬁed in the <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>
form.
<!--l. 834--><p class="indent" >   The second step is the creation of the new method metaobject by calling
make-instance. The class of the new method metaobject is determined
by calling <b><a 
href="symbols.html#x188-380456r456">generic-function-method-class</a></b> on the result of the call to
<b><a 
href="symbols.html#x188-380376r376">ensure-generic-function</a></b> from the ﬁrst step.
<!--l. 839--><p class="indent" >   The initialization arguments received by the call to <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b> are as
follows:
      <ul class="itemize1">
      <li class="itemize">The  value  of  the  <b>:qualiﬁers</b>  initialization  argument  is  a  list  of
      the  qualiﬁers  which  appeared  in  the  <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> form.  No  special
      processing is done on these values. The order of the elements of this
      list is the same as in the <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> form.
      </li>
      <li class="itemize">The   value   of   the   <b>:lambda-list</b>  initialization   argument   is   the
      unspecialized lambda list from the <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> form.
      </li>
      <li class="itemize">The  value  of  the  <b>:specializers</b> initialization  argument  is  a  list  of
      the  specializers  for  the  method.  For  specializers  which  are  classes,
      the  specializer  is  the  class  metaobject  itself.  In  the  case  of  <b><a 
href="symbols.html#x188-380379r379">eql</a></b>
      specializers,  it  will  be  an  <b>eql-specializer</b> metaobject  obtained  by
      calling  <b><a 
href="symbols.html#x188-380505r505">intern-eql-specializer</a></b> on  the  result  of  evaluating  the  <b><a 
href="symbols.html#x188-380379r379">eql</a></b>
      specializer form in the lexical environment of the <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> form.
      </li>
      <li class="itemize">The  value  of  the  <b>:function</b> initialization  argument  is  the  method
      function.
                                                                          

                                                                          
      </li>
      <li class="itemize">The value of the <b>:declarations</b> initialization argument is a list of the
      declarations from the <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> form. If there are no declarations in
      the macro form, this initialization argument either doesn&#x2019;t appear, or
      appears with a value of the empty list.
      </li>
      <li class="itemize">The  value  of  the  <b>:documentation</b>  initialization  argument  is  the
      documentation  string  from  the  <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>  form.  If  there  is  no
      documentation string in the macro form this initialization argument
      either doesn&#x2019;t appear, or appears with a value of false.
      </li>
      <li class="itemize">Any other initialization argument produced in conjunction with the
      method function are also included.
      </li>
      <li class="itemize">The   implementation   is   free   to   include   additional   initialization
      arguments   provided   these   are   not   symbols   accessible   in   the
      <b>common-lisp-user</b> package, or exported by any package deﬁned in
      the ANSI Common Lisp standard.</li></ul>
<!--l. 882--><p class="indent" >   In the third step, <b><a 
href="symbols.html#x188-380090r90">add-method</a></b> is called to add the newly created method to
the set of methods associated with the generic function metaobject.
<!--l. 885--><p class="indent" >   The result of the call to <b><a 
href="symbols.html#x188-380090r90">add-method</a></b> is returned as the result of evaluating or
executing the <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> form.
<!--l. 888--><p class="indent" >   An example <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> form and one possible correct expansion. In the
expansion, method-lambda is the result of calling <b><a 
href="symbols.html#x188-380600r600">make-method-lambda</a></b> as
described in the section <a 
href="#x184-36000029.1.4">29.1.4<!--tex4ht:ref: PROCESSING-METHOD-BODIES --></a>. The initargs appearing after :function are assumed
to be additional initargs returned from the call to <b><a 
href="symbols.html#x188-380600r600">make-method-lambda</a></b>.
<!--l. 894--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x184-3590011"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Figure 29.1: </span><span  
class="content">Example 3</span></div><!--tex4ht:label?: x184-3590011 -->
<div class="lisp">
<tt>
<!--l. 897--><p class="noindent" ><div class="tabbing">
(defmethod move :before ((p position) (l (eql 0))
<br>                                                &#x0026;optional (visiblyp t)<br>
                         &#x0026;key color)<br>                 (set-to-origin p)<br>
  (when visiblyp (show-move p 0 color)))<br>                                 <br>
(let ((#:g001 (ensure-generic-function &#x2019;move)))<br>        (add-method #:g001<br>
    (make-instance (generic-function-method-class #:g001)<br>
                   &#x2019;:qualiﬁers &#x2019;(:before)<br>
                   &#x2019;:specializers (list (ﬁnd-class &#x2019;position)<br>
                                        (intern-eql-specializer 0))<br>
                   &#x2019;:lambda-list &#x2019;(p l &#x0026;optional (visiblyp t)<br>
                                       &#x0026;key color)<br>
                   &#x2019;:function (function  method-lambda)<br>
                   &#x2019;additional-initarg-1 &#x2019;t<br>
                   &#x2019;additional-initarg-2 &#x2019;39)))<br>                          <br>
<!--l. 915--><p class="noindent" ></div>
</tt>
</div>
                                                                          

                                                                          
<!--l. 916--><p class="indent" >   </div><hr class="endfigure">
<!--l. 918--><p class="indent" >   An example showing a typical <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> form and a sample expansion is
shown in <a 
href="#x184-3590011">29.1<!--tex4ht:ref: example-3 --></a>. The processing of the method body for this method is shown
in <a 
href="#x184-3600012">29.2<!--tex4ht:ref: example-4 --></a>.
   <h5 class="subsubsectionHead"><a 
href="#x184-36000029.1.4" id="x184-36000029.1.4">Processing Method Bodies</a></h5>
<!--l. 924--><p class="noindent" >Before a method can be created, the list of forms comprising the method body
must be converted to a method function. This conversion is a two step
process.
<b>
<!--l. 927--><p class="indent" >   Note:</b> The body of methods can also appear in the <b>:initial-methods</b> option
of <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> forms. Initial methods are not considered by any of the protocols
speciﬁed in this document.
<!--l. 931--><p class="indent" >   During macro-expansion of the <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> macro shown in <a 
href="#x184-3590011">29.1<!--tex4ht:ref: example-3 --></a>, code similar
to this would be run to produce the method lambda and additional initargs. In
this example, <em>environment</em> is the macroexpansion environment of the <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>
macro form.
<!--l. 936--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x184-3600012"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Figure 29.2: </span><span  
class="content">Example 4</span></div><!--tex4ht:label?: x184-3600012 -->
<div class="lisp">
<tt>
<!--l. 939--><p class="noindent" ><div class="tabbing">
(let ((gf (ensure-generic-function &#x2019;move)))
<br>                                                    (make-method-lambda<br>
    gf<br>                (class-prototype (generic-function-method-class gf))<br>
    &#x2019;(lambda (p l &#x0026;optional (visiblyp t) &#x0026;key color)<br>
       (set-to-origin p)<br>            (when visiblyp (show-move p 0 color)))<br>
   environment))<br>                                                         <br>
<!--l. 948--><p class="noindent" ></div>
</tt>
</div>
                                                                          

                                                                          
<!--l. 949--><p class="indent" >   </div><hr class="endfigure">
<!--l. 951--><p class="indent" >   The ﬁrst step occurs during macro-expansion of the macro form. In this step,
the method lambda list, declarations and body are converted to a lambda
expression called a <em>method lambda</em>. This conversion is based on information
associated with the generic function deﬁnition in eﬀect at the time the macro form
is expanded.
<!--l. 957--><p class="indent" >   The generic function deﬁnition is obtained by calling <b><a 
href="symbols.html#x188-380376r376">ensure-generic-function</a></b>
with a ﬁrst argument of the generic function name speciﬁed in the macro form.
The <b>:lambda-list</b> keyword argument is not passed in this call.
<!--l. 962--><p class="indent" >   Given the generic function, production of the method lambda proceeds by
calling make-method-lambda. The ﬁrst argument in this call is the generic
function obtained as described above. The second argument is the result of calling
<b><a 
href="symbols.html#x188-380247r247">class-prototype</a></b> on the result of calling <b><a 
href="symbols.html#x188-380456r456">generic-function-method-class</a></b> on the
generic function. The third argument is a lambda expression formed from the
method lambda list, declarations and body. The fourth argument is the
macro-expansion environment of the macro form; this is the value of the
<b>&#x0026;environment</b> argument to the <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> macro.
<!--l. 972--><p class="indent" >   The generic function <b><a 
href="symbols.html#x188-380600r600">make-method-lambda</a></b> returns two values. The ﬁrst is
the method lambda itself. The second is a list of initialization arguments and
values. These are included in the initialization arguments when the method is
created.
<!--l. 977--><p class="indent" >   In the second step, the method lambda is converted to a function which
properly captures the lexical scope of the macro form. This is done by
having the method lambda appear in the macro-expansion as the argument
of the function special form. During the subsequent evaluation of the
macro-expansion, the result of the function special form is the method
function.
   <h5 class="subsubsectionHead"><a 
href="#x184-36100029.1.4" id="x184-36100029.1.4">The <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> Macro</a></h5>
<!--l. 985--><p class="noindent" >The evaluation or execution of a <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> form results in a call to
the <b><a 
href="symbols.html#x188-380376r376">ensure-generic-function</a></b> function. The arguments received by
<b><a 
href="symbols.html#x188-380376r376">ensure-generic-function</a></b> are derived from the <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> form in a deﬁned
way. As with <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> and <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>, the exact macro-expansion of the
<b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> form is not deﬁned, only the relationship between the arguments to
the macro and the arguments received by <b><a 
href="symbols.html#x188-380376r376">ensure-generic-function</a></b>.
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">The  <em>function-name</em>  argument  to  <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>  becomes  the  ﬁrst
      argument  to  ensure-generic-function.  This  is  the  only  positional
      argument accepted by ensure-generic-function; all other arguments are
      keyword arguments.
      </li>
      <li class="itemize">The  <em>lambda-list</em> argument  to  <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> becomes  the  value  of  the
      :lambda-list keyword argument to ensure-generic-function.
      </li>
      <li class="itemize">For     each     of     the     options     <b>:argument-precedence-order</b>,
      <b>:documentation</b>, <b>:generic-function-class</b> and <b>:method-class</b>, the
      value  of  the  option  becomes  the  value  of  the  keyword  argument
      with  the  same  name.  If  the  option  does  not  appear  in  the  macro
      form, the keyword argument does not appear in the resulting call to
      ensure-generic-function.
      </li>
      <li class="itemize">For the option declare, the list of declarations becomes the value of
      the <b>:declarations</b> keyword argument. If the declare option does not
      appear in the macro form, the <b>:declarations</b> keyword argument does
      not appear in the call to ensure-generic-function.
      </li>
      <li class="itemize">The handling of the <b>:method-combination</b> option is not speciﬁed.</li></ul>
<!--l. 1017--><p class="indent" >   The result of the call to <b><a 
href="symbols.html#x188-380376r376">ensure-generic-function</a></b> is returned as the result of
evaluating or executing the <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> form.
<!--l. 1020--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.1.5   </span> <a 
href="frontmatter.html#QQ2-184-408" id="x184-36200029.1.5">Subprotocols</a></h4>
<!--l. 1022--><p class="noindent" >This section provides an overview of the Metaobject Protocols. The detailed
behavior of each function, generic function and macro in the Metaobject
Protocol is presented in the Generic Functions and Methods Dictionary. The
remainder of this chapter is intended to emphasize connections among
the parts of the Metaobject Protocol, and to provide some examples of
the kinds of specializations and extensions the protocols are designed to
                                                                          

                                                                          
support.
<!--l. 1029--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-36300029.1.5" id="x184-36300029.1.5">Metaobject Initialization Protocols</a></h5>
<!--l. 1031--><p class="noindent" >Like other objects, metaobjects can be created by calling <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>. The
initialization arguments passed to <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b> are used to initialize the
metaobject in the usual way. The set of legal initialization arguments, and their
interpretation, depends on the kind of metaobject being created. Implementations
and portable programs are free to extend the set of legal initialization arguments.
Detailed information about the initialization of each kind of metaobject are
provided in Generic Functions and Methods Dictionary; this section provides an
overview and examples of this behavior.
<b>
<!--l. 1040--><p class="indent" >   Initialization of Class Metaobjects</b>
<!--l. 1042--><p class="indent" >   Class metaobjects created with <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b> are usually <em>anonymous</em>; that
is, they have no proper name. An anonymous class metaobject can be given a
proper name using <b>setf ﬁnd-class</b> and <b>setf class-name</b>.
<!--l. 1046--><p class="indent" >   When a class metaobject is created with <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>, it is initialized in
the usual way. The initialization arguments passed to <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b> are use to
establish the deﬁnition of the class. Each initialization argument is checked
for errors and associated with the class metaobject. The initialization
arguments correspond roughly to the arguments accepted by the <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>
macro, and more closely to the arguments accepted by the <b><a 
href="symbols.html#x188-380373r373">ensure-class</a></b>
function.
<!--l. 1053--><p class="indent" >   Some class metaobject classes allow their instances to be redeﬁned. When
permissible, this is done by calling <b><a 
href="symbols.html#x188-380795r795">reinitialize-instance</a></b>. This is discussed in the
next section.
<!--l. 1057--><p class="indent" >   An example of creating an anonymous class directly using <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>
follows:
<div class="lisp">
<tt>
<!--l. 1059--><p class="indent" >   <div class="tabbing">
(ﬂet ((zero () 0)
                                                                          

                                                                          
   <br>           (propellor () *propellor*))<br>      (make-instance &#x2019;standard-class<br>
    :name &#x2019;(my-class foo)<br>       :direct-superclasses (list (ﬁnd-class &#x2019;plane)<br>
                              another-anonymous-class)<br>
    :direct-slots ‘((:name x<br>                                  :initform 0<br>
                     :initfunction ,#&#x2019;zero<br>
                     :initargs (:x)<br>
                     :readers (position-x)<br>
                     :writers ((setf position-x)))<br>
                    (:name y<br>                            :initform 0<br>
                     :initfunction ,#&#x2019;zero<br>
                     :initargs (:y)<br>
                     :readers (position-y)<br>
                     :writers ((setf position-y))))<br>
    :direct-default-initargs ‘((:engine *propellor* ,#&#x2019;propellor))))<br>          <br>
<!--l. 1079--><p class="noindent" ></div>
</tt>
</div>
<b>
<!--l. 1081--><p class="indent" >   Reinitialization of Class Metaobjects</b>
<!--l. 1083--><p class="indent" >   Some class metaobject classes allow their instances to be reinitialized. This is
done by calling <b><a 
href="symbols.html#x188-380795r795">reinitialize-instance</a></b>. The initialization arguments have the
same interpretation as in class initialization.
<!--l. 1087--><p class="indent" >   If the class metaobject was ﬁnalized before the call to <b><a 
href="symbols.html#x188-380795r795">reinitialize-instance</a></b>,
<b><a 
href="symbols.html#x188-380411r411">ﬁnalize-inheritance</a></b> will be called again once all the initialization arguments
have been processed and associated with the class metaobject. In addition, once
ﬁnalization is complete, any dependents of the class metaobject will be updated
by calling <b><a 
href="symbols.html#x188-380991r991">update-dependent</a></b>.
<b>
<!--l. 1093--><p class="indent" >   Initialization of Generic Function and Method Metaobjects</b>
<!--l. 1095--><p class="indent" >   An example of creating a generic function and a method metaobject, and then
adding the method to the generic function is shown below. This example is
comparable to the method deﬁnition shown in <a 
href="#x184-3590011">29.1<!--tex4ht:ref: example-3 --></a>.
<div class="lisp">
<tt>
<!--l. 1099--><p class="indent" >   <div class="tabbing">
                                                                          

                                                                          
(let* ((gf (make-instance &#x2019;standard-generic-function
   <br>                          :lambda-list &#x2019;(p l &#x0026;optional visiblyp &#x0026;key)))<br>
       (method-class (generic-function-method-class gf)))<br>
  (multiple-value-bind (lambda initargs)<br>           (make-method-lambda<br>
         gf<br>                               (class-prototype method-class)<br>
         &#x2019;(lambda (p l &#x0026;optional (visiblyp t) &#x0026;key color)<br>
            (set-to-origin p)<br>            (when visiblyp (show-move p 0 color)))<br>
         nil)<br>                                             (add-method gf<br>
                (apply #&#x2019;make-instance method-class<br>
                       :function (compile nil lambda)<br>
                       :specializers (list (ﬁnd-class &#x2019;position)<br>
                                           (intern-eql-specializer 0))<br>
                       :qualiﬁers ()<br>                       :lambda-list &#x2019;(p l &#x0026;optional (visiblyp t)<br>
                                          &#x0026;key color)<br>
                       initargs))))<br>                                     <br>
<!--l. 1120--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1122--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-36400029.1.5" id="x184-36400029.1.5">Class Finalization Protocol</a></h5>
<!--l. 1125--><p class="noindent" >Class <em>ﬁnalization</em> is the process of computing the information a class inherits from
its superclasses and preparing to actually allocate instances of the class. The class
ﬁnalization process includes computing the class&#x2019;s class precedence list, the full set
of slots accessible in instances of the class and the full set of default initialization
arguments for the class. These values are associated with the class metaobject and
can be accessed by calling the appropriate reader. In addition, the class
ﬁnalization process makes decisions about how instances of the class will be
implemented.
<!--l. 1134--><p class="indent" >   To support forward-referenced superclasses, and to account for the fact that
not all classes are actually instantiated, class ﬁnalization is not done as part of the
initialization of the class metaobject. Instead, ﬁnalization is done as a separate
protocol, invoked by calling the generic function <b><a 
href="symbols.html#x188-380411r411">ﬁnalize-inheritance</a></b>. The exact
point at which <b><a 
href="symbols.html#x188-380411r411">ﬁnalize-inheritance</a></b> is called depends on the class of the class
metaobject; for standard-class it is called sometime after all the classes
superclasses are deﬁned, but no later than when the ﬁrst instance of the class is
                                                                          

                                                                          
allocated (by <b><a 
href="symbols.html#x188-380094r94">allocate-instance</a></b>).
<!--l. 1144--><p class="indent" >   The ﬁrst step of class ﬁnalization is computing the class precedence list. Doing
this ﬁrst allows subsequent steps to access the class precedence list. This step is
performed by calling the generic function <b><a 
href="symbols.html#x188-380272r272">compute-class-precedence-list</a></b>. The
value returned from this call is associated with the class metaobject and can be
accessed by calling the <b><a 
href="symbols.html#x188-380246r246">class-precedence-list</a></b> generic function.
<!--l. 1151--><p class="indent" >   The second step is computing the full set of slots that will be accessible in
instances of the class. This step is performed by calling the generic function
compute-slots. The result of this call is a list of eﬀective slot deﬁnition
metaobjects. This value is associated with the class metaobject and can be
accessed by calling the <b><a 
href="symbols.html#x188-380248r248">class-slots</a></b> generic function.
<!--l. 1157--><p class="indent" >   The behavior of <b><a 
href="symbols.html#x188-380278r278">compute-slots</a></b> is itself layered, consisting of calls to
<b><a 
href="symbols.html#x188-380365r365">eﬀective-slot-deﬁnition-class</a></b> and <b><a 
href="symbols.html#x188-380276r276">compute-eﬀective-slot-deﬁnition</a></b>.
<!--l. 1160--><p class="indent" >   The ﬁnal step of class ﬁnalization is computing the full set of initialization
arguments for the class. This is done by calling the generic function
<b><a 
href="symbols.html#x188-380273r273">compute-default-initargs</a></b>. The value returned by this generic function
is associated with the class metaobject and can be accessed by calling
<b><a 
href="symbols.html#x188-380238r238">class-default-initargs</a></b>.
<!--l. 1166--><p class="indent" >   If the class was previously ﬁnalized, <b><a 
href="symbols.html#x188-380411r411">ﬁnalize-inheritance</a></b> may call
<b><a 
href="symbols.html#x188-380596r596">make-instances-obsolete</a></b>. The circumstances under which this happens are
describe in the section <a 
href="clmse143.html#x175-29100027.1.10">27.1.10<!--tex4ht:ref: Redefining-Classes-SECTION --></a> of the CLOS speciﬁcation.
<!--l. 1170--><p class="indent" >   Forward-referenced classes, which provide a temporary deﬁnition for a class
which has been referenced but not yet deﬁned, can never be ﬁnalized. An
error is signalled if <b><a 
href="symbols.html#x188-380411r411">ﬁnalize-inheritance</a></b> is called on a forward-referenced
class.
<!--l. 1174--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-36500029.1.5" id="x184-36500029.1.5">Instance Structure Protocol</a></h5>
<!--l. 1177--><p class="noindent" >The instance structure protocol is responsible for implementing the behavior of
the slot access functions like slot-value and (setf slot-value).
<!--l. 1180--><p class="indent" >   For each CLOS slot access function other than slot-exists-p, there is a
corresponding generic function which actually provides the behavior of the
function. When called, the slot access function ﬁnds the pertinent eﬀective slot
deﬁnition metaobject, calls the corresponding generic function and returns its
result. The arguments passed on to the generic function include one additional
value, the class of the <em>object</em> argument, which always immediately precedes the
                                                                          

                                                                          
<em>object</em> argument
<!--l. 1188--><p class="indent" >   The correspondences between slot access function and underlying slot access
generic function are as follows:
   <div class="tabular"><table width="100%" class="tabular"><tr><td align="left" ><b>Slot Access Function</b></td><td align="left" ><b>Corresponding Slot Access Generic Function</b></td>
</tr><tr><td align="left" >slot-boundp                </td><td align="left" >slot-boundp-using-class                                     </td>
</tr><tr><td align="left" >slot-makunbound         </td><td align="left" >slot-makunbound-using-class                              </td>
</tr><tr><td align="left" >slot-value                   </td><td align="left" >slot-value-using-class                                        </td>
</tr><tr><td align="left" >(setf slot-value)           </td><td align="left" >(setf slot-value-using-class)                                </td></tr><tr><td align="left" > </td> </tr></table>
</div>
<!--l. 1199--><p class="indent" >   At the lowest level, the instance structure protocol provides only limited
mechanisms for portable programs to control the implementation of instances and
to directly access the storage associated with instances without going through the
indirection of slot access. This is done to allow portable programs to perform
certain commonly requested slot access optimizations.
<!--l. 1205--><p class="indent" >   In particular, portable programs can control the implementation of, and obtain
direct access to, slots with allocation <b>:instance</b> and type <b><a 
href="symbols.html#x188-380953r953">t</a></b>. These are called
directly accessible slots.
<!--l. 1209--><p class="indent" >   The relevant speciﬁed around-method on <b><a 
href="symbols.html#x188-380278r278">compute-slots</a></b> determines the
implementation of instances by deciding how each slot in the instance
will be stored. For each directly accessible slot, this method allocates a
location and associates it with the eﬀective slot deﬁnition metaobject. The
location can be accessed by calling the slot-deﬁnition-location generic
function. Locations are non-negative integers. For a given class, the locations
increase consecutively, in the order that the directly accessible slots appear
in the list of eﬀective slots. (Note that here, the next paragraph, and
the speciﬁcation of this around-method are the only places where the
value returned by <b><a 
href="symbols.html#x188-380278r278">compute-slots</a></b> is described as a list rather than a
set.)
<!--l. 1220--><p class="indent" >   Given the location of a directly accessible slot, the value of that slot in an instance
can be accessed with the appropriate accessor. For <b>standard-class</b>, this accessor
is the function <b><a 
href="symbols.html#x188-380901r901">standard-instance-access</a></b>. For <b>funcallable-standard-class</b>,
this accessor is the function <b><a 
href="symbols.html#x188-380445r445">funcallable-standard-instance-access</a></b>. In each
case, the arguments to the accessor are the instance and the slot location, in that
order. See the deﬁnition of each accessor in Chapter for additional restrictions on
the use of these function.
<!--l. 1229--><p class="indent" >   Portable programs are permitted to aﬀect and rely on the allocation of
locations only in the following limited way: By ﬁrst deﬁning a portable primary
method on <b><a 
href="symbols.html#x188-380278r278">compute-slots</a></b> which orders the returned value in a predictable way,
and then relying on the deﬁned behavior of the speciﬁed around-method to assign
                                                                          

                                                                          
locations to all directly accessible slots. Portable programs may compile-in calls to
low-level accessors which take advantage of the resulting predictable allocation of
slot locations.
<!--l. 1237--><p class="indent" >   The following example shows the use of this mechanism to implement a new
class metaobject class, <b>ordered-class</b> and class option <b>:slot-order</b>. This option
provides control over the allocation of slot locations. In this simple example
implementation, the <b>:slot-order</b> option is not inherited by subclasses; it controls
only instances of the class itself.
<div class="lisp">
<tt>
<!--l. 1243--><p class="indent" >   <div class="tabbing">
(defclass ordered-class (standard-class)
   <br>       ((slot-order :initform ()<br>                    :initarg :slot-order<br>
                  :reader class-slot-order)))<br>                            <br>
(defmethod <b><a 
href="symbols.html#x188-380278r278">compute-slots</a></b> ((class ordered-class))<br>
  (let ((order (class-slot-order class)))<br>    (sort (copy-list (<b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>))<br>
          #&#x2019;(lambda (a b) (&#x003C; (position (slot-deﬁnition-name a) order)<br>
                             (position (slot-deﬁnition-name b) order))))))<br>
<br>
<!--l. 1254--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1256--><p class="indent" >   Following is the source code the user of this extension would write. Note that
because the code above doesn&#x2019;t implement inheritance of the <b>:slot-order</b> option,
the function <b>distance</b> must not be called on instances of subclasses of <b>point</b>; it
can only be called on instances of <b>point</b> itself.
<div class="lisp">
<tt>
<!--l. 1261--><p class="indent" >   <div class="tabbing">
(defclass point ()
   <br>                        ((x :initform 0)<br>                         (y :initform 0))<br>
  (:metaclass ordered-class)<br>                              (:slot-order x y))<br>
                                                                          

                                                                          
<br>                                                    (defun distance (point)<br>
  (sqrt (/ (+ (expt (standard-instance-access point 0) 2)<br>
           (expt (standard-instance-access point 1) 2)) 2.0)))<br>             <br>
<!--l. 1271--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1273--><p class="indent" >   In more realistic uses of this mechanism, the calls to the low-level instance
structure accessors would not actually appear textually in the source program,
but rather would be generated by a meta-level analysis program run during the
process of compiling the source program.
<!--l. 1278--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-36600029.1.5" id="x184-36600029.1.5">Funcallable Instances</a></h5>
<!--l. 1281--><p class="noindent" >Instances of classes which are themselves instances of <b>funcallable-standard-class</b>
or one of its subclasses are called funcallable instances. Funcallable instances can
only be created by <b><a 
href="symbols.html#x188-380094r94">allocate-instance</a></b> (funcallable-standard-class).
<!--l. 1286--><p class="indent" >   Like standard instances, funcallable instances have slots with the normal
behavior. They diﬀer from standard instances in that they can be used as
functions as well; that is, they can be passed to funcall and apply, and they can be
stored as the deﬁnition of a function name. Associated with each funcallable
instance is the function which it runs when it is called. This function can be
changed with <b><a 
href="symbols.html#x188-380841r841">set-funcallable-instance-function</a></b>.
<!--l. 1293--><p class="indent" >   The following simple example shows the use of funcallable instances to create a
simple, <b><a 
href="symbols.html#x188-380325r325">defstruct</a></b>-like facility. (Funcallable instances are useful when a
program needs to construct and maintain a set of functions and information
about those functions. They make it possible to maintain both as the
same object rather than two separate objects linked, for example, by hash
tables.)
<div class="lisp">
<tt>
<!--l. 1299--><p class="indent" >   <div class="tabbing">
(defclass constructor ()
   <br>                           ((name :initarg :name :accessor constructor-name)<br>
                                                                          

                                                                          
      (ﬁelds :initarg :ﬁelds :accessor constructor-ﬁelds))<br>
  (:metaclass funcallable-standard-class))<br>
<br>                 (defmethod initialize-instance :after ((c constructor) &#x0026;key)<br>
  (with-slots (name ﬁelds) c<br>             (set-funcallable-instance-function<br>
      c<br>                                                    #&#x2019;(lambda ()<br>
          (let ((new (make-array (1+ (length ﬁelds)))))<br>
            (setf (aref new 0) name) new)))))<br>
<br>         (setq c1 (make-instance &#x2019;constructor :name &#x2019;position :ﬁelds &#x2019;(x y)))<br>
#&#x003C;CONSTRUCTOR 262437&#x003E;<br>                                            <br>
(setq p1 (funcall c1))<br>                               #&#x003C;ARRAY 3 263674&#x003E;<br>
<br>
<!--l. 1318--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1320--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-36700029.1.5" id="x184-36700029.1.5">Generic Function Invocation Protocol</a></h5>
<!--l. 1322--><p class="noindent" >Associated with each generic function is its discriminating function. Each time
the generic function is called, the discriminating function is called to
provide the behavior of the generic function. The discriminating function
receives the full set of arguments received by the generic function. It must
lookup and execute the appropriate methods, and return the appropriate
values.
<!--l. 1328--><p class="indent" >   The discriminating function is computed by the highest layer of the generic
function invocation protocol, <b><a 
href="symbols.html#x188-380274r274">compute-discriminating-function</a></b>. Whenever a
generic function metaobject is initialized, reinitialized, or a method is added or
removed, the discriminating function is recomputed. The new discriminating
function is then stored with <b><a 
href="symbols.html#x188-380841r841">set-funcallable-instance-function</a></b>.
<!--l. 1334--><p class="indent" >   Discriminating functions call <b><a 
href="symbols.html#x188-380270r270">compute-applicable-methods</a></b> and
<b><a 
href="symbols.html#x188-380271r271">compute-applicable-methods-using-classes</a></b> to compute the methods
applicable to the generic functions arguments. Applicable methods are combined
by <b><a 
href="symbols.html#x188-380275r275">compute-eﬀective-method</a></b> to produce an <em>eﬀective</em> method. Provisions are
made to allow memoization of the method applicability and eﬀective methods
computations. (See the description of <b><a 
href="symbols.html#x188-380274r274">compute-discriminating-function</a></b> for
details.)
<!--l. 1342--><p class="indent" >   The body of method deﬁnitions are processed by <b><a 
href="symbols.html#x188-380600r600">make-method-lambda</a></b>.
                                                                          

                                                                          
The result of this generic function is a lambda expression which is processed by
either <b><a 
href="symbols.html#x188-380260r260">compile</a></b> or the ﬁle compiler to produce a <em>method function</em>. The
arguments received by the method function are controlled by the call-method
forms appearing in the eﬀective methods. By default, method functions
accept two arguments: a list of arguments to the generic function, and a
list of next methods. The list of next methods corresponds to the next
methods argument to <b><a 
href="symbols.html#x188-380189r189">call-method</a></b>. If <b><a 
href="symbols.html#x188-380189r189">call-method</a></b> appears with additional
arguments, these will be passed to the method functions as well; in these cases,
<b><a 
href="symbols.html#x188-380600r600">make-method-lambda</a></b> must have created the method lambdas to expect
additional arguments.
<!--l. 1354--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x184-36800029.1.5" id="x184-36800029.1.5">Dependent Maintenance Protocol</a></h5>
<!--l. 1357--><p class="noindent" >It is convenient for portable metaobjects to be able to memoize information about
other metaobjects, portable or otherwise. Because class and generic function
metaobjects can be reinitialized, and generic function metaobjects can be
modiﬁed by adding and removing methods, a means must be provided to update
this memoized information.
<!--l. 1363--><p class="indent" >   The dependent maintenance protocol supports this by providing a way to
register an object which should be notiﬁed whenever a class or generic function is
modiﬁed. An object which has been registered this way is called a dependent of
the class or generic function metaobject. The dependents of class and
generic function metaobjects are maintained with <b><a 
href="symbols.html#x188-380087r87">add-dependent</a></b> and
<b><a 
href="symbols.html#x188-380800r800">remove-dependent</a></b>. The dependents of a class or generic function metaobject
can be accessed with <b><a 
href="symbols.html#x188-380613r613">map-dependents</a></b>. Dependents are notiﬁed about a
modiﬁcation by calling <b><a 
href="symbols.html#x188-380991r991">update-dependent</a></b>. (See the speciﬁcation of
<b><a 
href="symbols.html#x188-380991r991">update-dependent</a></b> for detailed description of the circumstances under which it
is called.)
<!--l. 1374--><p class="indent" >   To prevent conﬂicts between two portable programs, or between portable
programs and the implementation, portable code must not register metaobjects
themselves as dependents. Instead, portable programs which need to record a
metaobject as a dependent, should encapsulate that metaobject in some other
kind of object, and record that object as the dependent. The results are undeﬁned
if this restriction is violated.
<!--l. 1381--><p class="indent" >   This example shows a general facility for encapsulating metaobjects before
recording them as dependents. The facility deﬁnes a basic kind of encapsulating
                                                                          

                                                                          
object: an updater. Specializations of the basic class can be deﬁned with
appropriate special updating behavior. In this way, information about the
updating required is associated with each updater rather than with the
metaobject being updated.
<!--l. 1388--><p class="indent" >   Updaters are used to encapsulate any metaobject which requires updating
when a given class or generic function is modiﬁed. The function <b>record-updater</b>
is called to both create an updater and add it to the dependents of the class or
generic function. Methods on the generic function <b><a 
href="symbols.html#x188-380991r991">update-dependent</a></b>,
specialized to the speciﬁc class of updater do the appropriate update
work.
<div class="lisp">
<tt>
<!--l. 1394--><p class="indent" >   <div class="tabbing">
(defclass updater ()
   <br>                       ((dependent :initarg :dependent :reader dependent)))<br>
<br>           (defun record-updater (class dependee dependent &#x0026;rest initargs)<br>
  (let ((updater (apply #&#x2019;make-instance class :dependent dependent initargs)))<br>
    (<b><a 
href="symbols.html#x188-380087r87">add-dependent</a></b> dependee updater) updater))<br>
<!--l. 1401--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1403--><p class="indent" >   A ﬂush-cache-updater simply ﬂushes the cache of the dependent when it is
updated.
<div class="lisp">
<tt>
<!--l. 1405--><p class="indent" >   <div class="tabbing">
(defclass ﬂush-cache-updater (updater) ())
   <br>                                                                                               <br>
(defmethod <b><a 
href="symbols.html#x188-380991r991">update-dependent</a></b> (dependee (updater ﬂush-cache-updater) &#x0026;rest args)<br>
  (declare (ignore args))<br>                (ﬂush-cache (dependent updater)))<br>
<!--l. 1412--><p class="noindent" ></div>
                                                                          

                                                                          
</tt>
</div>
                                                                          

                                                                          
<!--l. 1414--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse151.html" >Next</a>&#x003E;&#x003C;<a 
href="amop.html" >Prev</a>&#x003E;&#x003C;<a 
href="amop.html#tailamop.html" >PrevTail</a>&#x003E;&#x003C;<a 
href="clmse150.html" >Front</a>&#x003E;&#x003C;<a 
href="amop.html#clmse150.html" >Up</a>&#x003E;<br>&lt;<a href="../index.html">Main Page</a>&gt; &lt;<a href="symbols.html">Symbols</a>&gt; </div><a 
 id="tailclmse150.html"></a>    
</body></html> 
