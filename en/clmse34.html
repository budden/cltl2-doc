<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Logical operators</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2013-03-12 14:37:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Main Page</a>&gt; &lt;<a href="symbols.html">Symbols</a>&gt; <br> &#x003C;<a 
href="contrl.html" >Next</a>&#x003E;&#x003C;<a 
href="clmse33.html" >Prev</a>&#x003E;&#x003C;<a 
href="clmse33.html#tailclmse33.html" >PrevTail</a>&#x003E;&#x003C;<a 
href="#tailclmse34.html">Tail</a>&#x003E;&#x003C;<a 
href="preds.html#clmse34.html" >Up</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">6.4   </span> <a 
href="clm.html#QQ2-45-81" id="x45-730006.4">Logical operators</a></h3>
<!--l. 884--><p class="noindent" >Common Lisp provides three operators on Boolean values: <b><a 
href="symbols.html#x200-396098r98">and</a></b>, <b><a 
href="symbols.html#x200-396703r703">or</a></b>, and <b><a 
href="symbols.html#x200-396676r676">not</a></b>. Of
these, <b><a 
href="symbols.html#x200-396098r98">and</a></b> and <b><a 
href="symbols.html#x200-396703r703">or</a></b> are also control structures because their arguments are
evaluated conditionally. The function <b><a 
href="symbols.html#x200-396676r676">not</a></b> necessarily examines its single
argument, and so is a simple function.
<div class="defun">
<div class="defunheader">
<a 
 id="dx45-73001"></a>
<em>
<!--l. 892--><p class="noindent" >[Function]</em> <b>not</b> <i>x</i>
</div>
<b>
<!--l. 894--><p class="indent" >   <a 
href="symbols.html#x200-396676r676">not</a></b> returns <b><a 
href="symbols.html#x200-396953r953">t</a></b> if <em>x</em> is <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, and otherwise returns <b><a 
href="symbols.html#x200-396670r670">nil</a></b>. It therefore inverts its
argument considered as a Boolean value.
<b>
<!--l. 897--><p class="indent" >   <a 
href="symbols.html#x200-396696r696">null</a></b> is the same as <b><a 
href="symbols.html#x200-396676r676">not</a></b>; both functions are included for the sake of
clarity. As a matter of style, it is customary to use <b><a 
href="symbols.html#x200-396696r696">null</a></b> to check whether
something is the empty list and to use <b><a 
href="symbols.html#x200-396676r676">not</a></b> to invert the sense of a logical
value.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 904--><p class="indent" >   <div class="tabbing">
 <em>[Macro]</em> <b>and</b> <a 
 id="dx45-73002"></a>{form}*
   <br>
<!--l. 905--><p class="noindent" ></div>
</div>
<b>
                                                                          

                                                                          
<!--l. 906--><p class="indent" >   (and <em>form1</em> <em>form2</em> ... )</b> evaluates each <em>form</em>, one at a time, from left to
right. If any <em>form</em> evaluates to <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, the value <b><a 
href="symbols.html#x200-396670r670">nil</a></b> is immediately returned without
evaluating the remaining <em>form</em>s. If every <em>form</em> but the last evaluates to a non-<b><a 
href="symbols.html#x200-396670r670">nil</a></b>
value, <b><a 
href="symbols.html#x200-396098r98">and</a></b> returns whatever the last <em>form</em> returns. Therefore in general <b><a 
href="symbols.html#x200-396098r98">and</a></b> can
be used both for logical operations, where <b><a 
href="symbols.html#x200-396670r670">nil</a></b> stands for <em>false</em> and non-<b><a 
href="symbols.html#x200-396670r670">nil</a></b>
values stand for <em>true</em>, and as a conditional expression. An example follows.
<div class="lisp"><tt><div class="tabbing">
(if (and (&#x003E;= n 0)
   <br>                                                  (&#x003C; n (length a-simple-vector))<br>
         (eq (elt a-simple-vector n) &#x2019;foo))<br>                 (princ &#x0022;Foo!&#x0022;))<br>
<!--l. 920--><p class="noindent" ></div>
</tt>
</div>
<!--l. 921--><p class="indent" >   The above expression prints <b>Foo!</b> if element <b>n</b> of <b>a-simple-vector</b> is the
symbol <b>foo</b>, provided also that <b>n</b> is indeed a valid index for <b>a-simple-vector</b>.
Because <b><a 
href="symbols.html#x200-396098r98">and</a></b> guarantees left-to-right testing of its parts, <b><a 
href="symbols.html#x200-396367r367">elt</a></b> is not called if <b>n</b> is
out of range.
<!--l. 926--><p class="indent" >   To put it another way, the <b><a 
href="symbols.html#x200-396098r98">and</a></b> special operator does <em>short-circuit</em> Boolean
evaluation, like the <b>and then</b> operator in Ada and what in some Pascal-like
languages is called <b>cand</b> (for “conditional and”); the Lisp <b><a 
href="symbols.html#x200-396098r98">and</a></b> special operator
is unlike the Pascal or Ada <b>and</b> operator, which always evaluates both
arguments.
<!--l. 934--><p class="indent" >   In the previous example writing <div class="lisp"><tt><div class="tabbing">
(and (&#x003E;= n 0)
   <br>                                                    (&#x003C; n (length a-simple-vector))<br>
     (eq (elt a-simple-vector n) &#x2019;foo)<br>                      (princ &#x0022;Foo!&#x0022;))<br>
<!--l. 940--><p class="noindent" ></div>
</tt>
</div>
<!--l. 941--><p class="indent" >   would accomplish the same thing. The diﬀerence is purely stylistic. Some
programmers never use expressions containing side eﬀects within <b><a 
href="symbols.html#x200-396098r98">and</a></b>, preferring
to use <b><a 
href="symbols.html#x200-396488r488">if</a></b> or <b><a 
href="symbols.html#x200-397011r1011">when</a></b> for that purpose.
                                                                          

                                                                          
<!--l. 945--><p class="indent" >   From the general deﬁnition, one can deduce that <b>(and <em>x</em>)</b> <span class="math"> ≡</span> <em>x</em>. Also, <b>(and)</b>
evaluates to <b><a 
href="symbols.html#x200-396953r953">t</a></b>, which is an identity for this operation.
<!--l. 949--><p class="indent" >   One can deﬁne <b><a 
href="symbols.html#x200-396098r98">and</a></b> in terms of <b><a 
href="symbols.html#x200-396281r281">cond</a></b> in this way: <div class="lisp"><tt><div class="tabbing">
(and <em>x</em> <em>y</em> <em>z</em> ... <em>w</em>) <span class="math"> ≡</span> (cond ((not <em>x</em>) <b><a 
href="symbols.html#x200-396670r670">nil</a></b>)
   <br>                                                                               ((not <em>y</em>) <b><a 
href="symbols.html#x200-396670r670">nil</a></b>)<br>
                           ((not <em>z</em>) <b><a 
href="symbols.html#x200-396670r670">nil</a></b>)<br>                                  <span class="math">…</span><br>
                           (<b><a 
href="symbols.html#x200-396953r953">t</a></b> <em>w</em>))<br>
<!--l. 956--><p class="noindent" ></div>
</tt>
</div>
<!--l. 958--><p class="indent" >   See <b><a 
href="symbols.html#x200-396488r488">if</a></b> and <b><a 
href="symbols.html#x200-397011r1011">when</a></b>, which are sometimes stylistically more appropriate than <b><a 
href="symbols.html#x200-396098r98">and</a></b>
for conditional purposes. If it is necessary to test whether a predicate is true of all
elements of a list or vector (element 0 <em>and</em> element 1 <em>and</em> element 2 <em>and</em> <span class="math">…</span>), then
the function <b><a 
href="symbols.html#x200-396389r389">every</a></b> may be useful.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 966--><p class="indent" >   <div class="tabbing">
 <em>[Macro]</em> <b>or</b> <a 
 id="dx45-73003"></a>{form}*
   <br>
<!--l. 967--><p class="noindent" ></div>
</div>
<b>
<!--l. 968--><p class="indent" >   (or <em>form1</em> <em>form2</em> ... )</b> evaluates each <em>form</em>, one at a time, from left to right.
If any <em>form</em> other than the last evaluates to something other than <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, <b><a 
href="symbols.html#x200-396703r703">or</a></b>
immediately returns that non-<b><a 
href="symbols.html#x200-396670r670">nil</a></b> value without evaluating the remaining <em>form</em>s. If
every <em>form</em> but the last evaluates to <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, <b><a 
href="symbols.html#x200-396703r703">or</a></b> returns whatever evaluation of the last
of the <em>form</em>s returns. Therefore in general <b><a 
href="symbols.html#x200-396703r703">or</a></b> can be used both for logical
operations, where <b><a 
href="symbols.html#x200-396670r670">nil</a></b> stands for <em>false</em> and non-<b><a 
href="symbols.html#x200-396670r670">nil</a></b> values stand for <em>true</em>, and as a
conditional expression.
<!--l. 979--><p class="indent" >   To put it another way, the <b><a 
href="symbols.html#x200-396703r703">or</a></b> special operator does <em>short-circuit</em> Boolean
evaluation, like the <b>or else</b> operator in Ada and what in some Pascal-like
                                                                          

                                                                          
languages is called <b>cor</b> (for “conditional or”); the Lisp <b><a 
href="symbols.html#x200-396703r703">or</a></b> special operator
is unlike the Pascal or Ada <b>or</b> operator, which always evaluates both
arguments.
<!--l. 987--><p class="indent" >   From the general deﬁnition, one can deduce that <b>(or <em>x</em>)</b> <span class="math"> ≡</span> <em>x</em>. Also, <b>(or)</b>
evaluates to <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, which is the identity for this operation.
<!--l. 991--><p class="indent" >   One can deﬁne <b><a 
href="symbols.html#x200-396703r703">or</a></b> in terms of <b><a 
href="symbols.html#x200-396281r281">cond</a></b> in this way: <div class="lisp"><tt><div class="tabbing">
(or <em>x</em> <em>y</em> <em>z</em> ... <em>w</em>) <span class="math"> ≡</span> (cond (<em>x</em>) (<em>y</em>) (<em>z</em>) ... (<b><a 
href="symbols.html#x200-396953r953">t</a></b> <em>w</em>))
   <br>
<!--l. 994--><p class="noindent" ></div>
</tt>
</div>
<!--l. 996--><p class="indent" >   See <b><a 
href="symbols.html#x200-396488r488">if</a></b> and <b><a 
href="symbols.html#x200-396984r984">unless</a></b>, which are sometimes stylistically more appropriate than <b><a 
href="symbols.html#x200-396703r703">or</a></b>
for conditional purposes. If it is necessary to test whether a predicate is true of
one or more elements of a list or vector (element 0 <em>or</em> element 1 <em>or</em> element 2 <em>or</em>
<span class="math">…</span>), then the function <b><a 
href="symbols.html#x200-396892r892">some</a></b> may be useful.
<hr></div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
<!--l. 7--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="contrl.html" >Next</a>&#x003E;&#x003C;<a 
href="clmse33.html" >Prev</a>&#x003E;&#x003C;<a 
href="clmse33.html#tailclmse33.html" >PrevTail</a>&#x003E;&#x003C;<a 
href="clmse34.html" >Front</a>&#x003E;&#x003C;<a 
href="preds.html#clmse34.html" >Up</a>&#x003E;<br>&lt;<a href="../index.html">Main Page</a>&gt; &lt;<a href="symbols.html">Symbols</a>&gt; </div><a 
 id="tailclmse34.html"></a>  
</body></html> 
