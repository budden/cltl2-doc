%%%Chapter of Common Lisp Manual.  Copyright 1989 Guy L. Steele Jr.
%%% Based on ANSI X3J13 document X3J13/89-004 which in turn is
%%% based on documentation by Lucid, Inc.

\clearpage\def\pagestatus{FINAL PROOF}

\chapter{Loop}
\label{LOOP}

\chapter{Цикл loop}
\label{LOOP}

Author: Jon L White

Автор: Jon L White

\begin{new}
\prefaceword
X3J13 voted in January 1989
\issue{LOOP-FACILITY}
to adopt an extended definition of the \cdf{loop} macro
as a part of the forthcoming draft Common Lisp standard.
\end{new}
This chapter presents the bulk of the Common Lisp
Loop Facility proposal, written by Jon L White.  I have
edited it only very lightly
to conform to the overall style of this book and have inserted a small
number of bracketed remarks, identified by the initials GLS.
(See the Acknowledgments to this second edition for
acknowledgments to others who contributed to the Loop Facility proposal.)

Guy L. Steele Jr.

\section{Introduction}

\section{Введение}

A \emph{loop\/} is a series of expressions that are executed one or more times,
a process known as \emph{iteration}.
The \emph{Loop Facility\/} defines a
variety of useful methods, indicated by
\emph{loop keywords}, to iterate and to
accumulate values in a loop.

\emph{Цикл} представляет собой группу выражений, которые выполняются
один или более раз, такой процесс известен как \emph{итерация}.
Цикл \emph{Loop} включает в себя различную функциональность, которая
обозначается \emph{ключевыми символами loop}, для итерации и для
накопления значений в цикле.

Loop keywords are not true Common Lisp keywords; they are symbols that
are recognized by the Loop Facility and that provide such capabilities
as controlling the direction of iteration, accumulating values inside
the body of a loop, and evaluating expressions that precede or follow
the loop body.  If you do not use any loop keywords, the Loop Facility
simply executes the loop body repeatedly.

Ключевые символы \emph{loop} это не те ключевые символы Common
Lisp'а. Они являются просто символами, которые имеют специальное
значение в теле этой формы. Символы указывают на: направление
итерации, накопление значения внутри тела, на действия для выполнения
в начале/конце цикла.  Если вы не используете эти ключевые символы, то
\cdf{loop} просто циклически выполняет тело.

\section{How the Loop Facility Works}

\section{Как работает Loop}

The driving element of the Loop Facility is the \cdf{loop} macro.
When Lisp encounters a \cdf{loop} macro call
form, it invokes the Loop Facility and passes to it the loop clauses
as a list of unevaluated forms, as with any macro.
The loop clauses contain Common Lisp forms and loop keywords.  The
loop keywords are recognized by their symbol name, regardless of the
packages that contain them.  The \cdf{loop} macro translates the
given form into Common Lisp code and returns the expanded form.

Главным элементом Loop является макрос \cdf{loop}.  Как только Common
Lisp видит вызов макроса \cdf{loop}, он разворачивает его без
вычисления аргументов, что собственно происходит и с любым другим
макросом. Loop содержит формы и ключевые символы. Ключевые символы
обозначаются символами не обращая внимание на их принадлежность к
пакету. Макрос \cdf{loop} транслирует полученную форму в Common
Lisp'овый код и возвращает развёрнутую форму.

The expanded loop form is one or more lambda-expressions for the local
binding of loop variables and a block and a tagbody that express a
looping control structure.  The variables established in the loop
construct are bound as if by using \cdf{let} or \cdf{lambda}.
Implementations can interleave the setting of initial values with the
bindings.  However, the assignment of the initial values is always
calculated in the order specified by the user.  A variable is thus
sometimes bound to a harmless value of the correct data type, and then
later in the prologue it is set to the true initial value by using
\cdf{setq}.

Развернутая форма представляется собой одно или более лямбда-выражений
для связываний переменных цикла и формы block или tagbody, которые
содержат тело цикла. Переменные для цикла создаются как если бы с
помощью \cdf{let} или \cdf{lambda}. Связывание локальных переменных
происходит в том порядке, в каком указал пользователь.

The expanded form consists of three basic parts in the tagbody:

Развёрнутая форма состоит из трёх основных частей в tagbody:

\begin{itemize}
\item
The \emph{loop prologue\/} contains forms that are executed before iteration begins, 
such as initial settings of loop variables and possibly an initial
termination test.

\item \emph{Пролог} содержит формы, которые вычисляется перед началом
  итераций, например, первоначальные связывания переменных цикла и
  возможно первая проверка на завершение цикла.

\item
The \emph{loop body\/}  contains those forms that are executed during iteration, 
including application-specific calculations, termination tests,
and variable stepping.  \emph{Stepping\/} is the process of assigning a
variable the next item in a series of items.

\item \emph{Тело} содержит формы, которые вычисляются на каждом шаге
  цикла, включая непосредственно пользовательские операции, проверки
  завершения цикла, и пошаговое изменение переменных
  цикла. \emph{Пошаговое изменение} это присваивание переменное
  следующего значения из последовательности значений.

\item
The \emph{loop epilogue} contains forms that are executed after iteration 
terminates,
such as code to return values from the loop.

\item \emph{Эпилог} содержит формы, которые вычисляются после
  завершения цикла, например, форма возврата значений из цикла.
\end{itemize}

Expansion of the \cdf{loop} macro produces an implicit block 
(named \cdf{nil}).
Thus, the Common Lisp macro \cdf{return} and the special operator 
\cdf{return-from} can be 
used to return values from a loop or to exit a loop.

Раскрытие макроса \cdf{loop} порождает неявный block (с именем
\cdf{nil}). Таким образом, внутри цикла для возврата значений или
выхода можно пользоваться макросом \cdf{return} или специальным
оператором \cdf{return-from}.

Within the executable parts of loop clauses and around the entire loop
form, you can still bind variables by using the Common Lisp special
operator \cdf{let}.

В любой части выражения цикла можно использовать обычную конструкцию
связывания переменных \cdf{let}.


\section{Parsing Loop Clauses}

\section{Парсинг выражений Loop}

The syntactic parts of a loop construct are called \emph{clauses}; the
scope of each clause is determined by the top-level parsing of that
clause's keyword.  The following example shows a loop construct with
six clauses:

Синтаксические части конструкции loop называются
\emph{выражениями}. Область действия каждого выражения определяется
парсером данного типа выражения. Следующий пример показывает loop с
шестью выражениями:

\begin{lisp} (loop for i from 1 to (compute-top-value)~~~~~~~~~;\textrm{First clause} \\*
~~~~~~while (not (unacceptable i))~~~~~~~~~~~~~~~~;\textrm{Second clause} \\*
~~~~~~collect (square i)~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Third clause} \\* 
~~~~~~do (format t "Working on {\Xtilde}D now" i)~~~~~~~~~;\textrm{Fourth clause} \\* 
~~~~~~when (evenp i)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Fifth clause} \\* 
~~~~~~~~do (format t "{\Xtilde}D is a non-odd number" i) \\* 
~~~~~~finally (format t "About to exit!"))~~~~~~~~;\textrm{Sixth clause}
\end{lisp}

\begin{lisp} (loop for i from 1 to (compute-top-value)~~~~~~~~~;\textrm{Первое выражение} \\*
~~~~~~while (not (unacceptable i))~~~~~~~~~~~~~~~~;\textrm{Второе} \\*
~~~~~~collect (square i)~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Третье} \\*
~~~~~~do (format t "Обрабтка {\Xtilde}D " i)~~~~~~~~~;\textrm{Четвёртое} \\*
~~~~~~when (evenp i)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Пятое} \\* 
~~~~~~~~do (format t "{\Xtilde}D чётное" i) \\* 
~~~~~~finally (format t "Почти у выхода!"))~~~~~~~~;\textrm{Шестое}
\end{lisp}

Each loop keyword introduces either a compound loop clause or a simple
loop clause that can consist of a loop keyword followed by a single
Lisp form.  The number of forms in a clause is determined by the loop
keyword that begins the clause and by the auxiliary keywords in the
clause.  The keywords \cdf{do}, \cdf{initially}, and \cdf{finally} are
the only loop keywords that can take any number of Lisp forms and
group them as if in a single \cdf{progn} form.

Каждое ключевое слово представляет или составное выражение, или
простое выражение, которое может состоять из этого ключевого слова и
одиночное Lisp'овой формы. Количество форм в выражении определяется
первым ключевым символом или вспомогательными ключевыми символами в
выражении. Только такие ключевые символы, как \cdf{do},
\cdf{initially} и \cdf{finally}, могут принимать любое количество
Lisp'овых форм и группировать в одиночную форму \cdf{progn}.

Loop clauses can contain auxiliary keywords, which are sometimes
called \emph{prepositions}.  For example, the first clause in the
preceding code includes the prepositions \cdf{from} and \cdf{to},
which mark the value from which stepping begins and the value at which
stepping ends.

Выражения loop могут содержать вспомогательные ключевые символы,
которые иногда называются \emph{предлоги}. Например, первое выражение
в предыдущем коде включает предлоги \cdf{from} и \cdf{to}, которые
указывают на начальное и конечное значения для переменной.

\subsection{Order of Execution}

\subsection{Порядок вычисления}

With the exceptions listed below, clauses are executed in the loop
body in the order in which they appear in the source.  Execution is
repeated until a clause terminates the loop or until a Common Lisp
\cdf{return}, \cdf{go}, or \cdf{throw} form is encountered.  The
following actions are exceptions to the linear order of execution:

Выражения в теле loop вычисляются в том порядке, в котором задал
пользователь, с некоторыми исключениями перечисленными
ниже. Вычисление повторяется пока не сработает выражение, завершающее
цикл, или не будет вызвана одна из Common Lisp'овых форм \cdf{return},
\cdf{go}, \cdf{throw}. Для последовательного выполнения существуют
следующие исключения:

\begin{itemize}

\item All variables are initialized first, regardless of where the
  establishing clauses appear in the source.  The order of
  initialization follows the order of these clauses.

\item Перво-наперво выполняется инициализация всех переменных, вне
  зависимости от их позиции в исходном коде.
  Порядок инициализации сохраняется.

\item The code for any \cdf{initially} clauses is collected into one
  \cdf{progn} in the order in which the clauses appear in the source.
  The collected code is executed once in the loop prologue after any
  implicit variable initializations.

\item Код из всех \cdf{initially} выражений в исходном порядке
  собирается в один большой \cdf{progn}. Собранный код вычисляется
  единожды в прологе после инициализации всех переменных.

\item The code for any \cdf{finally} clauses is collected into one
  \cdf{progn} in the order in which the clauses appear in the source.
  The collected code is executed once in the loop epilogue before any
  implicit values from the accumulation clauses are returned.
  Explicit returns anywhere in the source, however, will exit the loop
  without executing the epilogue code.

\item Код для всех \cdf{finally} выражение в исходном порядке
  собирается в один большой \cdf{progn}. Собранный код вычисляется
  единожды в эпилоге, перед тем как будут неявно возвращены значения
  из цикла. Однако явный выход где-либо в исходнике, будет завершать
  цикл без выполнения эпилога.

\item A \cdf{with} clause introduces a variable binding and an
  optional initial value.  The initial values are calculated in the
  order in which the \cdf{with} clauses occur.

\item \cdf{with} выражение обозначает связывание переменной и
  опционально первоначальное значение. Первоначальные значение
  вычисляются в исходном порядке.

\item Iteration control clauses implicitly perform the following
  actions:
  \begin{itemize}
  \item initializing variables

  \item stepping variables, generally between each execution of the
    loop body

  \item performing termination tests, generally just before the
    execution of the loop body
  \end{itemize}

\item Выражения для итераций неявно выполняют следующие действия:
  \begin{itemize}
  \item присваивание переменных
  \item наращивание переменных на каждой итерации

  \item проверка условия завершения цикла, обычно перед выполнение итерации
  \end{itemize}
  
\end{itemize}

\subsection{Kinds of Loop Clauses}
\label{LOOP-KINDS-SECTION}

\subsection{Разновидности Loop выражений}

Loop clauses fall into one of the following categories:

Выражения делятся на следующие категории:

\begin{itemize}
  
\item variable initialization and stepping

\item инициализация и пошаговое изменение

  \begin{itemize}
  \item The \cdf{for} and \cdf{as} constructs provide iteration
    control clauses that establish a variable to be initialized.  You
    can combine \cdf{for} and \cdf{as} clauses with the loop keyword
    \cdf{and} to get parallel initialization and stepping.

  \item Конструкции \cdf{for} и \cdf{as} служат для установки
    переменных. Для параллельной инициализации и изменения, выражения
    \cdf{for} и \cdf{as} могут комбинироваться с помощью символа
    \cdf{and}.

  \item The \cdf{with} construct is similar to a single \cdf{let}
    clause. You can combine \cdf{with} clauses using \cdf{and} to get
    parallel initialization.

  \item Конструкция \cdf{with} похожа на выражение \cdf{let}. Для
    параллельной инициализации вы можете комбинировать \cdf{with} с
    помощью \cdf{and}.

  \item The \cdf{repeat} construct causes iteration to terminate after
    a specified number of times.  It uses an internal variable to keep
    track of the number of iterations.


  \item Конструкция \cdf{repeat} указывает на количество итераций. Она
    использует внутреннюю переменную для подсчёта шагов.
  \end{itemize}

  You can specify data types for loop variables (see
  section~\ref{LOOP-TYPES-SECTION}).  It is an error to bind the same
  variable twice in any variable-binding clause of a single loop
  expression. Such variables include local variables, iteration
  control variables, and variables found by destructuring.

  Вы можете указать типы данных для переменных циклы (смотрите
  раздел~\ref{LOOP-TYPES-SECTION}). Связывать переменные два раза в
  одном цикле нельзя. Такие переменные включают локальные переменные,
  переменные для управления циклом и переменные созданные при
  деструктуризации.

\item value accumulation

\item накопление значения

  \begin{itemize}
  \item The \cdf{collect} construct takes one form in its clause and
    adds the value of that form to the end of a list of values.  By
    default, the list of values is returned when the loop finishes.

  \item Конструкция \cdf{collect} принимает одну форму и добавляет
    значение этой формы в конец списка значений. По-умолчанию в конце
    цикла этот список возвращается.

  \item The \cdf{append} construct takes one form in its clause and
    appends the value of that form to the end of a list of values.  By
    default, the list of values is returned when the loop finishes.

  \item Конструкция \cdf{append} принимает одну форму и добавляет
    значение этой формы в конец списка значений. По-умолчанию в конце
    цикла этот список возвращается.

  \item The \cdf{nconc} construct is similar to \cdf{append}, but its
    list values are concatenated as if by the Common Lisp function
    \cdf{nconc}.  By default, the list of values is returned when the
    loop finishes.

  \item Конструкция \cdf{nconc} похожа на \cdf{append}, но список
    соединяется с помощью функции \cdf{nconc}. По-умолчанию в конце
    цикла этот список возвращается.

  \item The \cdf{sum} construct takes one form in its clause that must
    evaluate to a number and adds that number into a running total.
    By default, the cumulative sum is returned when the loop finishes.

  \item Конструкция \cdf{sum} принимает одну форму, которая должна
    вернуть число, и добавляет это число в общую сумму. По-умолчанию
    накопленная сумма возвращается из цикла.

  \item The \cdf{count} construct takes one form in its clause and
    counts the number of times that the form evaluates to a
    non-\cdf{nil} value.  By default, the count is returned when the
    loop finishes.

  \item Конструкция \cdf{count} принимает одну форму и подсчитывает
    сколько раз эта форма вернула не-\cdf{nil} значение. По-умолчанию
    это количество возвращается из цикла.

  \item The \cdf{minimize} construct takes one form in its clause and
    determines the minimum value obtained by evaluating that form.  By
    default, the minimum value is returned when the loop finishes.

  \item Конструкция \cdf{minimize} принимает одну форму и сохраняет
    минимальное значение, которое вернула эта форма. По-умолчанию,
    минимальное значение возвращается из цикла.

  \item The \cdf{maximize} construct takes one form in its clause and
    determines the maximum value obtained by evaluating that form.  By
    default, the maximum value is returned when the loop finishes.

  \item Конструкция \cdf{maximize} принимает одну форму и сохраняет
    максимальное значение, которое вернула эта форма. По-умолчанию,
    максимальное значение возвращается из цикла.
  \end{itemize}

  \item termination conditions

  \item условия для завершения

  \begin{itemize}
  \item The \cdf{loop-finish} Lisp macro terminates iteration and
    returns any accumulated result.  If specified, any \cdf{finally}
    clauses are evaluated.

  \item Lisp'овые макрос \cdf{loop-finish} прекращает цикл и
    возвращает накопленный результат. Вычисляется выражение
    \cdf{finally}, если было указано.

  \item The \cdf{for} and \cdf{as} constructs provide a termination
    test that is determined by the iteration control clause.

  \item Конструкции \cdf{for} и \cdf{as} завершают цикл после
    выполнения указанных условий.

  \item The \cdf{repeat} construct causes termination after a
    specified number of iterations.

  \item Конструкция \cdf{repeat} завершает цикл после выполнения
    указанного количества итераций.

  \item The \cdf{while} construct takes one form, a condition, and
    terminates the iteration if the condition evaluates to \cdf{nil}.
    A \cdf{while} clause is equivalent to the expression
    \cd{(if~(not~\emph{condition}) (loop-finish))}.

  \item Конструкция \cdf{while} принимает одну форму --- условие, и
    завершает цикл когда условие возвращает \cdf{nil}. Выражение
    \cdf{while} эквивалентно \cd{(if~(not~\emph{condition})
      (loop-finish))}.

  \item The \cdf{until} construct is the inverse of \cdf{while}; it
    terminates the iteration if the condition evaluates to any
    non-\cdf{nil} value.  An \cdf{until} clause is equivalent to the
    expression \cd{(if~\emph{condition} (loop-finish))}.

  \item Конструкция \cdf{until} антоним конструкции \cdf{while}. Она
    завершает цикл, когда условие возвращает не-\cdf{nil}
    значение. Выражение \cdf{until} эквивалентно
    \cd{(if~\emph{condition} (loop-finish))}.

  \item The \cdf{always} construct takes one form and terminates the
    loop if the form ever evaluates to \cdf{nil}; in this case, it
    returns \cdf{nil}.  Otherwise, it provides a default return value
    of \cdf{t}.

  \item Конструкция \cdf{always} принимает одну форму и завершает
    цикл, если форма возвращает \cdf{nil}, в этом случае возвращается
    \cdf{nil}. Иначе возвращается результат по-умолчанию \cdf{t}.

  \item The \cdf{never} construct takes one form and terminates the
    loop if the form ever evaluates to non-\cdf{nil}; in this case, it
    returns \cdf{nil}.  Otherwise, it provides a default return value
    of \cdf{t}.

  \item Конструкция \cdf{never} принимает одну форму и завершает
    цикл, если форма возвращает \cdf{nil}, в этом случае возвращается
    \cdf{nil}. Иначе возвращается результат по-умолчанию \cdf{t}.

  \item The \cdf{thereis} construct takes one form and terminates the
    loop if the form ever evaluates to non-\cdf{nil}; in this case, it
    returns that value.

  \item Конструкция \cdf{thereis} принимает одну форму и завершает
    цикле, если форма возвращает не-\cdf{nil}, в этом случае
    возвращается значение формы.
  \end{itemize}

  \item unconditional execution

  \item безусловное выполнение

  \begin{itemize}
  \item The \cdf{do} construct simply evaluates all forms in its
clause.

  \item Конструкция \cdf{do} просто выполняет все переданные формы.

  \item The \cdf{return} construct takes one form and returns its
    value.  It is equivalent to the clause \cd{do (return \emph{value})}.

  \item Конструкция \cdf{return} принимает одну форму и возвращает её
    значение.  Эквивалентное выражение \cd{do (return \emph{value})}.
  \end{itemize}

  \item conditional execution

  \item условное выполнение

  \begin{itemize}
  \item The \cdf{if} construct takes one form as a predicate and a
    clause that is executed when the predicate is true. The clause can
    be a value accumulation, unconditional, or another conditional
    clause; it can also be any combination of such clauses connected
    by the loop keyword \cdf{and}.

  \item Конструкция \cdf{if} принимает форму в качестве предиката и
    выражение, которое выполняется в случае истинности
    предиката. Выражение может быть накоплением значения, безусловным
    или другим условным выражением.

  \item The \cdf{when} construct is a synonym for \cdf{if}.

  \item Конструкция \cdf{when} это синоним для конструкции \cdf{if}.

  \item The \cdf{unless} construct is similar to \cdf{when} except
    that it complements the predicate; it executes the following
    clause if the predicate is false.

  \item Конструкция \cdf{unless} похожа на \cdf{when} кроме того, что
    она выполняет форму при условии что предикат ложен.

  \item The \cdf{else} construct provides an optional component of
    \cdf{if}, \cdf{when}, and \cdf{unless} clauses that is executed
    when the predicate is false.  The component is one of the clauses
    described under \cdf{if}.

  \item Конструкция \cdf{else} содержит компонент, который будет
    выполнен при невыполнении веток \cdf{if}, \cdf{when} и
    \cdf{unless}. 

  \item The \cdf{end} construct provides an optional component to mark
    the end of a conditional clause.

  \item Конструкция \cdf{end} указывает на конец условного выражения.
  \end{itemize}

  \item miscellaneous operations

  \item дополнительные операции

  \begin{itemize}
  \item The \cdf{named} construct assigns a name to a loop construct.


  \item Конструкция \cdf{named} присваивает имя блоку цикла.

  \item The \cdf{initially} construct causes its forms to be evaluated
    in the loop prologue, which precedes all loop code except for
    initial settings specified by the constructs \cdf{with},
    \cdf{for}, or \cdf{as}.

  \item Конструкция \cdf{initially} вычисляет формы в прологе цикла,
    который следует перед телом цикла, но после первоначальных
    связываний в конструкциях \cdf{with}, \cdf{for} и \cdf{as}.

  \item The \cdf{finally} construct causes its forms to be evaluated
    in the loop epilogue after normal iteration terminates.  An
    unconditional clause can also follow the loop keyword
    \cdf{finally}.

  \item Конструкция \cdf{finally} выполняет формы в эпилоге цикла
    после завершения итераций. Кроме того после слова \cdf{finally}
    могут следовать безусловные выражения.
  \end{itemize}
  \end{itemize}


  \subsection{Loop Syntax}

  \subsection{Синтаксис Loop}

  The following syntax description provides an overview of the syntax
for loop clauses.  Detailed syntax descriptions of individual clauses
appear in sections~\ref{LOOP-ITERATION-SECTION}
through~\ref{LOOP-MISC-SECTION}.  A loop consists of the following
types of clauses:

\begin{tabbing} \emph{initial-final\/} ::= \emph{initially\/} {\Mor}
\emph{finally\/} \\* \emph{variables\/} ::= \emph{with\/} {\Mor}
\emph{initial-final\/} {\Mor} \emph{for-as\/} {\Mor} \emph{repeat} \\*
\emph{main\/} ::= \emph{unconditional\/} {\Mor} \emph{accumulation\/}
{\Mor} \emph{conditional\/} {\Mor} \emph{termination\/} {\Mor}
\emph{initial-final\/} \\* \emph{loop\/} ::= \cd{(loop \Mopt{\cd{named
\emph{name\/}}} \Mstar\emph{variables\/} \Mstar\emph{main\/})}
\end{tabbing}

Вот небольшой обзор синтаксиса для выражений цикла. Детальные описания
конкретных подвыражений находятся в разделах начиная
с~\ref{LOOP-ITERATION-SECTION} и
заканчивая~\ref{LOOP-MISC-SECTION}. Цикл содержит следующие типы
выражений:
\begin{tabbing} \emph{initial-final\/} ::= \emph{initially\/} {\Mor}
\emph{finally\/} \\* \emph{variables\/} ::= \emph{with\/} {\Mor}
\emph{initial-final\/} {\Mor} \emph{for-as\/} {\Mor} \emph{repeat} \\*
\emph{main\/} ::= \emph{unconditional\/} {\Mor} \emph{accumulation\/}
{\Mor} \emph{conditional\/} {\Mor} \emph{termination\/} {\Mor}
\emph{initial-final\/} \\* \emph{loop\/} ::= \cd{(loop \Mopt{\cd{named
\emph{name\/}}} \Mstar\emph{variables\/} \Mstar\emph{main\/})}
\end{tabbing}

Note that a loop must have at least one clause; however, for backward
compatibility, the following format is also supported:
\begin{lisp} (loop \Mstar{\emph{tag} {\Mor} \emph{expr}})
\end{lisp} where \emph{expr} is any Common Lisp expression that can be
evaluated, and \emph{tag} is any symbol not identifiable as a loop
keyword.  Such a format is roughly equivalent to the following one:

\begin{lisp} (loop do \Mstar{\emph{tag} {\Mor} \emph{expr}})
\end{lisp}

Заметьте, что цикл должен содержать как минимум одно выражение, однако
для обратной совместимости также поддерживается и следующий формат:
\begin{lisp} (loop \Mstar{\emph{tag} {\Mor} \emph{expr}})
\end{lisp}
где \emph{expr} является любым Common Lisp'овым выражением, которое
может быть вычислено, и \emph{tag} это любой символ не из множества
символов loop. Такой формат примерно эквивалентен следующему:

\begin{lisp} (loop do \Mstar{\emph{tag} {\Mor} \emph{expr}})
\end{lisp}

  A loop prologue consists of any automatic variable initializations
prescribed by the \emph{variable\/} clauses, along with any
\emph{initially\/} clauses in the order they appear in the source.

Пролог состоит из инициализации переменных описанных в соответствующих
выражения, и \cdf{initially} выражений в том порядке, в котором они
были записаны.

  A loop epilogue consists of \emph{finally\/} clauses, if any, along
with any implicit return value from an \emph{accumulation\/} clause or
an \emph{end-test\/} clause.

Эпилог состоит из выражений \cdf{finally} (если они были), и неявного
возврата значения из выражений собирающих результат или из выражений
проверки выхода из цикла.

  \section{User Extensibility}

  There is currently no specified portable method for users to add
extensions to the Loop Facility.  The names \cdf{defloop} and
\cdf{define-loop-method} have been suggested as candidates for such a
method.

\section{Пользовательские расширения}

Пользователю не предоставляется способа расширить функционал Loop.

\section{Loop Constructs}

\section{Конструкции Loop}

The remaining sections of this chapter describe the constructs that
the Loop Facility provides.  The descriptions are organized according
to the functionality of the constructs.  Each section begins with a
general discussion of a particular operation; it then presents the
constructs that perform the operation.

Следующие разделы раскрывают конструкции цикла Loop. Описания
сгруппированы по типам данных конструкций. Каждый раздел начинается с
общего описания конкретной операции, затем раскрывается конструкция,
которая выполняет данную операцию.

\begin{itemize}

\item Section~\ref{LOOP-ITERATION-SECTION}, ``Iteration Control,''
  describes iteration control clauses that allow directed loop
  iteration.

\item Раздел~\ref{LOOP-ITERATION-SECTION}, <<Управление итерациями>>
  описывает выражения для управления итерациями.

\item Section~\ref{LOOP-TEST-SECTION}, ``End-Test Control,'' describes
  clauses that stop iteration by providing a conditional expression
  that can be tested after each execution of the loop body.

\item Раздел~\ref{LOOP-TEST-SECTION}, <<Проверка завершения>>
  описывает выражения, которые прекращают итерации, в случае если того
  требует тестовое выражение, которые выполняется на каждой итерации.

\item Section~\ref{LOOP-ACCUM-SECTION}, ``Value Accumulation,''
  describes constructs that accumulate values during iteration and
  return them from a loop.  This section also discusses ways in which
  accumulation clauses can be combined within the Loop Facility.

\item Раздел~\ref{LOOP-ACCUM-SECTION}, <<Накопление значения>>
  описывает конструкции, которые накапливают значение во время
  итераций и возвращают их из цикла. Данный раздел также содержит
  методы комбинирования данных выражений с другим функционалом.

\item Section~\ref{LOOP-VAR-SECTION}, ``Variable Initializations,''
  describes the \cdf{with} construct, which provides local variables
  for use within the loop body, and other constructs that provide
  local variables.

\item Раздел~\ref{LOOP-VAR-SECTION}, <<Инициализация переменных>>
  описывает конструкцию \cdf{with}, которая позволяет создавать
  локальные переменные для использования в теле цикла, а также другие
  конструкции, которые создают локальные переменные.

\item Section~\ref{LOOP-COND-SECTION}, ``Conditional Execution,''
  describes how to execute loop clauses conditionally.

\item Раздел~\ref{LOOP-COND-SECTION}, <<Условное выполнение>>
  описывает то, как выполнять выражения цикла в зависимости от
  условия.

\item Section~\ref{LOOP-UNCOND-SECTION}, ``Unconditional Execution,''
  describes the \cdf{do} and \cdf{return} constructs.  It also
  describes constructs that are used in the loop prologue and loop
  epilogue.

\item Раздел~\ref{LOOP-UNCOND-SECTION}, <<Безусловное выполнение>>
  описывает конструкции \cdf{do} и \cdf{return}. Раздел также содержит
  информацию о прологе и эпилоге цикла Loop.

\item Section~\ref{LOOP-MISC-SECTION}, ``Miscellaneous Features,''
  discusses loop data types and destructuring.  It also presents
  constructs for naming a loop and for specifying initial and final
  actions.

\item Раздел~\ref{LOOP-MISC-SECTION} <<Дополнительные возможности>>
  описывает типы данных и деструктуризацию в контексте цикла
  loop. Раздел также содержит информацию о задании имени цикла и
  прологе и эпилоге.
\end{itemize}


\section{Iteration Control}
\label{LOOP-ITERATION-SECTION}

\section{Управление итерациями}
\label{LOOP-ITERATION-SECTION}

Iteration control clauses allow you to direct loop iteration.  The
loop keywords \cdf{as}, \cdf{for}, and \cdf{repeat} designate iteration control clauses.

Для управления итерациями используются выражения \cdf{as}, \cdf{for} и \cdf{repeat}.

Iteration control clauses differ with respect to the specification of
termination conditions and the initialization and stepping
of loop variables.  Iteration clauses by themselves
do not cause the Loop Facility to return values, but they
can be used in conjunction with value-accumulation clauses to
return values (see section~\ref{LOOP-ACCUM-SECTION}).

Управление итерациями отличается от условий завершения цикла и
инициализации и наращивания переменных цикла. Управление итерациями
само по себе не выполняет возврат значение, но оно может
использоваться в сочетании с выражениями накопления значения для
возврата значений (смотрите раздел~\ref{LOOP-ACCUM-SECTION}).

All variables are initialized in the loop prologue.  The scope of
the variable binding is \emph{lexical} unless it is proclaimed
special; thus, the variable can be
accessed only by expressions that lie textually within the loop.
Stepping assignments are made in the loop body before any other expressions
are evaluated in the body.

Все переменные инициализируются в прологе цикла. Область видимости
переменных \emph{лексическая}, если только они не объявлены как
\emph{специальные}. Таким образом переменные доступны только в
выражениях, которые текстово находятся в цикле. Наращивание переменных
выполняется в теле цикла перед другими выражениями.

The variable argument in iteration control clauses can be a 
\emph{destructuring list}.  A destructuring list
is a tree whose non-null atoms are symbols that
can be assigned a value (see section~\ref{LOOP-DESTRUCTURING-SECTION}).

На месте переменное может стоять \emph{список переменных для
  деструктуризации}. Данный список представляет из себя дерево, в
котором не-null атомы это символы, которые могут быть связаны со
значениями (смотрите раздел~\ref{LOOP-DESTRUCTURING-SECTION}).

The iteration control clauses \cdf{for}, \cdf{as}, and \cdf{repeat} 
must precede any other loop clauses except
\cdf{initially}, \cdf{with}, and \cdf{named},
since they establish variable bindings.  When iteration control clauses are
used in a loop, termination tests in the loop body are evaluated
before any other loop body code is executed.

Выражения для управления итерациями \cdf{for}, \cdf{as} и \cdf{repeat}
должны быть указаны прежде других выражений за исключением
\cdf{initially}, \cdf{with} и \cdf{named}, так как последние служат
для создания переменных. При использовании выражений управления
итерациями, проверка завершения выполняется перед самим телом цикла.

If you use multiple iteration clauses to control iteration, variable
initialization and stepping occur sequentially by default.  
You can use the \cdf{and} construct to connect two or more
iteration clauses when sequential binding and stepping are not necessary.
The iteration behavior of clauses joined by \cdf{and}
is analogous to the behavior of the Common Lisp macro \cdf{do}
relative to \cdf{do*}.

Если вы используете несколько выражений для управления итерациями,
по-умолчанию связывания и наращивания переменных выполняются
последовательно. Если последовательное выполнение необязательно, вы
можете объединить выражения с помощью конструкции \cdf{and}.  Различия
при неиспользовании и использовании конструкции \cdf{and} аналогичны
различиям между \cdf{do} и \cdf{do*}

In the following example, the variable \cdf{x} is stepped
before \cdf{y} is stepped; thus, the value of \cdf{y}
reflects the updated value of \cdf{x}:
\begin{lisp}
(loop for x from 1 to 9 \\*
~~~~~~for y = nil then x  \\*
~~~~~~collect (list x y)) \\*
~~~\EV~((1 NIL) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9))
\end{lisp}

In the following example, \cdf{x} and \cdf{y} are stepped in parallel:
\begin{lisp}
(loop for x from 1 to 9 \\*
~~~~~~and y = nil then x \\*
~~~~~~collect (list x y)) \\*
~~~\EV~((1 NIL) (2 1) (3 2) (4 3) (5 4) (6 5) (7 6) (8 7) (9 8))
\end{lisp}

В следующем примере переменная \cdf{x} наращивается прежде чем
\cdf{y}, таким образом \cdf{y} содержит новое значение \cdf{x}.
\begin{lisp}
(loop for x from 1 to 9 \\*
~~~~~~for y = nil then x  \\*
~~~~~~collect (list x y)) \\*
~~~\EV~((1 NIL) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9))
\end{lisp}

В следующем примере переменные \cdf{x} и \cdf{y} наращиваются
параллельно:
\begin{lisp}
(loop for x from 1 to 9 \\*
~~~~~~and y = nil then x \\*
~~~~~~collect (list x y)) \\*
~~~\EV~((1 NIL) (2 1) (3 2) (4 3) (5 4) (6 5) (7 6) (8 7) (9 8))
\end{lisp}

The \cdf{for} and \cdf{as} clauses iterate by using one or more local 
loop variables that are initialized to some value and that 
can be modified or stepped after each iteration.  
For these clauses, iteration terminates when a local
variable reaches some specified value or when some other loop clause
terminates iteration.  At each iteration, variables can be stepped by an
increment or a decrement or can be assigned a new value by 
the evaluation of 
an expression.  Destructuring can be used to assign initial values to 
variables during iteration.

Выражения \cdf{for} и \cdf{as} выполняют тело цикла для одной или
нескольких переменных, которые вначале инициализируются некоторым
значением, затем наращиваются после каждой итерации.  Для этих
выражений цикл завершается после того, как локальная переменная
достигает последнего указанного значения, или срабатывает какое-либо
другое завершающее выражение. На каждой итерации переменная может быть
увеличена, уменьшена, или ей может быть связана с значением некоторого
выражения. Для присваивания первоначальных значений может
использоваться деструктуризация.

The \cdf{for} and \cdf{as} keywords are synonyms and may be used
interchangeably.  There are
seven syntactic representations for these constructs.
In each syntactic description, the data type of
\emph{var\/} can be specified by the optional \emph{type-spec\/}
argument.  If \emph{var\/} is a destructuring list, the data type
specified by the \emph{type-spec\/} argument must appropriately match
the elements of the list (see sections~\ref{LOOP-TYPES-SECTION}
and~\ref{LOOP-DESTRUCTURING-SECTION}).

Ключевые символы \cdf{for} и \cdf{as} являются синонимами,
соответственно взаимозаменяемы. Для этих конструкций существует семь
синтаксических представлений. В каждой из них для переменной
\emph{var} опционально можно задать тип \emph{type-spec}. Если
\emph{var} является списком для деструктуризации, \emph{type-spec}
должен соответственно описывать элементы списка (смотрите
разделы~\ref{LOOP-TYPES-SECTION} и~\ref{LOOP-DESTRUCTURING-SECTION})

\begin{defloop}
for var [type-spec] [{\!from! | \!downfrom! | \!upfrom!} expr1]
                    [{\!to! | \!downto! | \!upto! | \!below! | \!above!} expr2]
                    [\!by! expr3] \\
as var [type-spec] [{\!from! | \!downfrom! | \!upfrom!} expr1]
                   [{\!to! | \!downto! | \!upto! | \!below! | \!above!} expr2]
                   [\!by! expr3]

[This is the first of seven \cdf{for}/\cdf{as} syntaxes.---GLS]

The \cdf{for} or \cdf{as} construct iterates from the value specified by
\emph{expr1\/} to the value specified by \emph{expr2\/} in increments or
decrements denoted by \emph{expr3}. Each
expression is evaluated only once and must evaluate to a number.  

The variable \emph{var\/} is bound to the value of 
\emph{expr1\/} in the first iteration and is stepped
by the value of \emph{expr3\/} in each succeeding iteration,
or by 1 if \emph{expr3\/} is not provided.  

The following loop keywords serve as valid prepositions within this 
syntax.

\begin{flushdesc}
\item[\cdf{from}]
The loop keyword \cdf{from} marks the value from which
stepping begins, as specified by \emph{expr1}.  
Stepping is incremental by default.  For
decremental stepping, use \cdf{above}
or \cdf{downto} with \emph{expr2}.  For incremental
stepping, the default \cdf{from} value is \cd{0}.

\item[\cdf{downfrom}, \cdf{upfrom}]
The loop keyword \cdf{downfrom} 
indicates that the variable \emph{var\/} is decreased in decrements
specified by \emph{expr3}; the loop keyword \cdf{upfrom} indicates that 
\emph{var\/} is increased in increments specified by \emph{expr3}.

\item[\cdf{to}]
The loop keyword \cdf{to} marks the end value for stepping specified in 
\emph{expr2}. Stepping is incremental by default.  For
decremental stepping, use \cdf{downto},
\cdf{downfrom}, or \cdf{above} with \emph{expr2}.

\item[\cdf{downto}, \cdf{upto}]
The loop keyword \cdf{downto} allows iteration to proceed
from a larger number to a smaller number by the decrement 
\emph{expr3}.  The loop keyword \cdf{upto} allows iteration to proceed
from a smaller number to a larger number by the increment \emph{expr3}.
Since there is no default for \emph{expr1\/} in decremental stepping,
you must supply a value with \cdf{downto}.

\item[\cdf{below}, \cdf{above}]
The loop keywords \cdf{below} and \cdf{above} are analogous to
\cdf{upto} and \cdf{downto}, respectively.  These keywords stop
iteration just before the value of the variable \emph{var} reaches the value 
specified by \emph{expr2\/}; the end value of \emph{expr2\/} is not included.
Since there is no default for \emph{expr1\/} in decremental stepping,
you must supply a value with \cdf{above}.

\item[\cdf{by}]
The loop keyword \cdf{by} marks the increment or decrement specified by
\emph{expr3}.  The value of \emph{expr3\/} can be any positive number.
The default value is \cd{1}.
\end{flushdesc}

At least one of these prepositions must be used with this syntax.

In an iteration control clause, the \cdf{for} or \cdf{as} construct
causes termination when the specified limit is reached.  That is,
iteration continues until the value \emph{var\/} is stepped to the
exclusive or inclusive limit specified by \emph{expr2\/}.  The range is
\emph{exclusive\/} if \emph{expr3\/} increases or decreases \emph{var\/}
to the value of \emph{expr2\/} without reaching that value; the loop
keywords \cdf{below} and \cdf{above} provide exclusive limits.  An
\emph{inclusive\/} limit allows \emph{var\/} to attain the value of
\emph{expr2}; \cdf{to}, \cdf{downto}, and \cdf{upto} provide inclusive
limits.

A common convention is to use \cdf{for} to introduce new iterations and \cdf{as}
to introduce iterations that depend on a previous iteration specification.
[However, \cdf{loop} does not enforce this convention, and some of the examples
below violate it.  \emph{De gustibus non disputandum est.}---GLS]

Examples:
\begin{lisp}
;;; Print some numbers. \\[3pt]
(loop as i from 1 to 5 \\*
~~~~~~do (print i)) \`;\textrm{Prints 5 lines} \\
1 \\*
2 \\*
3 \\*
4 \\*
5 \\*
~~~\EV~NIL \\
 \\
;;; Print every third number. \\[3pt]
(loop for i from 10 downto 1 by 3 \\*
~~~~~~do (print i)) \`;\textrm{Prints 4 lines}\\
10  \\*
7  \\*
4  \\*
1  \\*
~~~\EV~NIL
\end{lisp}

\begin{lisp}
;;; Step incrementally from the default starting value. \\[3pt]
(loop as i below 5 \\*
~~~~~~do (print i)) \`;\textrm{Prints 5 lines} \\
0 \\*
1 \\*
2 \\*
3 \\*
4 \\*
~~~\EV~NIL
\end{lisp}
\end{defloop}

\begin{defloop}
for var [type-spec] \!in! expr1 [\!by! step-fun] \\
as var [type-spec] \!in! expr1 [\!by! step-fun]

[This is the second of seven \cdf{for}/\cdf{as} syntaxes.---GLS]

This construct iterates over the contents of a list.  It checks for 
the end of the list as if using the Common Lisp function \cdf{endp}.  
The variable \emph{var\/} is bound to the successive elements  of 
the list \emph{expr1\/} before each
iteration.  At the end of each iteration, the function \emph{step-fun\/}
is called on the list and is expected to produce a successor list;
the default value for \emph{step-fun\/} is the \cdf{cdr} function.

The \cdf{for} or \cdf{as} construct causes termination when the
end of the list is reached.
The loop keywords \cdf{in} and \cdf{by} serve as valid prepositions in
this syntax.

Examples:
\begin{lisp}
;;; Print every item in a list. \\[3pt]
(loop for item in '(1 2 3 4 5) do (print item)) \`;\textrm{Prints 5 lines} \\
1 \\*
2 \\*
3 \\*
4 \\*
5 \\*
~~~\EV~NIL \\
 \\
;;; Print every other item in a list. \\[3pt]
(loop for item in '(1 2 3 4 5) by \#'cddr \\*
~~~~~~do (print item))  \`;\textrm{Prints 3 lines} \\
1 \\*
3 \\*
5 \\*
~~~\EV~NIL
\end{lisp}
\begin{lisp}
;;; Destructure items of a list, and sum the x values \\*
;;; using fixnum arithmetic. \\*
(loop for (item . x) (t . fixnum) \\*
~~~~~~~~~~in '((A . 1) (B . 2) (C . 3)) \\*
~~~~~~unless (eq item 'B) sum x) \\*
~~~\EV~4
\end{lisp}
\end{defloop}

\begin{defloop}
for var [type-spec] on expr1 [by step-fun] \\
as var [type-spec] on expr1 [by step-fun]

[This is the third of seven \cdf{for}/\cdf{as} syntaxes.---GLS]

This construct iterates over the contents of a list. It checks for the
end of the list as if using the Common Lisp function 
\cdf{endp}.  
The variable \emph{var\/} is bound to the successive tails of the list
\emph{expr1}.  At the end of each iteration, the function \emph{step-fun\/}
is called on the list and is expected to produce a successor list;
the default value for \emph{step-fun\/} is the \cdf{cdr} function.

The loop keywords \cdf{on} and \cdf{by} serve as valid
prepositions in this syntax.
The \cdf{for} or \cdf{as} construct causes termination when the
end of the list is reached.

Examples:
\begin{lisp}
;;; Collect successive tails of a list. \\*
(loop for sublist on '(a b c d) \\*
~~~~~~collect sublist) \\*
~~~\EV~((A B C D) (B C D) (C D) (D)) \\
 \\
;;; Print a list by using destructuring with the loop keyword ON. \\*
(loop for (item) on '(1 2 3) \\*
~~~~~~do (print item))  \`;\textrm{Prints 3 lines}\\
1  \\*
2  \\*
3  \\*
~~~\EV~NIL \\
 \\
;;; Print items in a list without using destructuring. \\*
(loop for item in '(1 2 3) \\*
~~~~~~do (print item))  \`;\textrm{Prints 3 lines}\\
1  \\*
2  \\*
3  \\*
~~~\EV~NIL
\end{lisp}
\end{defloop}

\begin{defloop}
for var [type-spec] \!\Xequal! expr1 [\!then! expr2] \\
as var [type-spec] \!\Xequal! expr1 [\!then! expr2]

[This is the fourth of seven \cdf{for}/\cdf{as} syntaxes.---GLS]


  This construct initializes the variable \emph{var\/} by setting it to the
  result of evaluating \emph{expr1\/} on the first iteration, then setting
  it to the result of evaluating \emph{expr2\/} on the second and
  subsequent iterations.  If \emph{expr2\/} is omitted, the construct
  uses \emph{expr1\/} on the second and
  subsequent iterations.  When \emph{expr2\/} is omitted, the expanded
  code shows the following optimization:

\begin{lisp}
;;; Sample original code: \\*
(loop for x = \emph{expr1\/} then \emph{expr2\/} do (print x))
\end{lisp}
\begin{lisp}
;;; The usual expansion: \\*
(tagbody \\*
~~~~~~(setq x \emph{expr1\/}) \\*
~~tag (print x) \\*
~~~~~~(setq x \emph{expr2\/}) \\*
~~~~~~(go tag))
\end{lisp}
\begin{lisp}
;;; The optimized expansion: \\*
(tagbody \\*
~~tag (setq x \emph{expr1\/}) \\*
~~~~~~(print x) \\*
~~~~~~(go tag))
\end{lisp}

The loop keywords \cdf{=} and  \cdf{then} serve as valid prepositions
in this syntax.
This construct does not provide any termination conditions.

Example:
\begin{lisp}
;;; Collect some numbers. \\*
(loop for item = 1 then (+ item 10) \\*
~~~~~~repeat 5 \\*
~~~~~~collect item) \\*
~~~\EV~(1 11 21 31 41)
\end{lisp}
\end{defloop}


\begin{defloop}
for var [type-spec] across vector \\
as var [type-spec] across vector

[This is the fifth of seven \cdf{for}/\cdf{as} syntaxes.---GLS]

    This construct binds the variable \emph{var\/} to
    the value of each element in the array \emph{vector}.

  The loop keyword \cdf{across} marks the array \emph{vector}; \cdf{across}
  is used as a preposition in this syntax.
  Iteration stops when there are no more elements in the specified
  array that can be referenced.

  Some implementations might use a [user-supplied---GLS] \cdf{the} special operator
  in the \emph{vector} form to produce more efficient code.

  Example:
\begin{lisp}
(loop for char across (the simple-string (find-message port)) \\*
~~~~~~do (write-char char stream))
\end{lisp}
\end{defloop}

\begin{defloop}
for var [type-spec] \!being! {\!each! | \!the!}
                    {\!hash-key! | \!hash-keys! | \!hash-value! | \!hash-values!}
                    {\!in! | \!of!} hash-table [\!using! ({\!hash-value! | \!hash-key!} other-var)] \\
as var [type-spec] \!being! {\!each! | \!the!}
                    {\!hash-key! | \!hash-keys! | \!hash-value! | \!hash-values!}
                    {\!in! | \!of!} hash-table [\!using! ({\!hash-value! | \!hash-key!} other-var)]

[This is the sixth of seven \cdf{for}/\cdf{as} syntaxes.---GLS]

This construct iterates over the elements, keys, and values of a hash
table.  The variable \emph{var\/} takes on the value of each hash key
or hash value in the specified hash table. 

The following loop keywords serve as valid prepositions within this syntax.

\begin{flushdesc}
\item[\cdf{being}]
The keyword \cdf{being} marks the loop method to be used, either 
\cdf{hash-key} or \cdf{hash-value}.

\item[\cdf{each}, \cdf{the}]
For purposes of readability, the loop keyword \cdf{each}
should follow the loop keyword \cdf{being} when \cdf{hash-key} or
\cdf{hash-value} is used.  The loop keyword \cdf{the} is used with
\cdf{hash-keys} and \cdf{hash-values}.

\item[\cdf{hash-key}, \cdf{hash-keys}]
These loop keywords access each key entry of the hash table.  If
the name \cdf{hash-value} is specified in a \cdf{using} construct with one
of these loop methods, the iteration can optionally access the keyed
value. The order in which the keys are accessed is undefined; empty
slots in the hash table are ignored.

\item[\cdf{hash-value}, \cdf{hash-values}]
These loop keywords access each value entry of a hash table.  If
the name \cdf{hash-key} is specified in a \cdf{using} construct with one of
these loop methods, the iteration can optionally access the key that
corresponds to the value.  The order in which the keys are accessed is
undefined; empty slots in the hash table are ignored.

\item[\cdf{using}]
The loop keyword \cdf{using} marks the optional key or the keyed value to
be accessed.  It allows you to access the hash key if
iterating over the hash values, and the hash value if
iterating over the hash keys.

\item[\cdf{in}, \cdf{of}]
These loop prepositions mark the hash table \emph{hash-table}.
\end{flushdesc}

Iteration stops when there are no more hash keys or hash values to be
referenced in the specified hash table.
\end{defloop}


\begin{defloop}
for var [type-spec] \!being! {\!each! | \!the!}
                    {\!symbol! | \!present-symbol! | \!external-symbol! |
                     \!symbols! | \!present-symbols! | \!external-symbols!}
                    {\!in! | \!of!} package \\
as var [type-spec] \!being! {\!each! | \!the!}
                    {\!symbol! | \!present-symbol! | \!external-symbol! |
                     \!symbols! | \!present-symbols! | \!external-symbols!}
                    {\!in! | \!of!} package

[This is the last of seven \cdf{for}/\cdf{as} syntaxes.---GLS]


This construct iterates over the symbols in a package.
The variable \emph{var\/} takes on the value of each symbol
in the specified package.  

The following loop keywords serve as valid prepositions within this syntax.

\begin{flushdesc}

\item[\cdf{being}]
The keyword \cdf{being} marks the loop method to be used:
\cdf{symbol}, \cd{present-\discretionary{}{}{}symbol},  or \cdf{external-symbol}.

\item[\cdf{each}, \cdf{the}]
For purposes of readability, the loop keyword \cdf{each}
should follow the loop keyword \cdf{being} when \cdf{symbol}, 
\cdf{present-symbol}, or \cdf{external-symbol} is used.  The loop keyword
\cdf{the} is used with \cdf{symbols}, \cdf{present-symbols}, and 
\cdf{external-symbols}.

\item[\cdf{present-symbol}, \cdf{present-symbols}]
These loop methods iterate over the symbols that are present but not
external in a package.
The package to be iterated over is
specified in the same way that package arguments to the Common Lisp function
\cdf{find-package} are specified.  If you do not specify the package 
for the iteration, the current package is used.  If you specify a 
package that does not exist, an error is signaled.

\item[\cdf{symbol}, \cdf{symbols}]
These loop methods iterate over symbols that are
accessible from a given package.  The package to be iterated over is specified
in the same way that package arguments to the Common Lisp function
\cdf{find-package} are specified.  If you do not specify the package 
for the iteration, the current package is used.  If you specify a 
package that does not exist, an error is signaled.

\item[\cdf{external-symbol}, \cdf{external-symbols}]
These loop methods iterate over the external symbols of a package.
The package to be iterated over is specified in
the same way that package arguments to the Common Lisp function
\cdf{find-package} are specified.  If you do not specify the package 
for the iteration, the current package is used.  If you specify a 
package that does not exist, an error is signaled.

\item[\cdf{in}, \cdf{of}]
These loop prepositions mark the package \emph{package}.
\end{flushdesc}

Iteration stops when there are no more symbols to be referenced in the
specified package.

Example:
\begin{lisp}
(loop for x being each present-symbol of "COMMON-LISP-USER"  \\*
~~~~~~do (print x)) \`;\textrm{Prints 7 lines in this example}\\*
COMMON-LISP-USER::IN  \\*
COMMON-LISP-USER::X  \\
COMMON-LISP-USER::ALWAYS  \\
COMMON-LISP-USER::FOO  \\
COMMON-LISP-USER::Y  \\
COMMON-LISP-USER::FOR  \\*
COMMON-LISP-USER::LUCID  \\*
~~~\EV~NIL
\end{lisp}
\end{defloop}



\begin{defloop}
repeat expr

The \cdf{repeat} construct causes iteration to terminate after a
specified number of times.
The loop body is executed \emph{n} times, where \emph{n} is the value 
of the expression \emph{expr}.  The \emph{expr} argument is evaluated one time
in the loop prologue.  If the expression evaluates to zero or 
to a negative number, the loop body is not evaluated.

Конструкция \cdf{repeat} завершает цикл после указанного количества
итераций.  Тело цикла выполняется \emph{n} раз, где \emph{n} является
значением выражения \emph{expr}. Аргумент \emph{expr} вычисляется
единожды в прологе цикла. Если выражение возвращает ноль или
отрицательное число, тело цикла не выполняется.

The clause \cdf{repeat} \emph{n} is roughly equivalent to a clause
such as
\begin{lisp}
for \emph{internal-variable} downfrom (- \emph{n} 1) to 0
\end{lisp}
but, in some implementations, the \cdf{repeat} construct might be more
efficient.

Выражение \cdf{repeat} \emph{n} примерно похоже на выражение
\begin{lisp}
for \emph{internal-variable} downfrom (- \emph{n} 1) to 0
\end{lisp}
но на некоторых реализациях \cdf{repeat} может быть более эффективна.

Examples:
\begin{lisp}
(loop repeat 3 \`;\textrm{Prints 3 lines}\\*
~~~~~~do (format t "What I say three times is true{\Xtilde}\%")) \\*
What I say three times is true \\*
What I say three times is true \\*
What I say three times is true \\*
~~~\EV~NIL \\
 \\
(loop repeat -15 \`;\textrm{Prints nothing}\\*
~~~~~~do (format t "What you see is what you expect{\Xtilde}\%")) \\*
~~~\EV~NIL
\end{lisp}

Примеры:
\begin{lisp}
(loop repeat 3 \`;\textrm{Напечатает 3 строки}\\*
~~~~~~do (format t "То, что я скажу три раза является истиной{\Xtilde}\%")) \\*
То, что я скажу три раза является истиной \\*
То, что я скажу три раза является истиной \\*
То, что я скажу три раза является истиной \\*
~~~\EV~NIL \\
 \\
(loop repeat -15 \`;\textrm{Ничего не напечатает}\\*
~~~~~~do (format t "То что вы видите, это то, что вы ожидаете{\Xtilde}\%")) \\*
~~~\EV~NIL
\end{lisp}
\end{defloop}


\section{End-Test Control}
\label{LOOP-TEST-SECTION}

\section{Проверка завершения}
\label{LOOP-TEST-SECTION}

The loop keywords \cdf{always}, \cdf{never}, \cdf{thereis},
\cdf{until}, and \cdf{while} designate constructs that use a single test 
condition to determine when loop iteration should terminate.

Ключевые символы \cdf{always}, \cdf{never}, \cdf{thereis}, \cdf{until}
и \cdf{while} обозначают конструкции, которые с помощью условия
проверяют должен ли быть завершён цикл.

The constructs \cdf{always}, \cdf{never}, and \cdf{thereis} provide
specific values to be returned when a loop terminates.  
Using \cdf{always}, \cdf{never}, or \cdf{thereis} with 
value-returning accumulation clauses can produce unpredictable results.
In all other respects these
constructs behave like the \cdf{while} and \cdf{until} constructs.

The macro \cdf{loop-finish} can be used at any time to cause normal
termination.  In normal termination, \cdf{finally} clauses are 
executed and default return values are returned.

End-test control constructs can be used anywhere within the loop
body.  The termination conditions are tested in the order in which
they appear.

\begin{defloop}
while expr \\
until expr

The \cdf{while} construct allows iteration to continue until the specified
expression \emph{expr} evaluates to \cdf{nil}.  The expression
is re-evaluated at the location of the \cdf{while} clause.

The \cdf{until} construct is equivalent to 
{\cdf{while} (\cdf{not} \emph{expr})}.  If the value of the
specified expression is non-\cdf{nil}, iteration terminates.

You can use \cdf{while} and \cdf{until} 
at any point in a loop.  If a \cdf{while} or \cdf{until} clause causes
termination, any clauses that precede it in the source
are still evaluated.  

Examples:
\begin{lisp}
;;; A classic "while-loop". \\
(loop while (hungry-p) do (eat)) \\
 \\
;;; UNTIL NOT is equivalent to WHILE. \\*
(loop until (not (hungry-p)) do (eat)) \\
 \\
;;; Collect the length and the items of STACK. \\*
(let ((stack '(a b c d e f))) \\*
~~(loop while stack \\*
~~~~~~~~for item = (length stack) then (pop stack) \\*
~~~~~~~~collect item)) \\*
~~~\EV~(6 A B C D E F) \\
 \\
;;; Use WHILE to terminate a loop that otherwise wouldn't \\*
;;; terminate.  Note that WHILE occurs after the WHEN. \\*
(loop for i fixnum from 3 \\*
~~~~~~when (oddp i) collect i \\*
~~~~~~while (< i 5)) \\*
~~~\EV~(3 5)
\end{lisp}
\end{defloop}


\begin{defloop}
always expr \\
never expr \\
thereis expr

The \cdf{always} construct takes one form and terminates the loop if
the form ever evaluates to \cdf{nil}; in this case, it returns
\cdf{nil}.  Otherwise, it provides a default return value of \cdf{t}.

The \cdf{never} construct takes one form and terminates the loop if
the form ever evaluates to non-\cdf{nil}; in this case, it returns
\cdf{nil}.  Otherwise, it provides a default return value of \cdf{t}.

The \cdf{thereis} construct takes one form and terminates the loop if
the form ever evaluates to non-\cdf{nil}; in this case, it returns
that value.

If the \cdf{while} or \cdf{until} construct causes termination,
control is passed to the loop epilogue, where any \cdf{finally}
clauses will be executed.  Since \cdf{always}, \cdf{never}, and 
\cdf{thereis} use the Common Lisp macro \cdf{return} to terminate
iteration, any \cdf{finally} clause that is specified is not
evaluated.

Examples:
\begin{lisp}
;;; Make sure I is always less than 11 (two ways). \\*
;;; The FOR construct terminates these loops.
\end{lisp}
\begin{lisp}
(loop for i from 0 to 10 \\*
~~~~~~always (< i 11)) \\*
~~~\EV~T
\end{lisp}
\begin{lisp}
(loop for i from 0 to 10 \\*
~~~~~~never (> i 11)) \\*
~~~\EV~T
\end{lisp}
\begin{lisp}
;;; If I exceeds 10, return I; otherwise, return NIL. \\*
;;; The THEREIS construct terminates this loop.
\end{lisp}
\begin{lisp}
(loop for i from 0 \\*
~~~~~~thereis (when (> i 10) i) ) \\*
~~~\EV~11
\end{lisp}
\begin{lisp}
;;; The FINALLY clause is not evaluated in these examples.
\end{lisp}
\begin{lisp}
(loop for i from 0 to 10 \\*
~~~~~~always (< i 9) \\*
~~~~~~finally (print "you won't see this")) \\*
~~~\EV~NIL
\end{lisp}
\begin{lisp}
(loop never t \\*
~~~~~~finally (print "you won't see this")) \\*
~~~\EV~NIL
\end{lisp}
\begin{lisp}
(loop thereis "Here is my value" \\*
~~~~~~finally (print "you won't see this")) \\*
~~~\EV~"Here is my value"
\end{lisp}
\begin{lisp}
;;; The FOR construct terminates this loop, \\*
;;; so the FINALLY clause is evaluated.
\end{lisp}
\begin{lisp}
(loop for i from 1 to 10 \\*
~~~~~~thereis (> i 11) \\*
~~~~~~finally (print i)) \`;\textrm{Prints 1 line}\\*
11 \\*
~~~\EV~NIL
\end{lisp}
\goodbreak
\begin{lisp}
(defstruct mountain height difficulty (why "because it is there")) \\*
(setq everest (make-mountain :height '(2.86e-13 parsecs))) \\*
(setq chocorua (make-mountain :height '(1059180001 microns))) \\*
(defstruct desert area (humidity 0)) \\*
(setq sahara (make-desert :area '(212480000 square furlongs))) \\
\`;\textrm{First there is a mountain, then there is no mountain, then there is $\ldots$} \\
(loop for x in (list everest sahara chocorua) \`;~\textrm{---GLS} \\*
~~~~~~thereis (and (mountain-p x) (mountain-height x))) \\*
~~~\EV~(2.86E-13 PARSECS) \\
 \\
;;; If you could use this code to find a counterexample to \\*
;;; Fermat's last theorem, it would still not return the value \\*
;;; of the counterexample because all of the THEREIS clauses \\*
;;; in this example return only T.~~ Of course, this code has \\*
;;; never been observed to terminate. \\*
 \\*
(loop for z upfrom 2 \\*
~~~~~~thereis \\*
~~~~~~~~(loop for n upfrom 3 below (log z 2) \\*
~~~~~~~~~~~~~~thereis \\*
~~~~~~~~~~~~~~~~(loop for x below z \\*
~~~~~~~~~~~~~~~~~~~~~~thereis \\*
~~~~~~~~~~~~~~~~~~~~~~~~(loop for y below z \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~thereis (= (+ (expt x n) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(expt y n)) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(expt z n))))))
\end{lisp}
\end{defloop}

\begin{defmac}
loop-finish \!!

The macro \cdf{loop-finish} terminates iteration normally
and returns any accumulated result.  If specified, a \cdf{finally} clause
is evaluated.

In most cases it is not necessary to use \cdf{loop-finish}
because other loop control clauses terminate the loop.  
Use \cdf{loop-finish} to provide a normal exit
from a nested condition inside a loop.

You can use \cdf{loop-finish}
inside nested Lisp code to provide a normal exit from a loop.
Since \cdf{loop-finish} transfers control to the loop epilogue,
using \cdf{loop-finish} within a \cdf{finally} expression can cause
infinite looping.

Implementations are allowed to provide this construct as a local macro
by using \cdf{macrolet}.

Examples:
\begin{lisp}
;;; Print a date in February, but exclude leap day. \\*
;;; LOOP-FINISH exits from the nested condition. \\*
(loop for date in date-list \\*
~~~~~~do (case date \\*
~~~~~~~~~~~(29 (when (eq month 'february) \\*
~~~~~~~~~~~~~~~~~~~~~(loop-finish)) \\*
~~~~~~~~~~~~~(format t "{\Xtilde}:@({\Xtilde}A{\Xtilde}) {\Xtilde}A" month date)))) \\
 \\
;;; Terminate the loop, but return the accumulated count. \\*
(loop for i in '(1 2 3 stop-here 4 5 6) \\*
~~~~~~when (symbolp i) do (loop-finish) \\*
~~~~~~count i) \\*
~~~\EV~3 \\
 \\
;;; This loop works just as well as the previous example. \\*
(loop for i in '(1 2 3 stop-here 4 5 6) \\*
~~~~~~until (symbolp i) \\*
~~~~~~count i) \\*
~~~\EV~3
\end{lisp}
\end{defmac}

\section{Value Accumulation}
\label{LOOP-ACCUM-SECTION}

Accumulating values during iteration and returning them from a loop
is often useful.  Some of these accumulations occur so
frequently that special loop clauses have been developed to handle them.

The loop keywords \cdf{append}, \cdf{appending},
\cdf{collect}, \cdf{collecting},
\cdf{nconc}, and \cdf{nconcing}
designate clauses that
accumulate values in lists and return them.

The loop keywords \cdf{count}, \cdf{counting},
\cdf{maximize}, \cdf{maximizing},
\cdf{minimize}, \cdf{minimizing},
\cdf{sum}, and \cdf{summing}
designate clauses that accumulate and
return numerical values.
[There is no semantic difference between the ``ing'' keywords and their non-``ing''
counterparts.  They are provided purely for the sake of stylistic diversity among users.
I happen to prefer the non-``ing'' forms---when I use \cdf{loop} at all.---GLS]

The loop preposition \cdf{into} can be used to name the 
variable used to hold partial accumulations.
The variable is bound as if by the loop
construct \cdf{with} (see section~\ref{LOOP-VAR-SECTION}).  If 
\cdf{into} is used, the construct does not provide a default return value;
however, the variable is available
for use in any \cdf{finally} clause.

You can combine value-returning accumulation clauses in a loop if
all the clauses accumulate the same type of data object.  
By default, the Loop Facility returns only one value;
thus, the data objects collected by multiple accumulation clauses 
as return values must have compatible types. For example, since both
the \cdf{collect} and \cdf{append} constructs accumulate objects into a
list that is returned from a loop, you can combine them safely.


\begin{lisp}
;;; Collect every name and the kids in one list by using \\*
;;; COLLECT and APPEND. \\*
(loop for name in '(fred sue alice joe june) \\*
~~~~~~for kids in '((bob ken) () () (kris sunshine) ()) \\*
~~~~~~collect name \\*
~~~~~~append kids) \\*
~~~\EV~(FRED BOB KEN SUE ALICE JOE KRIS SUNSHINE JUNE)
\end{lisp}
[In the preceding example, note that the items accumulated by the
\cdf{collect} and \cdf{append} clauses are interleaved in the result list, according to
the order in which the clauses were executed.---GLS]

Multiple clauses that do not accumulate the same type of data object 
can coexist in a loop only if each clause accumulates its values into 
a different user-specified variable.  Any number of values can
be returned from a loop if you use the Common Lisp function \cdf{values},
as the next example shows:
\begin{lisp}
;;; Count and collect names and ages. \\*
(loop for name in '(fred sue alice joe june) \\*
~~~~~~as age in '(22 26 19 20 10) \\*
~~~~~~append (list name age) into name-and-age-list \\*
~~~~~~count name into name-count \\*
~~~~~~sum age into total-age \\*
~~~~~~finally \\*
~~~~~~~~(return (values (round total-age name-count) \\*
~~~~~~~~~~~~~~~~~~~~~~~~name-and-age-list))) \\*
~~~\EV~19 \textrm{and} (FRED 22 SUE 26 ALICE 19 JOE 20 JUNE 10)
\end{lisp}

\begin{defloop}
collect expr [\!into! var] \\
collecting expr [\!into! var]

During each iteration, these constructs collect the value of the specified 
expression into a list. When iteration terminates, the list is returned.

The argument \emph{var\/} is 
set to the list of collected values; if \emph{var} is specified, the loop
does not return the final list automatically.  If \emph{var} is not
specified, it is equivalent to specifying an internal name for
\emph{var} and returning its value in a \cdf{finally} clause.
The \emph{var\/} argument
is bound as if by the construct \cdf{with}.
You cannot specify a data type for \emph{var\/}; it must be of type \cdf{list}.


Examples:
\begin{lisp}
;;; Collect all the symbols in a list. \\*
(loop for i in '(bird 3 4 turtle (1 . 4) horse cat) \\*
~~~~~~when (symbolp i) collect i) \\*
~~~\EV~(BIRD TURTLE HORSE CAT) \\
 \\
;;; Collect and return odd numbers. \\*
(loop for i from 1 to 10 \\*
~~~~~~if (oddp i) collect i) \\*
~~~\EV~(1 3 5 7 9) \\
 \\
;;; Collect items into local variable, but don't return them. \\*
(loop for i in '(a b c d) by \#'cddr \\*
~~~~~~collect i into my-list \\*
~~~~~~finally (print my-list)) \`;\textrm{Prints 1 line}\\*
(A C)  \\*
~~~\EV~NIL
\end{lisp}
\end{defloop}

\begin{defloop}
append expr [\!into! var] \\
appending expr [\!into! var] \\
nconc expr [\!into! var] \\
nconcing expr [\!into! var]

These constructs are similar to \cdf{collect} except that the
values of the specified expression must be lists.  

The \cdf{append} keyword causes its list values to be concatenated 
into a single list, as if 
they were arguments to the Common Lisp function \cdf{append}.

The \cdf{nconc} keyword causes its list values to be concatenated
into a single list,
as if they were arguments to the Common Lisp function \cdf{nconc}.  
Note that the \cdf{nconc} keyword destructively modifies its argument lists.

The argument \emph{var\/} is 
set to the list of concatenated values; if you specify \emph{var}, the loop
does not return the final list automatically.  The \emph{var\/} argument
is bound as if by the construct \cdf{with}.
You cannot specify a data type for \emph{var\/}; it must be of type \cdf{list}.


Examples:
\begin{lisp}
;;; Use APPEND to concatenate some sublists. \\*
(loop for x in '((a) (b) ((c))) \\*
~~~~~~append x) \\*
~~~\EV~(A B (C))
\end{lisp}
\begin{lisp}
;;; NCONC some sublists together.  Note that only lists \\*
;;; made by the call to LIST are modified. \\*
(loop for i upfrom 0  \\*
~~~~~~as x in '(a b (c)) \\*
~~~~~~nconc (if (evenp i) (list x) '())) \\*
~~~\EV~(A (C))
\end{lisp}
\end{defloop}


\begin{defloop}
count expr [\!into! var] [type-spec] \\
counting expr [\!into! var] [type-spec]

The \cdf{count} construct counts the number of times that the specified 
expression has a non-\cdf{nil} value.

The argument \emph{var\/} accumulates the number of occurrences; if 
\emph{var} is specified, the loop
does not return the final count automatically.  The \emph{var\/} argument
is bound as if by the construct \cdf{with}.

If \cdf{into} \emph{var\/} is used, the optional
\emph{type-spec\/} argument specifies a data type for \emph{var\/}.
If there is no \cdf{into} variable, the optional \emph{type-spec\/}
argument applies to the internal variable that is keeping the count.
In either case it is an error to specify a non-numeric 
data type.
The default type is implementation-dependent, but it must be a subtype
of \cd{(or~integer float)}.

Example:
\begin{lisp}
(loop for i in '(a b nil c nil d e) \\*
~~~~~~count i) \\*
~~~\EV~5
\end{lisp}
\end{defloop}


\begin{defloop}
sum expr [\!into! var] [type-spec] \\
summing expr [\!into! var] [type-spec]

The \cdf{sum} construct forms a cumulative sum of the values of the
specified expression at each iteration.

The argument \emph{var\/} is used to accumulate
the sum; if \emph{var} is specified, the loop
does not return the final sum automatically.  The \emph{var\/} argument
is bound as if by the construct \cdf{with}.

If \cdf{into} \emph{var\/} is used, the optional
\emph{type-spec\/} argument specifies a data type for \emph{var\/}.
If there is no \cdf{into} variable, the optional \emph{type-spec\/}
argument applies to the internal variable that is keeping the sum.
In either case it is an error to specify a non-numeric 
data type.
The default type is implementation-dependent, but it must be a subtype
of \cdf{number}.

Examples:
\begin{lisp}
;;; Sum the elements of a list. \\*
\\*
(loop for i fixnum in '(1 2 3 4 5) \\*
~~~~~~sum i) \\*
~~~\EV~15 \\
\\
;;; Sum a function of elements of a list. \\*
\\*
(setq series \\
~~~~~~'(1.2 4.3 5.7)) \\*
~~~\EV~(1.2 4.3 5.7) \\
\\
(loop for v in series  \\*
~~~~~~sum (* 2.0 v)) \\*
~~~\EV~22.4
\end{lisp}
\end{defloop}

\begin{defloop}
maximize expr [\!into! var] [type-spec] \\
maximizing expr [\!into! var] [type-spec] \\
minimize expr [\!into! var] [type-spec] \\
minimizing expr [\!into! var] [type-spec]

The \cdf{maximize} construct compares the value of the specified expression
obtained during the first iteration with values obtained in successive
iterations. The maximum value encountered is determined and returned.  If the
loop never executes the body, the returned value is not meaningful.

The \cdf{minimize} construct is similar to \cdf{maximize}; it
determines and returns the minimum value.

The argument \emph{var\/} accumulates the maximum or
minimum value; if \emph{var} is specified, the loop
does not return the maximum or minimum automatically.  The \emph{var\/} argument
is bound as if by the construct \cdf{with}.

If \cdf{into} \emph{var\/} is used, the optional
\emph{type-spec\/} argument specifies a data type for \emph{var\/}.
If there is no \cdf{into} variable, the optional \emph{type-spec\/}
argument applies to the internal variable that is keeping the intermediate result.
In either case it is an error to specify a non-numeric 
data type.
The default type is implementation-dependent, but it must be a subtype
of \cd{(or integer float)}.

Examples:
\begin{lisp}
(loop for i in '(2 1 5 3 4) \\*
~~~~~~maximize i) \\*
~~~\EV~5
\end{lisp}
\penalty-10000 % required
\begin{lisp}
(loop for i in '(2 1 5 3 4) \\*
~~~~~~minimize i) \\*
~~~\EV~1 \\
 \\
;;; In this example, FIXNUM applies to the internal \\*
;;; variable that holds the maximum value. \\*
\\
(setq series '(1.2 4.3 5.7)) \\*
~~~\EV~(1.2 4.3 5.7) \\
\\
(loop for v in series  \\*
~~~~~~maximize (round v) fixnum) \\*
~~~\EV~6 \\
 \\
;;; In this example, FIXNUM applies to the variable RESULT. \\
\\
(loop for v float in series \\*
~~~~~~minimize (round v) into result fixnum \\*
~~~~~~finally (return result)) \\*
~~~\EV~1
\end{lisp}
\end{defloop}


\section{Variable Initializations}
\label{LOOP-VAR-SECTION}

\section{Инициализация переменных}
\label{LOOP-VAR-SECTION}

A local loop variable is one that exists only when the Loop Facility
is invoked.  At that time, the variables are declared and are
initialized to some value.  These local variables exist until loop
iteration terminates, at which point they cease to exist.  Implicitly
variables are also established by iteration control clauses and the
\cdf{into} preposition of accumulation clauses.

The loop keyword \cdf{with} designates a loop clause that allows you to 
declare and initialize variables
that are local to a loop.  The variables are initialized one time
only; they can be initialized sequentially or in parallel.

By default, the \cdf{with} construct initializes variables
sequentially; that is, one variable is assigned a value before the
next expression is evaluated.  However, by using the loop keyword 
\cdf{and} to join several \cdf{with} clauses, you can force
initializations to occur in parallel; that is, all of the specified
expressions are evaluated, and the results are bound to the respective
variables simultaneously.

Use sequential binding for making the initialization of
some variables depend on the values of previously bound variables.
For example, suppose you want to bind the variables \cdf{a}, \cdf{b},
and \cdf{c} in sequence:
\begin{lisp}
(loop with a = 1  \\*
~~~~~~with b = (+ a 2)  \\*
~~~~~~with c = (+ b 3) \\*
~~~~~~with d = (+ c 4) \\*
~~~~~~return (list a b c d)) \\*
~~~\EV~(1 3 6 10)
\end{lisp}

Если инициализация переменных зависит от предыдущих переменных,
используйте последовательное связывание. Например, вы хотите
последовательно связать переменные \cdf{a}, \cdf{b} и \cdf{c}:
\begin{lisp}
(loop with a = 1  \\*
~~~~~~with b = (+ a 2)  \\*
~~~~~~with c = (+ b 3) \\*
~~~~~~with d = (+ c 4) \\*
~~~~~~return (list a b c d)) \\*
~~~\EV~(1 3 6 10)
\end{lisp}

The execution of the preceding loop is equivalent to the execution of
the following code:
\begin{lisp}
(let* ((a 1) \\*
~~~~~~~(b (+ a 2)) \\*
~~~~~~~(c (+ b 3)) \\*
~~~~~~~(d (+ c 4))) \\
~~(block nil \\*
~~~~(tagbody \\*
~~~~~~next-loop (return (list a b c d)) \\*
~~~~~~~~~~~~~~~~(go next-loop) \\*
~~~~~~end-loop)))
\end{lisp}

Предыдущий код эквивалентен такому:
\begin{lisp}
(let* ((a 1) \\*
~~~~~~~(b (+ a 2)) \\*
~~~~~~~(c (+ b 3)) \\*
~~~~~~~(d (+ c 4))) \\
~~(block nil \\*
~~~~(tagbody \\*
~~~~~~next-loop (return (list a b c d)) \\*
~~~~~~~~~~~~~~~~(go next-loop) \\*
~~~~~~end-loop)))
\end{lisp}

If you are not depending on the value of previously bound variables
for the initialization of other local variables, you can use
parallel bindings as follows:
\begin{lisp}
(loop with a = 1  \\*
~~~~~~~and b = 2  \\*
~~~~~~~and c = 3 \\*
~~~~~~~and d = 4 \\*
~~~~~~return (list a b c d)) \\*
~~~\EV~(1 2 3 4)
\end{lisp}

Если последовательная инициализация не требуется, используйте параллельную:
\begin{lisp}
(loop with a = 1  \\*
~~~~~~~and b = 2  \\*
~~~~~~~and c = 3 \\*
~~~~~~~and d = 4 \\*
~~~~~~return (list a b c d)) \\*
~~~\EV~(1 2 3 4)
\end{lisp}

The execution of the preceding loop is equivalent to the execution of
the following code:

\begin{lisp}
(let ((a 1) \\*
~~~~~~(b 2) \\*
~~~~~~(c 3) \\*
~~~~~~(d 4)) \\
~~(block nil \\*
~~~~(tagbody \\*
~~~~~~next-loop (return (list a b c)) \\*
~~~~~~~~~~~~~~~~(go next-loop) \\*
~~~~~~end-loop)))
\end{lisp}

Предыдущий код эквивалентен такому:

\begin{lisp}
(let ((a 1) \\*
~~~~~~(b 2) \\*
~~~~~~(c 3) \\*
~~~~~~(d 4)) \\
~~(block nil \\*
~~~~(tagbody \\*
~~~~~~next-loop (return (list a b c)) \\*
~~~~~~~~~~~~~~~~(go next-loop) \\*
~~~~~~end-loop)))
\end{lisp}

\begin{defloop}
with var [type-spec] [\!\Xequal! expr] {\!and! var [type-spec] [\!\Xequal! expr]}*

The \cdf{with} construct initializes variables that are local to 
a loop.  The variables are initialized one time only.

Конструкция \cdf{with} инициализирует локальные переменные. Переменные
инициализируются только один раз.

If the optional \emph{type-spec\/} argument is specified for any variable 
\emph{var\/}, but there is no related expression \emph{expr} to be evaluated, \emph{var\/}
is initialized to an appropriate default value for its data type.
For example, for the data types \cdf{t}, \cdf{number}, and \cdf{float},
the default values are \cdf{nil}, \cd{0}, and \cd{0.0}, respectively.
It is an error to specify a \emph{type-spec\/} argument for \emph{var\/} if
the related expression returns a value that is not of the specified type.
The optional \cdf{and} clause forces parallel rather than sequential 
initializations.

Examples:
\begin{lisp}
;;; These bindings occur in sequence. \\*
(loop with a = 1  \\*
~~~~~~with b = (+ a 2)  \\*
~~~~~~with c = (+ b 3) \\*
~~~~~~with d = (+ c 4) \\*
~~~~~~return (list a b c d)) \\*
~~~\EV~(1 3 6 10) \\
 \\
;;; These bindings occur in parallel. \\*
(setq a 5 b 10 c 1729) \\*
(loop with a = 1 \\*
~~~~~~~and b = (+ a 2) \\*
~~~~~~~and c = (+ b 3) \\*
~~~~~~~and d = (+ c 4) \\*
~~~~~~return (list a b c d)) \\*
~~~\EV~(1 7 13 1733) \\
 \\
;;; This example shows a shorthand way to declare \\*
;;; local variables that are of different types. \\*
(loop with (a b c) (float integer float) \\*
~~~~~~return (format nil "{\Xtilde}A {\Xtilde}A {\Xtilde}A" a b c)) \\*
~~~\EV~"0.0 0 0.0" \\
 \\
;;; This example shows a shorthand way to declare \\*
;;; local variables that are of the same type. \\*
(loop with (a b c) float  \\*
~~~~~~return (format nil "{\Xtilde}A {\Xtilde}A {\Xtilde}A" a b c)) \\*
~~~\EV~"0.0 0.0 0.0"
\end{lisp}
\end{defloop}


\section{Conditional Execution}
\label{LOOP-COND-SECTION}

\section{Условное выполнение}
\label{LOOP-COND-SECTION}

The loop keywords \cdf{if}, \cdf{when}, and \cdf{unless} designate constructs that 
are useful when you want some loop clauses to operate under a specified
condition.

Ключевые символы \cdf{if}, \cdf{when} и \cdf{unless} обозначают
конструкцию, которая полезна, когда вы хотите выполнить некоторые
действия только при выполнении некоторого условия.

If the specified condition is true, the succeeding loop clause
is executed.  If the specified condition is not true, the succeeding clause is
skipped, and program control moves to the clause that follows the loop
keyword \cdf{else}.  If the specified condition is not true and no
\cdf{else} clause is specified, the entire conditional construct
is skipped.  Several clauses can be connected into
one compound clause with the loop keyword \cdf{and}.
The end of the conditional clause can be marked with the keyword \cdf{end}.

Если условие истинно, выполняется следующее выражение. Если условие
ложно, следующее выражение пропускается и выполнение переходит к
выражению в ветке \cdf{else}. Если условие ложно и ветка \cdf{else}
отсутствует, всё выражение просто пропускается. Несколько выражений
могут объединены в одно с помощью \cdf{and}. Конец условного выражения
можно обозначить символом \cdf{end}.

\begin{defloop}
if expr clause {\!and! clause}*
   [\!else! clause {\!and! clause}*] [\!end!] \\
when expr clause {\!and! clause}*
     [\!else! clause {\!and! clause}*] [\!end!] \\
unless expr clause {\!and! clause}*
       [\!else! clause {\!and! clause}*] [\!end!]

The constructs \cdf{when} and \cdf{if} allow conditional execution of
loop clauses.  These constructs are synonyms and
can be used interchangeably.

Конструкции \cdf{when} и \cdf{if} выполняют действия в зависимости от
условия. Эти конструкции являются синонимами и соответственно взаимозаменяемы.

If the value of the test expression \emph{expr\/} is non-\cdf{nil}, the expression
\emph{clause1\/} is evaluated. If the test expression evaluates to \cdf{nil}
and an \cdf{else} construct is specified, the statements that follow the
\cdf{else} are evaluated; otherwise, control passes to the next clause.

Если значение условия \emph{expr} не-\cdf{nil}, выполняется выражение
\emph{clause1}. Если условие возвращает \cdf{nil} и указана ветка
\cdf{else} выполняются выражения в этой ветке, иначе выполнение
переходит к следующему выражению.

The \cdf{unless} construct is equivalent to \cdf{when} (\cdf{not} 
\emph{expr\/}) and \cdf{if} (\cdf{not} \emph{expr\/}).
If the value of the test expression \emph{expr\/} is \cdf{nil}, the expression
\emph{clause1\/} is evaluated. If the test expression evaluates to 
non-\cdf{nil}
and an \cdf{else} construct is specified, the statements that follow the
\cdf{else} are evaluated; otherwise, control passes to the next clause.
[Compare this to the \emph{macro} \cdf{unless},
which does not allow an ``else'' part---or do I mean a ``then'' part?!  Ugh.
To prevent confusion, I strongly recommend as a matter of style
that \cdf{else} not be used with \cdf{unless} loop clauses.---GLS]

Конструкция \cdf{unless} эквивалентна конструкциям \cdf{when}
(\cdf{not} \emph{expr}) и \cdf{if} (\cdf{not} \emph{expr}). Если
значение условия \cdf{nil}, выполняется выражение \emph{clause1}. Если
условие не-\cdf{nil} выполняется ветка \cdf{else}, иначе выполнение
переходит к следующей конструкции.

The \emph{clause\/} arguments must be either accumulation, unconditional,
or conditional clauses (see section~\ref{LOOP-KINDS-SECTION}).
Clauses that follow the test expression can be grouped by using the 
loop keyword \cdf{and} to produce a compound 
clause.

Аргументы \emph{clause} должны быть или накоплением значения,
безусловным или условным выполнением (смотрите
раздел~\ref{LOOP-KINDS-SECTION}). Выражения, которые следуют после
условия, могут группироваться с помощью \cdf{and}.

The loop keyword \cdf{it} can be used to refer to the result of
the test expression in a clause.  If multiple clauses are connected with \cdf{and},
the \cdf{it} construct must be used in the first
clause in the block.  Since \cdf{it} is a loop keyword, \cdf{it} may not be used
as a local variable within a loop.

Для ссылки на результат условия может использоваться символ
\cdf{it}. Если выражения были сгруппированы с помощью \cdf{and},
\cdf{it} должна использоваться только в первом выражении в
блоке. Таким образом \cdf{it} не может использоваться в качестве
локальной переменной внутри \cdf{loop}.

If \cdf{when} or \cdf{if} clauses are nested, each \cdf{else} is
paired with the closest preceding \cdf{when} or \cdf{if} construct that has
no associated \cdf{else}.

Если \cdf{when} или \cdf{if} вложены, каждый \cdf{else} относится к
ближайшему предшествующему \cdf{when} или \cdf{if}, у которого ещё не
было \cdf{else}.

The optional loop keyword \cdf{end} marks the end of the clause.  If this
keyword is not specified, the next loop keyword marks the end.  You can use
\cdf{end} to distinguish the scoping of compound clauses.
\begin{lisp}
;;; Group conditional clauses into a block. \\*
(loop for i in numbers-list \\*
~~~~~~when (oddp i) \\*
~~~~~~~~do (print i) \\*
~~~~~~~~and collect i into odd-numbers \\*
~~~~~~~~and do (terpri) \\
~~~~~~else~~~~~;\textrm{\cdf{I} is even} \\*
~~~~~~~~collect i into even-numbers \\*
~~~~~~finally \\*
~~~~~~~~(return (values odd-numbers even-numbers)))
\end{lisp}
\begin{lisp}
;;; Collect numbers larger than 3. \\*
(loop for i in '(1 2 3 4 5 6) \\*
~~~~~~when (and (> i 3) i) \\*
~~~~~~collect it)~~~~~;\textrm{\cdf{it} refers to \cd{(and (> i 3) i)}} \\*
~~~\EV~(4 5 6)
\end{lisp}
\begin{lisp}
;;; Find a number in a list. \\*
(loop for i in '(1 2 3 4 5 6) \\*
~~~~~~when (and (> i 3) i) \\*
~~~~~~return it) \\*
~~~\EV~4
\end{lisp}
\begin{lisp}
;;; The preceding example is similar to the following one. \\*
(loop for i in '(1 2 3 4 5 6) \\*
~~~~~~thereis (and (> i 3) i)) \\*
~~~\EV~4
\end{lisp}
\begin{lisp}
;;; An example of using UNLESS with ELSE (yuk).\`\textrm{---GLS} \\*
(loop for turtle in teenage-mutant-ninja-turtles do\\*
~~(loop for x in '(joker brainiac shredder krazy-kat) \\*
~~~~~~~~unless (evil x) \\*
~~~~~~~~~~do (eat (make-pizza :anchovies t)) \\*
~~~~~~~~else unless (and (eq x 'shredder) (attacking-p x))\\*
~~~~~~~~~~~~~~~do (cut turtle slack)\,;\textrm{When the evil Shredder attacks,} \\*
~~~~~~~~~~~~~else (fight turtle x)))\,;\,\textrm{those turtle boys don't cut no slack}
\end{lisp}
\goodbreak
\begin{lisp}
;;; Nest conditional clauses. \\*
(loop for i in list \\*
~~~~~~when (numberp i) \\*
~~~~~~~~when (bignump i) \\*
~~~~~~~~~~collect i into big-numbers \\*
~~~~~~~~else~~~~~;\textrm{Not \cd{(bignump i)}} \\*
~~~~~~~~~~collect i into other-numbers \\
~~~~~~else~~~~~;\textrm{Not \cd{(numberp i)}} \\*
~~~~~~~~when (symbolp i)  \\*
~~~~~~~~~~collect i into symbol-list \\*
~~~~~~~~else~~~~~;\textrm{Not \cd{(symbolp i)}} \\*
~~~~~~~~~~(error "found a funny value in list {\Xtilde}S, value {\Xtilde}S{\Xtilde}\%" \\*
~~~~~~~~~~~~~~~~"list i)) \\
 \\
;;; Without the END marker, the last AND would apply to the \\*
;;; inner IF rather than the outer one. \\*
(loop for x from 0 to 3  \\*
~~~~~~do (print x) \\*
~~~~~~if (zerop (mod x 2)) \\*
~~~~~~~~do (princ " a") \\*
~~~~~~~~~~and if (zerop (floor x 2)) \\*
~~~~~~~~~~~~~~~~do (princ " b") \\*
~~~~~~~~~~~~~~end \\*
~~~~~~~~~~and do (princ " c"))
\end{lisp}

Конец можно обозначить необязательным символом \cdf{end}. Если этот
символ не указан, конструкция заканчивается там, где начинается
следующая, обозначенная символом. Вы можете использовать \cdf{end} для
ограничения пространство составных выражений.
\begin{lisp}
;;; Группирует условные выражение в блок. \\*
(loop for i in numbers-list \\*
~~~~~~when (oddp i) \\*
~~~~~~~~do (print i) \\*
~~~~~~~~and collect i into odd-numbers \\*
~~~~~~~~and do (terpri) \\
~~~~~~else~~~~~;\textrm{\cdf{I} is even} \\*
~~~~~~~~collect i into even-numbers \\*
~~~~~~finally \\*
~~~~~~~~(return (values odd-numbers even-numbers)))
\end{lisp}
\begin{lisp}
;;; Накапливает числа, большие чем 3. \\*
(loop for i in '(1 2 3 4 5 6) \\*
~~~~~~when (and (> i 3) i) \\*
~~~~~~collect it)~~~~~;\textrm{\cdf{it} ссылается на \cd{(and (> i 3) i)}} \\*
~~~\EV~(4 5 6)
\end{lisp}
\begin{lisp}
;;; Ищет числа в списке. \\*
(loop for i in '(1 2 3 4 5 6) \\*
~~~~~~when (and (> i 3) i) \\*
~~~~~~return it) \\*
~~~\EV~4
\end{lisp}
\begin{lisp}
;;; То же что и в предыдущем примере. \\*
(loop for i in '(1 2 3 4 5 6) \\*
~~~~~~thereis (and (> i 3) i)) \\*
~~~\EV~4
\end{lisp}
\begin{lisp}
;;; Пример использования UNLESS с ELSE.\`\textrm{---GLS} \\*
(loop for turtle in teenage-mutant-ninja-turtles do\\*
~~(loop for x in '(joker brainiac shredder krazy-kat) \\*
~~~~~~~~unless (evil x) \\*
~~~~~~~~~~do (eat (make-pizza :anchovies t)) \\*
~~~~~~~~else unless (and (eq x 'shredder) (attacking-p x))\\*
~~~~~~~~~~~~~~~do (cut turtle slack)\,;\textrm{Когда злой Шрёдер атакует,} \\*
~~~~~~~~~~~~~else (fight turtle x)))\,;\,\textrm{эти черепашки-ниндзя дают ему отпор.}
\end{lisp}
\goodbreak
\begin{lisp}
;;; Вложенные условные выражения. \\*
(loop for i in list \\*
~~~~~~when (numberp i) \\*
~~~~~~~~when (bignump i) \\*
~~~~~~~~~~collect i into big-numbers \\*
~~~~~~~~else~~~~~;\textrm{Not \cd{(bignump i)}} \\*
~~~~~~~~~~collect i into other-numbers \\
~~~~~~else~~~~~;\textrm{Not \cd{(numberp i)}} \\*
~~~~~~~~when (symbolp i)  \\*
~~~~~~~~~~collect i into symbol-list \\*
~~~~~~~~else~~~~~;\textrm{Not \cd{(symbolp i)}} \\*
~~~~~~~~~~(error "нашёл интересное значение в списке {\Xtilde}S, значение {\Xtilde}S{\Xtilde}\%" \\*
~~~~~~~~~~~~~~~~"list i)) \\
 \\
;;; Без маркера END последнее AND должно примениться к \\*
;;; внутреннему IF, а не к внешнему. \\*
(loop for x from 0 to 3  \\*
~~~~~~do (print x) \\*
~~~~~~if (zerop (mod x 2)) \\*
~~~~~~~~do (princ " a") \\*
~~~~~~~~~~and if (zerop (floor x 2)) \\*
~~~~~~~~~~~~~~~~do (princ " b") \\*
~~~~~~~~~~~~~~end \\*
~~~~~~~~~~and do (princ " c"))
\end{lisp}
\end{defloop}


\section{Unconditional Execution}
\label{LOOP-UNCOND-SECTION}

\section{Безусловное выполнение}
\label{LOOP-UNCOND-SECTION}

The loop construct \cdf{do} (or \cdf{doing}) takes one or more expressions
and simply evaluates them in order.

The loop construct \cdf{return} takes one expression and returns its value.  It 
is equivalent to the clause \cd{do~(return \emph{value\/})}.

Конструкция \cdf{do} (или \cdf{doing}) принимает одно или более
выражений и просто их выполняет в исходном порядке.

Конструкция \cdf{return} принимает одно выражение и возвращает его
значение. Оно эквивалентно такому выражению: \cd{do~(return
  \emph{value\/})}.

\begin{defloop}
do {expr}* \\
doing {expr}*

The \cdf{do} construct simply evaluates the specified expressions
wherever they occur in the expanded form of \cdf{loop}.

Конструкция \cdf{do} просто выполняет указанные выражения. Конструкция
может быть использована в любом месте формы \cdf{loop}.

The \emph{expr\/} argument can be any non-atomic Common Lisp form.
Each \emph{expr\/} is evaluated in every iteration.

Аргумент \emph{expr} может быть любой неатомной Common Lisp'овой формой.
Каждое выражение \emph{expr} вычисляется на каждой итерации цикла.

The constructs \cdf{do}, \cdf{initially}, and \cdf{finally} are the
only loop keywords that take an arbitrary number of forms and group
them as if using an implicit \cdf{progn}.  
Because every loop clause must begin with a loop keyword, you would use
the keyword \cdf{do} when no control action other than execution is 
required.

Только конструкции \cdf{do}, \cdf{initially} и \cdf{finally} принимают
несколько форм и группируют их как неявный \cdf{progn}.  Так как
каждое выражение цикла \cdf{loop} начинается с ключевого символа,
когда требуется просто выполнение некоторых действий, вы должны
использовать ключевой символ \cdf{do}.

Examples:
\begin{lisp}
;;; Print some numbers. \\*
(loop for i from 1 to 5 \\*
~~~~~~do (print i)) \`;\textrm{Prints 5 lines} \\*
1 \\*
2 \\*
3 \\*
4 \\*
5 \\*
~~~\EV~NIL \\
 \\
;;; Print numbers and their squares. \\*
;;; The DO construct applies to multiple forms. \\*
(loop for i from 1 to 4 \\*
~~~~~~do (print i) \\*
~~~~~~~~~(print (* i i))) \`;\textrm{Prints 8 lines} \\
1  \\*
1  \\*
2  \\*
4  \\*
3  \\*
9  \\*
4  \\*
16  \\*
~~~\EV~NIL
\end{lisp}

Примеры:
\begin{lisp}
;;; Напечатает несколько чисел \\*
(loop for i from 1 to 5 \\*
~~~~~~do (print i)) \`;\textrm{Напечатает 5 строк} \\*
1 \\*
2 \\*
3 \\*
4 \\*
5 \\*
~~~\EV~NIL \\
 \\
;;; Напечатает числа и их квадраты. \\*
;;; Конструкция DO применяется к нескольким формам. \\*
(loop for i from 1 to 4 \\*
~~~~~~do (print i) \\*
~~~~~~~~~(print (* i i))) \`;\textrm{Напечатает 8 строк} \\
1  \\*
1  \\*
2  \\*
4  \\*
3  \\*
9  \\*
4  \\*
16  \\*
~~~\EV~NIL
\end{lisp}
\end{defloop}


\begin{defloop}
return expr

The \cdf{return} construct terminates a 
loop and returns the value of 
the specified expression as the value of the loop.   This construct
is similar to the Common Lisp special operator \cdf{return-from} and the
Common Lisp macro \cdf{return}.

The Loop Facility supports the \cdf{return} construct for backward
compatibility with older \cdf{loop} implementations.  
The \cdf{return} construct returns immediately and does not execute
any \cdf{finally} clause that is given.

Examples:
\begin{lisp}
;;; Signal an exceptional condition. \\*
(loop for item in '(1 2 3 a 4 5) \\*
~~~~~~when (not (numberp item)) \\*
~~~~~~return (cerror "enter new value" \\*
~~~~~~~~~~~~~~~~~~~~~"non-numeric value: {\Xtilde}s" \\*
~~~~~~~~~~~~~~~~~~~~~item)) \`;\textrm{Signals an error} \\*
>>Error: non-numeric value: A \\
 \\
;;; The previous example is equivalent to the following one. \\*
(loop for item in '(1 2 3 a 4 5) \\*
~~~~~when (not (numberp item)) \\*
~~~~~~do (return  \\*
~~~~~~~~~~~(cerror "enter new value" \\*
~~~~~~~~~~~~~~~~~~~"non-numeric value: {\Xtilde}s" \\*
~~~~~~~~~~~~~~~~~~~item)))  \`;\textrm{Signals an error} \\*
>>Error: non-numeric value: A
\end{lisp}
\end{defloop}


\section{Miscellaneous Features}
\label{LOOP-MISC-SECTION}

\section{Дополнительные возможности}
\label{LOOP-MISC-SECTION}

The Loop Facility provides the \cdf{named} construct to name a loop so that
the Common Lisp special operator \cdf{return-from} can be used.

Для задания имени цикла используется конструкция \cdf{named}. Данное
имя впоследствии можно использовать в \cdf{return-from}.

The loop keywords \cdf{initially} and \cdf{finally} designate loop constructs that cause
expressions to be evaluated before and after the loop body, respectively.

Символы \cdf{initially} и \cdf{finally} обозначают выражения, которые
будут выполнены перед и после тела цикла соответственно.

The code for any \cdf{initially} clauses is collected into one
\cdf{progn} in the order in which the clauses appeared in the loop.
The collected code is executed once in the loop prologue after any
implicit variable initializations.

Выражения после всех \cdf{initially} собираются в один \cdf{progn} в
исходном порядке. Сгруппированный код выполняется единожды перед
началом итераций.

The code for any \cdf{finally} clauses is collected into one
\cdf{progn} in the order in which the clauses appeared in the loop.
The collected code is executed once in the loop epilogue before any
implicit values are returned from the accumulation clauses.  Explicit
returns in the loop body, however, will exit the loop without
executing the epilogue code.

Выражения после всех \cdf{finally} собираются в один \cdf{progn} в
исходном порядке. Сгруппированный код выполняется единожды после
выполнения всех итераций в эпилоге перед неявным возвратом значений. В
случае явного выхода из цикла, эпилог не выполняется.

\subsection{Data Types}
\label{LOOP-TYPES-SECTION}

\subsection{Типы данных}
\label{LOOP-TYPES-SECTION}

Many loop constructs take a \emph{type-spec\/} argument that
allows you to specify  certain data types for loop variables.
While it is not necessary to specify a data type for any variable,
by doing so you ensure that the variable has a correctly typed initial
value.  The type declaration is made available to the compiler for
more efficient \cdf{loop} 
expansion. 
In some implementations,
fixnum and float declarations are especially
useful; the compiler notices them and emits more efficient code.

Многие конструкции принимают аргумент \emph{type-spec}, который
позволяет задать тип для переменной. Конечно в этом нет прямой
необходимости, но декларации типов упрощают дальнейшую работу с
программой. Декларация типов также помогает компилятору оптимизировать
программу. Особенно это касается типов fixnum и float.

The \emph{type-spec\/} argument has the following syntax:
\begin{tabbing}
\emph{type-spec\/} ::= \cdf{of-type} \emph{d-type-spec} \\
\emph{d-type-spec\/} ::= \emph{type-specifier\/} {\Mor} \cd{(\emph{d-type-spec} . \emph{d-type-spec})}
\end{tabbing}
A \emph{type-specifier} in this syntax can be any Common Lisp type
specifier.  The \emph{d-type-spec} argument is used for destructuring,
as described in section~\ref{LOOP-DESTRUCTURING-SECTION}.  If the
\emph{d-type-spec} argument consists solely of the types \cdf{fixnum},
\cdf{float}, \cdf{t}, or \nil, the \cdf{of-type} keyword is optional.  The
\cdf{of-type} construct is optional in these cases to provide backward
compatibility; thus the following two expressions are the same:
\begin{lisp}
;;; This expression uses the old syntax for type specifiers. \\*
(loop for i fixnum upfrom 3 ...) \\
 \\
;;; This expression uses the new syntax for type specifiers. \\*
(loop for i of-type fixnum upfrom 3 ...)
\end{lisp}

Аргумент \emph{type-spec} выглядит так:
\begin{tabbing}
\emph{type-spec\/} ::= \cdf{of-type} \emph{d-type-spec} \\
\emph{d-type-spec\/} ::= \emph{type-specifier\/} {\Mor} \cd{(\emph{d-type-spec} . \emph{d-type-spec})}
\end{tabbing}
На месте \emph{type-specifier} может быть любой спецификатор
типа. Аргумент \emph{d-type-spec} используется для деструктуризации,
как написано в разделе~\ref{LOOP-DESTRUCTURING-SECTION}. Если аргумент
\emph{d-type-spec} состоит только из ключевых слов \cdf{fixnum},
\cdf{float}, \cdf{t} или \nil, символ \cdf{of-type} необязателен. Это
оставлено для обратной совместимости.

\begin{lisp}
;;; Старый стиль кода. \\*
(loop for i fixnum upfrom 3 ...) \\
 \\
;;; Новый стиль кода. \\*
(loop for i of-type fixnum upfrom 3 ...)
\end{lisp}

\subsection{Destructuring}
\label{LOOP-DESTRUCTURING-SECTION}

Destructuring allows you to bind a set of variables to a corresponding
set of values anywhere that you can normally bind a value to a single
variable.  During \cdf{loop} expansion, each variable in the variable list
is matched with the values in the values list.  If there are more variables
in the variable list than there are values in the values list, the 
remaining variables are given a value of \cdf{nil}.  If there are more
values than variables listed, the extra values are discarded.

Suppose you want to assign values from a list to the variables \cdf{a},
\cdf{b}, and \cdf{c}.  You could use one \cdf{for} clause to
bind the variable \cdf{numlist} to the \emph{car} of the specified expression,
and then you could use another \cdf{for} clause to bind the variables
\cdf{a}, \cdf{b}, and \cdf{c} sequentially.  
\begin{lisp}
;;; Collect values by using FOR constructs. \\*
(loop for numlist in '((1 2 4.0) (5 6 8.3) (8 9 10.4)) \\*
~~~~~~for a integer = (first numlist) \\*
~~~~~~and for b integer = (second numlist) \\*
~~~~~~and for c float = (third numlist) \\*
~~~~~~collect (list c b a)) \\*
~~~\EV~((4.0 2 1) (8.3 6 5) (10.4 9 8))
\end{lisp}
Destructuring makes this process easier by allowing the variables to
be bound in parallel in each loop iteration.  You can declare data
types by using a list of \emph{type-spec\/} arguments.  If all the types
are the same, you can use a shorthand destructuring syntax, as the second
example following illustrates.
\begin{lisp}
;;; Destructuring simplifies the process. \\*
(loop for (a b c) (integer integer float) in \\*
~~~~~~'((1 2 4.0) (5 6 8.3) (8 9 10.4)) \\*
~~~~~~collect (list c b a))) \\*
~~~\EV~((4.0 2 1) (8.3 6 5) (10.4 9 8)) \\
 \\
;;; If all the types are the same, this way is even simpler. \\*
(loop for (a b c) float in \\*
~~~~~~'((1.0 2.0 4.0) (5.0 6.0 8.3) (8.0 9.0 10.4)) \\*
~~~~~~collect (list c b a)) \\*
~~~\EV~((4.0 2.0 1.0) (8.3 6.0 5.0) (10.4 9.0 8.0))
\end{lisp}


If you use destructuring to declare or initialize a number of groups
of variables into types, you can use the loop keyword \cdf{and}
to simplify the process further.
\begin{lisp}
;;; Initialize and declare variables in parallel \\*
;;; by using the AND construct. \\*
(loop with (a b) float = '(1.0 2.0) \\*
~~~~~~and (c d) integer = '(3 4) \\*
~~~~~~and (e f) \\*
~~~~~~return (list a b c d e f)) \\*
~~~\EV~(1.0 2.0 3 4 NIL NIL)
\end{lisp}

A data type specifier for a destructuring pattern is a tree of type
specifiers with the same shape as the tree of variables, with the
following exceptions:

\begin{itemize}

\item When aligning the trees, an atom in the type specifier tree that
  matches a cons in the variable tree declares the same type for each
  variable.

\item A cons in the type specifier tree that matches an atom in the
  variable tree is a non-atomic type specifer.

\end{itemize}
   
\begin{lisp}
;;; Declare X and Y to be of type VECTOR and FIXNUM, respectively. \\*
(loop for (x y) of-type (vector fixnum) in my-list do ...)
\end{lisp}

If \cdf{nil} is used in a destructuring list, no variable is provided for
its place.
\begin{lisp}
(loop for (a nil b) = '(1 2 3) \\*
~~~~~~do (return (list a b))) \\*
~~~\EV~(1 3)
\end{lisp}

Note that nonstandard lists can specify destructuring.
\begin{lisp}
(loop for (x . y) = '(1 . 2) \\*
~~~~~~do (return y)) \\*
~~~\EV~2 \\
 \\
(loop for ((a . b) (c . d)) \\*
~~~~~~~~~~of-type ((float . float) (integer . integer)) \\*
~~~~~~~~~~in '(((1.2 . 2.4) (3 . 4)) ((3.4 . 4.6) (5 . 6))) \\*
~~~~~~collect (list a b c d)) \\*
~~~\EV~((1.2 2.4 3 4) (3.4 4.6 5 6))
\end{lisp}

[It is worth noting that the destructuring facility of \cdf{loop} predates,
and differs in some details from, that
of \cdf{destructuring-bind}, an extension that has been provided by many implementors
of Common Lisp.---GLS]

\begin{defloop}
initially {expr}* \\
finally [\!do! | \!doing!] {expr}* \\
finally \!return! expr

The \cdf{initially} construct causes the specified expression to be evaluated
in the loop prologue, which precedes all loop code except for 
initial settings specified by constructs \cdf{with}, \cdf{for}, or
\cdf{as}.
The \cdf{finally} construct causes the specified expression to be evaluated
in the loop epilogue after normal iteration terminates.

The \emph{expr\/} argument can be any non-atomic Common Lisp form.

Clauses such as \cdf{return}, \cdf{always}, \cdf{never}, and \cdf{thereis}
can bypass the \cdf{finally} clause.

The Common Lisp macro \cdf{return} (or the \cdf{return} loop construct) can be used
after \cdf{finally} to return
values from a loop.  The evaluation of the \cdf{return} form inside the
\cdf{finally} clause takes precedence over returning the accumulation
from clauses specified by such keywords as \cdf{collect}, \cdf{nconc}, 
\cdf{append}, \cdf{sum}, \cdf{count}, \cdf{maximize}, and \cdf{minimize}; 
the accumulation values for these pre-empted clauses are not returned by 
the loop if \cdf{return} is used.

The constructs \cdf{do}, \cdf{initially}, and \cdf{finally} are the
only loop keywords that take an arbitrary number of (non-atomic) forms and group
them as if by using an implicit \cdf{progn}.  

\goodbreak

Examples:
\begin{lisp}
;;; This example parses a simple printed string representation  \\*
;;; from BUFFER (which is itself a string) and returns the \\*
;;; index of the closing double-quote character. \\*
\\*
(loop initially (unless (char= (char buffer 0) \#{\Xbackslash}") \\*
~~~~~~~~~~~~~~~~~~(loop-finish)) \\*
~~~~~~for i fixnum from 1 below (string-length buffer) \\*
~~~~~~when (char= (char buffer i) \#{\Xbackslash}") \\*
~~~~~~~~return i) \\
 \\
;;; The FINALLY clause prints the last value of I. \\*
;;; The collected value is returned. \\*
\\*
(loop for i from 1 to 10 \\*
~~~~~~when (> i 5) \\*
~~~~~~~~collect i \\*
~~~~~~finally (print i)) \`;\textrm{Prints 1 line}\\*
11 \\*
~~~\EV~(6 7 8 9 10) \\
 \\
;;; Return both the count of collected numbers \\*
;;; as well as the numbers themselves. \\*
\\*
(loop for i from 1 to 10 \\*
~~~~~~when (> i 5) \\*
~~~~~~~~collect i into number-list \\*
~~~~~~~~and count i into number-count \\*
~~~~~~finally (return (values number-count number-list))) \\*
~~~\EV~5 \textrm{and} (6 7 8 9 10)
\end{lisp}
\end{defloop}

\begin{defloop}
named name

The \cdf{named} construct allows you to assign a name to a \cdf{loop}
construct so that you can use the Common Lisp special operator 
\cdf{return-from} to exit the named loop.

Only one name may be assigned per loop; the specified name becomes the
name of the implicit block for the loop.

If used, the \cdf{named}
construct must be the first clause in the loop expression, coming right after the
word \cdf{loop}.

Example:
\begin{lisp}
;;; Just name and return. \\*
(loop named max \\*
~~~~~~for i from 1 to 10 \\*
~~~~~~do (print i) \\*
~~~~~~do (return-from max 'done)) \`;\textrm{Prints 1 line}\\*
1  \\*
~~~\EV~DONE
\end{lisp}
\end{defloop}

