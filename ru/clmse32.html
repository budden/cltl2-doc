<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Предикаты типов данных</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2013-03-12 14:38:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="clmse33.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse31.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse31.html#tailclmse31.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse32.html">В-конец</a>&#x003E;&#x003C;<a 
href="preds.html#clmse32.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">6.2
</span> <a 
href="clm.html#QQ2-43-78" id="x43-690006.2">Предикаты типов данных</a></h3>
<!--l. 1069--><p class="noindent" >Возможно наиболее важными предикатами в Lisp&#x2019;е это предикаты, которые
различают типы данных. То есть позволяют узнать принадлежит ли
заданный объект данному типу. Также предикаты могут сравнивать два
спецификатора типов.
<!--l. 1073--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.1   </span> <a 
href="frontmatter.html#QQ2-43-79" id="x43-700006.2.1">Основные предикаты</a></h4>
<!--l. 1075--><p class="noindent" >Если тип данных рассматривать, как множество все объектов, принадлежащих
этому типу, тогда функция <b><a 
href="symbols.html#x200-396976r976">typep</a></b> проверяет принадлежность множеству,
тогда как <b>subtypep</b> — принадлежность подмножеству.
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-70001"></a>
<em>
<!--l. 1080--><p class="noindent" >[Функция]</em> <b>typep</b> <i>object</i> <i>type</i>
</div>
<b>
<!--l. 1082--><p class="indent" >   <a 
href="symbols.html#x200-396976r976">typep</a></b> является предикатом, который истинен, если объект <em>object</em>
принадлежит типу <em>type</em>, и ложен в противном случае. Следует отметить, что
объект может принадлежать нескольким типам, так как один тип может
включать другой. <em>type</em> может быть любым спецификатором типа,
описанным в главе <a 
href="dtspec.html#x26-420004">4<!--tex4ht:ref: DTSPEC --></a>, за исключением того, что он не может быть или
включать список спецификатор типа, у которого первый элемент равен
<b><a 
href="symbols.html#x200-396446r446">function</a></b> или <b><a 
href="symbols.html#x200-396999r999">values</a></b>. Спецификатор формы <b>(satisﬁes <em>fn</em>)</b> обрабатывается
просто как применение функции <em>fn</em> к объекту <em>object</em> (смотрите <b><a 
href="symbols.html#x200-396444r444">funcall</a></b>).
Объект <em>object</em> принадлежит заданному типу, если результат не равен
<b><a 
href="symbols.html#x200-396670r670">nil</a></b>.
                                                                          

                                                                          
<div class="new">
<!--l. 1094--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx43-70002"></a>to change <b><a 
href="symbols.html#x200-396976r976">typep</a></b> to give specialized
<b>array</b> and <b><a 
href="symbols.html#x200-396268r268">complex</a></b> type speciﬁers the same meaning for purposes of type
discrimination as they have for declaration purposes. Of course, this also applies
to such type speciﬁers as <b><a 
href="symbols.html#x200-397002r1002">vector</a></b> and <b>simple-array</b> (see section <a 
href="clmse22.html#x31-470004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>). Thus
<div class="lisp"><tt><div class="tabbing">
(typep foo &#x2019;(array bignum))
   <br>
<!--l. 1105--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1106--><p class="indent" >   in the ﬁrst edition asked the question, Is <b>foo</b> an array specialized to hold
bignums? but under the new interpretation asks the question, Could the array <b>foo</b>
have resulted from giving <b>bignum</b> as the <b>:element-type</b> argument to
<b><a 
href="symbols.html#x200-396588r588">make-array</a></b>?
</div>
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-70003"></a>
<em>
<!--l. 1115--><p class="noindent" >[Функция]</em> <b>subtypep</b> <i>type1</i> <i>type2</i>
</div>
<!--l. 1117--><p class="indent" >   Аргументы должны быть спецификаторами типов, но только теми,
которые могут использоваться и для <b><a 
href="symbols.html#x200-396976r976">typep</a></b>. Два спецификатора типа
сравниваются. Данный предикат истинен, если тип <em>type1</em> точно является
подтипом типа <em>type2</em>, иначе предикат ложен. Если результат <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, тогда тип
<em>type1</em> может быть, а может и не быть подтипом типа <em>type2</em> (иногда это
невозможно определить, особенно когда используется тип <b>satisﬁes</b>). Второе
возвращаемое значение указывает на точность результата. Если оно является
истиной, значит первое значение указывает на точную принадлежность
типов. Таким образом возможны следующие комбинации результатов:
<div class="tabbing">
                                                                          

                                                                          
<b><a 
href="symbols.html#x200-396951r951">t</a></b>          <b><a 
href="symbols.html#x200-396951r951">t</a></b>          <em>type1</em> точно является подтипом <em>type2</em>
   <br>             <b><a 
href="symbols.html#x200-396670r670">nil</a></b>        <b><a 
href="symbols.html#x200-396951r951">t</a></b>          <em>type1</em> точно не является подтипом <em>type2</em><br>
<b><a 
href="symbols.html#x200-396670r670">nil</a></b>        <b><a 
href="symbols.html#x200-396670r670">nil</a></b>        <b><a 
href="symbols.html#x200-396938r938">subtypep</a></b> не может определить отношение<br>
<!--l. 1132--><p class="noindent" ></div>
<div class="new">
<!--l. 1135--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx43-70004"></a>to place certain requirements upon the
implementation of <b><a 
href="symbols.html#x200-396938r938">subtypep</a></b>, for it noted that implementations in many cases
simply “give up” and return the two values <b><a 
href="symbols.html#x200-396670r670">nil</a></b> and <b><a 
href="symbols.html#x200-396670r670">nil</a></b> when in fact it would have
been possible to determine the relationship between the given types. The
requirements are as follows, where it is understood that a type speciﬁer <em>s</em> <em>involves</em>
a type speciﬁer <em>u</em> if either <em>s</em> contains an occurrence of <em>u</em> directly or <em>s</em>
contains a type speciﬁer <em>w</em> deﬁned by <b><a 
href="symbols.html#x200-396326r326">deftype</a></b> whose expansion involves
<em>u</em>.
      <ul class="itemize1">
      <li class="itemize"><b><a 
href="symbols.html#x200-396938r938">subtypep</a></b> is not permitted to return a second value of <b><a 
href="symbols.html#x200-396670r670">nil</a></b> unless one
      or both of its arguments involves <b>satisﬁes</b>, <b><a 
href="symbols.html#x200-396098r98">and</a></b>, <b><a 
href="symbols.html#x200-396703r703">or</a></b>, <b><a 
href="symbols.html#x200-396676r676">not</a></b>, or <b><a 
href="symbols.html#x200-396627r627">member</a></b>.
      </li>
      <li class="itemize"><b><a 
href="symbols.html#x200-396938r938">subtypep</a></b> should signal an error when one or both of its arguments
      involves <b><a 
href="symbols.html#x200-396999r999">values</a></b> or the list form of the <b><a 
href="symbols.html#x200-396446r446">function</a></b> type speciﬁer.
      </li>
      <li class="itemize"><b><a 
href="symbols.html#x200-396938r938">subtypep</a></b> must always return the two values <b><a 
href="symbols.html#x200-396951r951">t</a></b> and <b><a 
href="symbols.html#x200-396951r951">t</a></b> in the case where
      its arguments, after expansion of speciﬁers deﬁned by <b><a 
href="symbols.html#x200-396326r326">deftype</a></b>, are
      <b><a 
href="symbols.html#x200-396381r381">equal</a></b>.</li></ul>
<!--l. 1155--><p class="noindent" >In addition, X3J13 voted to clarify that in some cases the relationships between types
as reﬂected by <b><a 
href="symbols.html#x200-396938r938">subtypep</a></b> may be implementation-speciﬁc. For example, in an
implementation supporting only one type of ﬂoating-point number, <b>(subtypep
&#x2019;ﬂoat &#x2019;long-ﬂoat)</b> would return <b><a 
href="symbols.html#x200-396951r951">t</a></b> and <b><a 
href="symbols.html#x200-396951r951">t</a></b>, since the two types would be
identical.
<!--l. 1162--><p class="indent" >   Note that <b>satisﬁes</b> is an exception because relationships between types
involving <b>satisﬁes</b> are undecidable in general, but (as X3J13 noted) <b><a 
href="symbols.html#x200-396098r98">and</a></b>, <b><a 
href="symbols.html#x200-396703r703">or</a></b>, <b><a 
href="symbols.html#x200-396676r676">not</a></b>,
and <b><a 
href="symbols.html#x200-396627r627">member</a></b> are merely very messy to deal with. In all likelihood these will not
be addressed unless and until someone is willing to write a careful speciﬁcation
                                                                          

                                                                          
that covers all the cases for the processing of these type speciﬁers by <b><a 
href="symbols.html#x200-396938r938">subtypep</a></b>.
The requirements stated above were easy to state and probably suﬃce for most
cases of interest.
</div>
<div class="new">
<!--l. 1173--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx43-70005"></a>to change <b><a 
href="symbols.html#x200-396938r938">subtypep</a></b> to give specialized
<b>array</b> and <b><a 
href="symbols.html#x200-396268r268">complex</a></b> type speciﬁers the same meaning for purposes of
type discrimination as they have for declaration purposes. Of course, this
also applies to such type speciﬁers as <b><a 
href="symbols.html#x200-397002r1002">vector</a></b> and <b>simple-array</b> (see
section <a 
href="clmse22.html#x31-470004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>).
<!--l. 1182--><p class="indent" >   If <em>A</em> and <em>B</em> are type speciﬁers (other than <b><a 
href="symbols.html#x200-396011r11">*</a></b>, which technically is not a type
speciﬁer anyway), then <b>(array <em>A</em>)</b> and <b>(array <em>B</em>)</b> represent the same type in
a given implementation if and only if they denote arrays of the same
specialized representation in that implementation; otherwise they are
disjoint. To put it another way, they represent the same type if and only if
<b>(upgraded-array-element-type &#x2019;<em>A</em>)</b> and <b>(upgraded-array-element-type &#x2019;<em>B</em>)</b>
are the same type. Therefore <div class="lisp"><tt><div class="tabbing">
(subtypep &#x2019;(array <em>A</em>) &#x2019;(array <em>B</em>))
   <br>
<!--l. 1196--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1197--><p class="indent" >   is true if and only if <b>(upgraded-array-element-type &#x2019;<em>A</em>)</b> is the same type
as <b>(upgraded-array-element-type &#x2019;<em>B</em>)</b>.
<!--l. 1202--><p class="indent" >   The <b><a 
href="symbols.html#x200-396268r268">complex</a></b> type speciﬁer is treated in a similar but subtly diﬀerent manner.
If <em>A</em> and <em>B</em> are two type speciﬁers (but not <b><a 
href="symbols.html#x200-396011r11">*</a></b>, which technically is not a type
speciﬁer anyway), then <b>(complex <em>A</em>)</b> and <b>(complex <em>B</em>)</b> represent the same
type in a given implementation if and only if they refer to complex numbers of the
same specialized representation in that implementation; otherwise they are
disjoint. Note, however, that there is no function called <b>make-complex</b> that
allows one to specify a particular element type (then to be upgraded);
instead, one must describe specialized complex numbers in terms of the
actual types of the parts from which they were constructed. There is no
number of type (or rather, <em>representation</em>) <b><a 
href="symbols.html#x200-396426r426">ﬂoat</a></b> as such; there are only
numbers of type <b>single-ﬂoat</b>, numbers of type <b>double-ﬂoat</b>, and so on.
                                                                          

                                                                          
Therefore we want <b>(complex single-ﬂoat)</b> to be a subtype of <b>(complex
ﬂoat)</b>.
<!--l. 1220--><p class="indent" >   The rule, then, is that <b>(complex <em>A</em>)</b> and <b>(complex <em>B</em>)</b> represent the same
type (and otherwise are disjoint) in a given implementation if and only if <em>either</em>
the type <em>A</em> is a subtype of <em>B</em>, <em>or</em> <b>(upgraded-complex-part-type &#x2019;<em>A</em>)</b> and
<b>(upgraded-complex-part-type &#x2019;<em>B</em>)</b> are the same type. In the latter case
<b>(complex <em>A</em>)</b> and <b>(complex <em>B</em>)</b> in fact refer to the same specialized
representation. Therefore <div class="lisp"><tt><div class="tabbing">
(subtypep &#x2019;(complex <em>A</em>) &#x2019;(complex <em>B</em>))
   <br>
<!--l. 1231--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1232--><p class="indent" >   is true if and only if the results of <b>(upgraded-complex-part-type &#x2019;<em>A</em>)</b> and
<b>(upgraded-complex-part-type &#x2019;<em>B</em>)</b> are the same type.
<!--l. 1236--><p class="indent" >   Under this interpretation <div class="lisp"><tt><div class="tabbing">
(subtypep &#x2019;(complex single-ﬂoat) &#x2019;(complex ﬂoat))
   <br>
<!--l. 1239--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1240--><p class="indent" >   must be true in all implementations; but <div class="lisp"><tt><div class="tabbing">
(subtypep &#x2019;(array single-ﬂoat) &#x2019;(array ﬂoat))
   <br>
<!--l. 1243--><p class="noindent" ></div>
</tt>
</div>
                                                                          

                                                                          
<!--l. 1244--><p class="indent" >   is true only in implementations that do not have a specialized array
representation for <b>single-ﬂoat</b> elements distinct from that for <b><a 
href="symbols.html#x200-396426r426">ﬂoat</a></b> elements in
general.
</div>
<hr></div>
<!--l. 1250--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.2   </span> <a 
href="frontmatter.html#QQ2-43-80" id="x43-710006.2.2">Специальные предикаты</a></h4>
<!--l. 1252--><p class="noindent" >Следующие предикаты осуществляют проверку определённых типов
данных.
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71001"></a>
<em>
<!--l. 1255--><p class="noindent" >[Функция]</em> <b>null</b> <i>object</i>
</div>
<b>
<!--l. 1257--><p class="indent" >   <a 
href="symbols.html#x200-396696r696">null</a></b> истинен, если аргумент является (), иначе является ложью. Похожая
операция производится <b><a 
href="symbols.html#x200-396676r676">not</a></b>, однако <b><a 
href="symbols.html#x200-396676r676">not</a></b> используется для отрицания булевых
значение, тогда как <b><a 
href="symbols.html#x200-396696r696">null</a></b> используется для проверки того, пустой ли список.
Таким образом программист может выразить свои намерения, выбрав
нужное имя функции. <div class="lisp"><tt><div class="tabbing">
(null x) <span class="math"> ≡</span> (typep x &#x2019;null) <span class="math"> ≡</span> (eq x &#x2019;())
   <br>
<!--l. 1264--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
                                                                          

                                                                          
<a 
 id="dx43-71002"></a>
<em>
<!--l. 1268--><p class="noindent" >[Функция]</em> <b>symbolp</b> <i>object</i>
</div>
<b>
<!--l. 1270--><p class="indent" >   <a 
href="symbols.html#x200-396949r949">symbolp</a></b> истинен, если её аргумент является символом, в противном
случае ложен. <div class="lisp"><tt><div class="tabbing">
(symbolp x) <span class="math"> ≡</span> (typep x &#x2019;symbol)
   <br>
<!--l. 1274--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71003"></a>
<em>
<!--l. 1278--><p class="noindent" >[Функция]</em> <b>atom</b> <i>object</i>
</div>
<!--l. 1280--><p class="indent" >   Предикат <b><a 
href="symbols.html#x200-396133r133">atom</a></b> истинен, если аргумент не является cons-ячейкой, в
противном случае ложен. Следует отметить <b>(atom &#x2019;())</b> являет истиной,
потому что ()<span class="math">  ≡</span><b><a 
href="symbols.html#x200-396670r670">nil</a></b>. <div class="lisp"><tt><div class="tabbing">
(atom x) <span class="math"> ≡</span> (typep x &#x2019;atom) <span class="math"> ≡</span> (not (typep x &#x2019;cons))
   <br>
<!--l. 1286--><p class="noindent" ></div>
</tt>
</div>
<hr>
                                                                          

                                                                          
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71004"></a>
<em>
<!--l. 1290--><p class="noindent" >[Функция]</em> <b>consp</b> <i>object</i>
</div>
<!--l. 1292--><p class="indent" >   Предикат <b><a 
href="symbols.html#x200-396285r285">consp</a></b> истинен, если его аргумент является cons-ячейкой, в
противном случае ложен. Следует отметить, пустой список не является
cons-ячейкой, так <b>(consp &#x2019;())</b> <span class="math"> ≡</span> <b>(consp &#x2019;<b><a 
href="symbols.html#x200-396670r670">nil</a></b>)</b> <span class="math"> ⇒</span> <b><a 
href="symbols.html#x200-396670r670">nil</a></b>. <div class="lisp"><tt><div class="tabbing">
(consp x) <span class="math"> ≡</span> (typep x &#x2019;cons) <span class="math"> ≡</span> (not (typep x &#x2019;atom))
   <br>
<!--l. 1298--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71005"></a>
<em>
<!--l. 1302--><p class="noindent" >[Функция]</em> <b>listp</b> <i>object</i>
</div>
<b>
<!--l. 1304--><p class="indent" >   <a 
href="symbols.html#x200-396552r552">listp</a></b> истинен, если его аргумент является cons-ячейкой или пустым
списком (), в противном случае ложен. Она не проверяет является ли «список
Ъ (true list)» (завершающийся <b><a 
href="symbols.html#x200-396670r670">nil</a></b>) или «с точкой (dotted)» (завершающийся
не-null атомом). <div class="lisp"><tt><div class="tabbing">
(listp x) <span class="math"> ≡</span> (typep x &#x2019;list) <span class="math"> ≡</span> (typep x &#x2019;(or cons null))
   <br>
                                                                          

                                                                          
<!--l. 1310--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71006"></a>
<em>
<!--l. 1314--><p class="noindent" >[Функция]</em> <b>numberp</b> <i>object</i>
</div>
<b>
<!--l. 1316--><p class="indent" >   <a 
href="symbols.html#x200-396697r697">numberp</a></b> истинен, если аргумент это любой вид числа, в противном
случае ложен. <div class="lisp"><tt><div class="tabbing">
(numberp x) <span class="math"> ≡</span> (typep x &#x2019;number)
   <br>
<!--l. 1320--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71007"></a>
<em>
<!--l. 1324--><p class="noindent" >[Функция]</em> <b>integerp</b> <i>object</i>
</div>
<em>
<!--l. 1326--><p class="indent" >   integerp</em> истинен, если аргумент целое число, в противном случае ложен.
<div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(integerp x) <span class="math"> ≡</span> (typep x &#x2019;integer)
   <br>
<!--l. 1330--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71008"></a>
<em>
<!--l. 1334--><p class="noindent" >[Функция]</em> <b>rationalp</b> <i>object</i>
</div>
<b>
<!--l. 1336--><p class="indent" >   <a 
href="symbols.html#x200-396777r777">rationalp</a></b> истинен, если аргумент рациональное число (дробь или целое),
в противном случае ложен. <div class="lisp"><tt><div class="tabbing">
(rationalp x) <span class="math"> ≡</span> (typep x &#x2019;rational)
   <br>
<!--l. 1340--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71009"></a>
<em>
                                                                          

                                                                          
<!--l. 1344--><p class="noindent" >[Функция]</em> <b>ﬂoatp</b> <i>object</i>
</div>
<b>
<!--l. 1346--><p class="indent" >   <a 
href="symbols.html#x200-396433r433">ﬂoatp</a></b> истинен, если аргумент число с плавающей точкой, в противном
случае ложен. <div class="lisp"><tt><div class="tabbing">
(ﬂoatp x) <span class="math"> ≡</span> (typep x &#x2019;ﬂoat)
   <br>
<!--l. 1350--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71010"></a>
<em>
<!--l. 1354--><p class="noindent" >[Функция]</em> <b>realp</b> <i>object</i>
</div>
<b>
<!--l. 1356--><p class="indent" >   <a 
href="symbols.html#x200-396791r791">realp</a></b> истинна, если аргумент является действительным числом, иначе
ложна. <div class="lisp"><tt><div class="tabbing">
(realp x) <span class="math"> ≡</span> (typep x &#x2019;real)
   <br>
<!--l. 1360--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
                                                                          

                                                                          
<div class="defunheader">
<a 
 id="dx43-71011"></a>
<em>
<!--l. 1364--><p class="noindent" >[Функция]</em> <b>complexp</b> <i>object</i>
</div>
<em>
<!--l. 1366--><p class="indent" >   complexp</em> истинен, если аргумент комплексное число, в противном случае
ложен. <div class="lisp"><tt><div class="tabbing">
(complexp x) <span class="math"> ≡</span> (typep x &#x2019;complex)
   <br>
<!--l. 1370--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71012"></a>
<em>
<!--l. 1374--><p class="noindent" >[Функция]</em> <b>characterp</b> <i>object</i>
</div>
<b>
<!--l. 1376--><p class="indent" >   <a 
href="symbols.html#x200-396235r235">characterp</a></b> истинен, если аргумент – буква, иначе ложен. <div class="lisp"><tt><div class="tabbing">
(characterp x) <span class="math"> ≡</span> (typep x &#x2019;character)
   <br>
<!--l. 1380--><p class="noindent" ></div>
</tt>
</div>
<hr>
                                                                          

                                                                          
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71013"></a>
<em>
<!--l. 1384--><p class="noindent" >[Функция]</em> <b>stringp</b> <i>object</i>
</div>
<b>
<!--l. 1386--><p class="indent" >   <a 
href="symbols.html#x200-396927r927">stringp</a></b> истинен, если аргумент строка, иначе ложен. <div class="lisp"><tt><div class="tabbing">
(stringp x) <span class="math"> ≡</span> (typep x &#x2019;string)
   <br>
<!--l. 1389--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71014"></a>
<em>
<!--l. 1393--><p class="noindent" >[Функция]</em> <b>bit-vector-p</b> <i>object</i>
</div>
<b>
<!--l. 1395--><p class="indent" >   <a 
href="symbols.html#x200-396146r146">bit-vector-p</a></b> истинен, если аргумент битовый вектор, иначе ложен.
<div class="lisp"><tt><div class="tabbing">
(bit-vector-p x) <span class="math"> ≡</span> (typep x &#x2019;bit-vector)
   <br>
                                                                          

                                                                          
<!--l. 1398--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71015"></a>
<em>
<!--l. 1402--><p class="noindent" >[Функция]</em> <b>vectorp</b> <i>object</i>
</div>
<b>
<!--l. 1404--><p class="indent" >   <a 
href="symbols.html#x200-397006r1006">vectorp</a></b> истинен, если аргумент вектор, иначе ложен. <div class="lisp"><tt><div class="tabbing">
(vectorp x) <span class="math"> ≡</span> (typep x &#x2019;vector)
   <br>
<!--l. 1407--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71016"></a>
<em>
<!--l. 1411--><p class="noindent" >[Функция]</em> <b>simple-vector-p</b> <i>object</i>
</div>
<b>
<!--l. 1413--><p class="indent" >   <a 
href="symbols.html#x200-397006r1006">vectorp</a></b> истинен, если аргумент простой общий вектор, иначе ложен.
<div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(simple-vector-p x) <span class="math"> ≡</span> (typep x &#x2019;simple-vector)
   <br>
<!--l. 1417--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71017"></a>
<em>
<!--l. 1421--><p class="noindent" >[Функция]</em> <b>simple-string-p</b> <i>object</i>
</div>
<b>
<!--l. 1423--><p class="indent" >   <a 
href="symbols.html#x200-396861r861">simple-string-p</a></b> истинен, если аргумент простая строка, иначе ложен.
<div class="lisp"><tt><div class="tabbing">
(simple-string-p x) <span class="math"> ≡</span> (typep x &#x2019;simple-string)
   <br>
<!--l. 1427--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71018"></a>
<em>
<!--l. 1431--><p class="noindent" >[Функция]</em> <b>simple-bit-vector-p</b> <i>object</i>
</div>
<b>
<!--l. 1433--><p class="indent" >   <a 
href="symbols.html#x200-396856r856">simple-bit-vector-p</a></b> истинен, если аргумент простой битовый вектор,
иначе ложен. <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(simple-bit-vector-p x) <span class="math"> ≡</span> (typep x &#x2019;simple-bit-vector)
   <br>
<!--l. 1437--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71019"></a>
<em>
<!--l. 1441--><p class="noindent" >[Функция]</em> <b>arrayp</b> <i>object</i>
</div>
<b>
<!--l. 1443--><p class="indent" >   <a 
href="symbols.html#x200-396122r122">arrayp</a></b> истинен, если аргумент массив, иначе ложен. <div class="lisp"><tt><div class="tabbing">
(arrayp x) <span class="math"> ≡</span> (typep x &#x2019;array)
   <br>
<!--l. 1446--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71020"></a>
<em>
<!--l. 1450--><p class="noindent" >[Функция]</em> <b>packagep</b> <i>object</i>
</div>
<b>
                                                                          

                                                                          
<!--l. 1452--><p class="indent" >   <a 
href="symbols.html#x200-396712r712">packagep</a></b> истинен, если аргумент является пакетом, иначе является
ложью. <div class="lisp"><tt><div class="tabbing">
(packagep x) <span class="math"> ≡</span> (typep x &#x2019;package)
   <br>
<!--l. 1456--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx43-71021"></a>
<em>
<!--l. 1460--><p class="noindent" >[Функция]</em> <b>functionp</b> <i>object</i>
</div>
<div class="lisp">
<tt>
<!--l. 1462--><p class="indent" >   <div class="tabbing">
(functionp x) <span class="math"> ≡</span> (typep x &#x2019;function)
   <br>
<!--l. 1464--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1465--><p class="indent" >   Типы <b>cons</b> и <b>symbol</b> непересекаются с типом <b><a 
href="symbols.html#x200-396446r446">function</a></b>. <b><a 
href="symbols.html#x200-396450r450">functionp</a></b>
является ложной для символов и списков.
<hr></div>
<div class="defun">
<div class="defunheader">
                                                                          

                                                                          
<a 
 id="dx43-71022"></a>
<em>
<!--l. 1472--><p class="noindent" >[Функция]</em> <b>compiled-function-p</b> <i>object</i>
</div>
<b>
<!--l. 1474--><p class="indent" >   <a 
href="symbols.html#x200-396263r263">compiled-function-p</a></b> истинен, если аргумент — скомпилированный
объект кода, иначе ложен. <div class="lisp"><tt><div class="tabbing">
(compiled-function-p x) <span class="math"> ≡</span> (typep x &#x2019;compiled-function)
   <br>
<!--l. 1478--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<!--l. 1481--><p class="indent" >   Смотрите также <b><a 
href="symbols.html#x200-396898r898">standard-char-p</a></b>, <b>string-char-p</b>, <b><a 
href="symbols.html#x200-396907r907">streamp</a></b>,
<b><a 
href="symbols.html#x200-396770r770">random-state-p</a></b>, <b><a 
href="symbols.html#x200-396790r790">readtablep</a></b>, <b><a 
href="symbols.html#x200-396481r481">hash-table-p</a></b> и <b><a 
href="symbols.html#x200-396726r726">pathnamep</a></b>.
                                                                          

                                                                          
<!--l. 1486--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse33.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse31.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse31.html#tailclmse31.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse32.html" >В-начало</a>&#x003E;&#x003C;<a 
href="preds.html#clmse32.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse32.html"></a>
 
</body></html> 
