<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Формы циклов</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2013-03-12 14:38:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="clmse43.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse41.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse41.html#tailclmse41.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse42.html">В-конец</a>&#x003E;&#x003C;<a 
href="contrl.html#clmse42.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">7.8
</span> <a 
href="clm.html#QQ2-54-93" id="x54-840007.8">Формы циклов</a></h3>
<a 
 id="dx54-84001"></a>
<!--l. 6934--><p class="noindent" >Common Lisp предоставляет некоторые конструкции для циклов.
Конструкция <b><a 
href="symbols.html#x200-396577r577">loop</a></b> предоставляет простую функциональность. Она слегка
больше, чем <b><a 
href="symbols.html#x200-396761r761">progn</a></b>, и имеет ветку для переноса управления снизу вверх.
Конструкции <b><a 
href="symbols.html#x200-396347r347">do</a></b> и <b><a 
href="symbols.html#x200-396348r348">do*</a></b> предоставляют общую функциональность для
управления на каждом цикле изменением нескольких переменных. Для
специализированных циклов над элементами списка или <em>n</em> последовательных
чисел предоставляются формы <b><a 
href="symbols.html#x200-396354r354">dolist</a></b> и <b><a 
href="symbols.html#x200-396355r355">dotimes</a></b>. Конструкция <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>
наиболее общая конструкция, которая внутри себя позволяет использование
выражений <b><a 
href="symbols.html#x200-396476r476">go</a></b>. (Традиционная конструкция <b><a 
href="symbols.html#x200-396757r757">prog</a></b> — это синтез <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>,
<b><a 
href="symbols.html#x200-396148r148">block</a></b> и <b><a 
href="symbols.html#x200-396543r543">let</a></b>.) Большинство конструкций циклов позволяют определённые
статически нелокальные выходы (смотрите <b><a 
href="symbols.html#x200-396817r817">return-from</a></b> и <b><a 
href="symbols.html#x200-396816r816">return</a></b>).
<!--l. 6947--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.8.1   </span> <a 
href="frontmatter.html#QQ2-54-94" id="x54-850007.8.1">Бесконечный цикл</a></h4>
<!--l. 6949--><p class="noindent" >Конструкция <b><a 
href="symbols.html#x200-396577r577">loop</a></b> является наипростейшей функциональностью для
итераций. Она не управляет переменными, и просто циклично выполняет
своё тело.
<div class="defmac">
<div class="defmacheader">
<!--l. 6953--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>loop</b> <a 
 id="dx54-85001"></a>{form}*
   <br>
<!--l. 6954--><p class="noindent" ></div>
</div>
<!--l. 6955--><p class="indent" >   Каждая форма <em>form</em> выполняется последовательно слева направо. Когда
                                                                          

                                                                          
вычислена последняя форма, тогда вычисляется первая форма и так далее, в
безостановочном цикле. Конструкция <b><a 
href="symbols.html#x200-396577r577">loop</a></b> никогда не возвращает значение.
Её выполнение может быть остановлено явно, с помощью <b><a 
href="symbols.html#x200-396816r816">return</a></b> или <b><a 
href="symbols.html#x200-396961r961">throw</a></b>,
например.
<b>
<!--l. 6961--><p class="indent" >   <a 
href="symbols.html#x200-396577r577">loop</a></b>, как и многие конструкции циклов, устанавливает неявный блок с
именем <b><a 
href="symbols.html#x200-396670r670">nil</a></b>. Таким образом, <b><a 
href="symbols.html#x200-396816r816">return</a></b> с заданным результатом может
использоваться для выхода и <b><a 
href="symbols.html#x200-396577r577">loop</a></b>.
<hr></div>
<!--l. 6967--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.8.2   </span> <a 
href="frontmatter.html#QQ2-54-95" id="x54-860007.8.2">Основные формы циклов</a></h4>
<!--l. 6969--><p class="noindent" >В отличие от <b><a 
href="symbols.html#x200-396577r577">loop</a></b>, <b><a 
href="symbols.html#x200-396347r347">do</a></b> и <b><a 
href="symbols.html#x200-396348r348">do*</a></b> предоставляют мощный механизм для
повторных вычислений большого количества переменных.
<div class="defmac">
<div class="defmacheader">
<!--l. 6974--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>do</b> <a 
 id="dx54-86001"></a>({var | (var [init [step]])}*)(end-test {result}*){declaration}* {tag | statement}*
   <br>
<!--l. 6976--><p class="noindent" ></div>
</div>
<div class="defmacheader">
<!--l. 6976--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>do*</b> <a 
 id="dx54-86002"></a>({var | (var [init [step]])}*)(end-test {result}*){declaration}* {tag | statement}*
   <br>
<!--l. 6980--><p class="noindent" ></div>
</div>
<!--l. 6981--><p class="indent" >   Оператор <b><a 
href="symbols.html#x200-396347r347">do</a></b> представляет общую функциональность цикла, с
произвольным количеством «переменных-индексов». Эти переменные
связываются при входе в цикл и параллельно наращиваются, как это было
задано. Они могут быть использованы, как для генерации необходимых
последовательных чисел (как, например, последовательные целые
                                                                          

                                                                          
числа), так и для накопления результата. Когда условие окончания
цикла успешно выполнилось, тогда цикл завершается с заданным
значением.
<!--l. 6990--><p class="indent" >   В общем виде <b><a 
href="symbols.html#x200-396347r347">do</a></b> выглядит так: <div class="lisp"><tt><div class="tabbing">
(do ((<em>var1</em> <em>init1</em> <em>step1</em>)
   <br>                                                                    (<em>var2</em> <em>init2</em> <em>step2</em>)<br>
     ...<br>                                               (<em>varn</em> <em>initn</em> <em>stepn</em>))<br>
    (<em>end-test</em> . <em>result</em>)<br>                                      {<i><em>declaration</em></i>}* <br>
  . <em>tagbody</em>)<br>
<!--l. 6999--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7000--><p class="indent" >   Цикл <b><a 
href="symbols.html#x200-396348r348">do*</a></b> выглядит также, кроме изменения имени с <b><a 
href="symbols.html#x200-396347r347">do</a></b> на <b><a 
href="symbols.html#x200-396348r348">do*</a></b>.
<!--l. 7002--><p class="indent" >   Первый элемент формы является списком нуля и более спецификаторов
переменных-индексов. Каждый спецификатор является списком из имени
переменной <em>var</em>, первоначального значения <em>init</em>, и форма приращения <em>step</em>.
Если <em>init</em> опущен, используется первоначальное значение <b><a 
href="symbols.html#x200-396670r670">nil</a></b>. Если <em>step</em>
опущен, <em>var</em> не изменяется на итерациях цикла (но может изменяться в теле
цикла с помощью формы <b><a 
href="symbols.html#x200-396845r845">setq</a></b>).
<!--l. 7010--><p class="indent" >   Спецификатор переменной-индекса может также быть просто именем
переменной. В этом случае переменная будет иметь первоначальное
значение <b><a 
href="symbols.html#x200-396670r670">nil</a></b> и не будет изменяться при итерациях цикла. В целях стиля,
использовать просто имя переменной рекомендуется, только если
перед первым использованием для неё устанавливается значение с
помощью <b><a 
href="symbols.html#x200-396845r845">setq</a></b>. Если необходимо чтобы первоначальное значение
было <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, а не неопределённое, то лучше указывать это явно, если
нужна ложь так: <b>(<em>varj</em> <b><a 
href="symbols.html#x200-396670r670">nil</a></b>)</b> или если нужен пустой список так: <b>(<em>varj</em>
&#x2019;())</b>.
<!--l. 7021--><p class="indent" >   Перед первой итерацией вычисляются все формы <em>init</em>, и каждая
переменная <em>var</em> связывается с соответствующим результатом вычислений
<em>init</em>. Используется именно связывание, а не присвоение. Когда цикл
завершается, старые значения этих переменных восстанавливаются. Для <b><a 
href="symbols.html#x200-396347r347">do</a></b>,
<em>все</em> формы <em>init</em> вычисляется перед тем, как будут связаны переменные <em>var</em>.
Таким образом все формы могут ссылаться на старые связывания этих
переменных (то есть на значения, которые были видимы до начала
                                                                          

                                                                          
выполнения конструкции <b><a 
href="symbols.html#x200-396347r347">do</a></b>). Для <b><a 
href="symbols.html#x200-396348r348">do*</a></b> вычисляется первая форма <em>init</em>,
затем первая переменная связывается с результатом этих вычислений. Затем
вычисляется вторая форма <em>init</em> и вторая переменная <em>var</em> связывается с этим
значением, и так далее. В целом, форма <em>initj</em> может ссылаться на <em>новые</em>
связывания <em>vark</em>, если <span class="math">k &#x003C; j</span>, иначе ссылка происходит на <em>старое</em>
связывание.
<!--l. 7037--><p class="indent" >   Второй элемент конструкции цикла это список из формы предиката-выхода
<em>end-test</em> и нуля и более форм результата <em>result</em>. Этот элемент напоминает
подвыражение <b><a 
href="symbols.html#x200-396281r281">cond</a></b>. В начале каждой итерации, после обработки всех
переменных, вычисляется форма <em>end-test</em>. Если результат <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, выполняется
тело формы <b><a 
href="symbols.html#x200-396347r347">do</a></b> (или <b><a 
href="symbols.html#x200-396348r348">do*</a></b>). Если результат не <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, последовательно
вычисляются формы <em>result</em>, как неявный <b><a 
href="symbols.html#x200-396761r761">progn</a></b>, и затем <b><a 
href="symbols.html#x200-396347r347">do</a></b> возвращает
управление. <b><a 
href="symbols.html#x200-396347r347">do</a></b> возвращает результаты вычисления последней формы <em>result</em>.
Если таких форм не быть, значением <b><a 
href="symbols.html#x200-396347r347">do</a></b> становиться <b><a 
href="symbols.html#x200-396670r670">nil</a></b>. Следует отметить,
что аналогия с подвыражениями <b><a 
href="symbols.html#x200-396281r281">cond</a></b> не полная, так как <b><a 
href="symbols.html#x200-396281r281">cond</a></b> в этом случае
возвращает результат формы условия.
<!--l. 7051--><p class="indent" >   Переменные-индексы изменяются в начале каждой непервой итерации
так, как написано далее. Слева направо вычисляются все формы <em>step</em>, и
затем результаты присваиваются переменным-индексам. Если такой формы
<em>step</em> для переменной указано не было, то переменная и не изменяется. Для
<b><a 
href="symbols.html#x200-396347r347">do</a></b>, все формы <em>step</em> вычисляются перед там, как будут изменены переменные.
Присваивания переменным осуществляются параллельно, как в <b><a 
href="symbols.html#x200-396765r765">psetq</a></b>. Так
как <em>все</em> формы <em>step</em> вычисляются перед тем, как будет изменена хоть одна
переменных, форма <em>step</em> при вычислении всегда ссылается на старые
значения <em>всех</em> переменных-индексов, даже если другие формы <em>step</em>
были выполнены. Для <b><a 
href="symbols.html#x200-396348r348">do*</a></b>, вычисляется первая форма <em>step</em>, затем
полученное значение присваивается первой переменной-индексом, затем
вычисляется вторая форма <em>step</em>, и полученное значение присваивается второй
переменной, и так далее. Присваивание происходит последовательно, как в
<b><a 
href="symbols.html#x200-396845r845">setq</a></b>. И для <b><a 
href="symbols.html#x200-396347r347">do</a></b>, и для <b><a 
href="symbols.html#x200-396348r348">do*</a></b> после того как переменные были изменены,
вычисляется <em>end-test</em> так, как уже было описано выше. Затем продолжаются
итерации.
<!--l. 7071--><p class="indent" >   Если <em>end-test</em> формы <b><a 
href="symbols.html#x200-396347r347">do</a></b> равен <b><b><a 
href="symbols.html#x200-396670r670">nil</a></b></b>, тогда предикат всегда ложен. Таким
образом получается «бесконечный цикл»: тело <em>body</em> <b><a 
href="symbols.html#x200-396347r347">do</a></b> выполняется
циклично, переменные-индексы изменяются как обычно. (Конструкция <b><a 
href="symbols.html#x200-396577r577">loop</a></b>
также является «бесконечным циклом», только без переменных-индексов.)
Бесконечный цикл может быть остановлен использованием <b><a 
href="symbols.html#x200-396816r816">return</a></b>,
<b><a 
href="symbols.html#x200-396817r817">return-from</a></b>, <b><a 
href="symbols.html#x200-396476r476">go</a></b> на более высокий уровень или <b><a 
href="symbols.html#x200-396961r961">throw</a></b>. Например:
                                                                          

                                                                          
<div class="lisp"><tt><div class="tabbing">
(do ((j 0 (+ j 1)))
   <br>                        (<b><a 
href="symbols.html#x200-396670r670">nil</a></b>)                        ;Выполнять вечно<br>
  (format t &#x0022;~%Input ~D:&#x0022; j)<br>                          (let ((item (read)))<br>
    (if (null item) (return)     ;Обрабатывать элементы пока не найден <b><a 
href="symbols.html#x200-396670r670">nil</a></b><br>
        (format t &#x0022;~&#x0026;Output ~D: ~S&#x0022; j (process item)))))<br>
<!--l. 7087--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7089--><p class="indent" >   Оставшаяся часть <b><a 
href="symbols.html#x200-396347r347">do</a></b> оборачивается в неявный <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>. Теги могут
использоваться внутри тела цикла <b><a 
href="symbols.html#x200-396347r347">do</a></b> для того, чтобы затем использовать
выражения <b><a 
href="symbols.html#x200-396476r476">go</a></b>. На такие выражения <b><a 
href="symbols.html#x200-396476r476">go</a></b> не могут использоваться в
спецификаторах переменных-индексов, в предикате <em>end-test</em> и в формах
результата <em>result</em>. Когда управление достигает конца тела цикла <b><a 
href="symbols.html#x200-396347r347">do</a></b>,
наступает следующая цикл итерации (начинающийся с вычисления форм
<em>step</em>).
<!--l. 7097--><p class="indent" >   Неявный <b><a 
href="symbols.html#x200-396148r148">block</a></b> с именем <b><a 
href="symbols.html#x200-396670r670">nil</a></b> окружает всю форму <b><a 
href="symbols.html#x200-396347r347">do</a></b>. Выражение <b><a 
href="symbols.html#x200-396816r816">return</a></b>
может использоваться в любом месте для немедленного выхода из
цикла.
<!--l. 7101--><p class="indent" >   Формы <b><a 
href="symbols.html#x200-396307r307">declare</a></b> могут использоваться в начала тела <b><a 
href="symbols.html#x200-396347r347">do</a></b>. Они применяются
к коду внутри тела <b><a 
href="symbols.html#x200-396347r347">do</a></b>, для связываний переменных-индексов, для форм
<em>init</em>, для форм <em>step</em>, для предиката <em>end-test</em> и для форм результата
<em>result</em>.
<!--l. 7106--><p class="indent" >   Вот парочка примеров использования <b><a 
href="symbols.html#x200-396347r347">do</a></b>: <div class="lisp"><tt><div class="tabbing">
(do ((i 0 (+ i 1))     ;Sets every null element of <b>a-vector</b> to zero
   <br>                                                                (n (length a-vector)))<br>
    ((= i n))<br>                                (when (null (aref a-vector i))<br>
    (setf (aref a-vector i) 0)))<br>
<!--l. 7113--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7114--><p class="indent" >   Конструкция <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(do ((x e (cdr x))
   <br>                                (oldx x x))<br>                               ((null x))<br>
  <em>body</em>)<br>
<!--l. 7120--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7121--><p class="indent" >   использует параллельное присваивание переменным-индексам. На первой
итерации значение <b>oldx</b> получает значение <b>x</b>, которое было до входа в цикл.
При выходе из цикла <b>oldx</b> будет содержать значение <b>x</b>, которое было на
предыдущей итерации.
<!--l. 7126--><p class="indent" >   Очень часто алгоритм цикла может быть по большей части выражен в
формах <em>step</em> и тело при этом останется пустым. Например, <div class="lisp"><tt><div class="tabbing">
(do ((x foo (cdr x))
   <br>                                                                         (y bar (cdr y))<br>
     (z &#x2019;() (cons (f (car x) (car y)) z)))<br>              ((or (null x) (null y))<br>
     (nreverse z)))<br>
<!--l. 7135--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7136--><p class="indent" >   делает то же, что и <b>(mapcar #&#x2019;f foo bar)</b>. Следует отметить, что
вычисление <em>step</em> для <b>z</b> использует тот факт, что переменные переприсваиваются
параллельно. Тело функции пустое. Наконец, использование <b><a 
href="symbols.html#x200-396680r680">nreverse</a></b> в
форме возврата результата, переставляет элементы списка для правильного
результата. Другой пример: <div class="lisp"><tt><div class="tabbing">
(defun list-reverse (list)
   <br>           (do ((x list (cdr x))<br>                (y &#x2019;() (cons (car x) y)))<br>
           ((endp x) y)))<br>
<!--l. 7147--><p class="noindent" ></div>
</tt>
                                                                          

                                                                          
</div>
<!--l. 7148--><p class="indent" >   Нужно заметить, что используется <b><a 
href="symbols.html#x200-396371r371">endp</a></b> вместо <b><a 
href="symbols.html#x200-396696r696">null</a></b> или <b><a 
href="symbols.html#x200-396133r133">atom</a></b> для
проверки конца списка. Это даёт более надёжный алгоритм.
<!--l. 7151--><p class="indent" >   В качестве примера вложенных циклов, предположим что <b>env</b> содержит
список cons-ячеек. <em>car</em> элемента каждой cons-ячейки является списком
символов, и <em>cdr</em> каждой cons-ячейки является списком такой же длины с
соответствующими значениями. Такая структура данных похожа на
ассоциативный список, но она в отличие разделена на «кадры». Общая
структура напоминает грудную клетку. Функция поиска по такой структуре
может быть такой: <div class="lisp"><tt><div class="tabbing">
(defun ribcage-lookup (sym ribcage)
   <br>                (do ((r ribcage (cdr r)))<br>                    ((null r) <b><a 
href="symbols.html#x200-396670r670">nil</a></b>)<br>
         (do ((s (caar r) (cdr s))<br>                   (v (cdar r) (cdr v)))<br>
             ((null s))<br>                          (when (eq (car s) sym)<br>
             (return-from ribcage-lookup (car v))))))<br>
<!--l. 7168--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7169--><p class="indent" >   (Примечание, использование отступов в примере выше выделяет тела
вложенных циклов.)
<!--l. 7172--><p class="indent" >   Цикл <b><a 
href="symbols.html#x200-396347r347">do</a></b> может быть выражен в терминах более примитивных
конструкций <b><a 
href="symbols.html#x200-396148r148">block</a></b>, <b><a 
href="symbols.html#x200-396816r816">return</a></b>, <b><a 
href="symbols.html#x200-396543r543">let</a></b>, <b><a 
href="symbols.html#x200-396577r577">loop</a></b>, <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b> и <b><a 
href="symbols.html#x200-396765r765">psetq</a></b>: <div class="lisp"><tt><div class="tabbing">
(block nil
   <br>                      (let ((<em>var1</em> <em>init1</em>)<br>                            (<em>var2</em> <em>init2</em>)<br>
        ...<br>                                                 (<em>varn</em> <em>initn</em>))<br>
     {<i><em>declaration</em></i>}* <br>          (loop (when <em>end-test</em> (return (progn . <em>result</em>)))<br>
          (tagbody . <em>tagbody</em>)<br>                        (psetq <em>var1</em> <em>step1</em><br>
                 <em>var2</em> <em>step2</em><br>                                       ...<br>
                 <em>varn</em> <em>stepn</em>))))<br>
<!--l. 7188--><p class="noindent" ></div>
</tt>
                                                                          

                                                                          
</div>
<b>
<!--l. 7189--><p class="indent" >   <a 
href="symbols.html#x200-396348r348">do*</a></b> почти то же, что и <b><a 
href="symbols.html#x200-396347r347">do</a></b> за исключением того, что связывание и
наращение переменных происходит последовательно, а не параллельно.
Таким образом, в вышеприведённой конструкции, <b><a 
href="symbols.html#x200-396543r543">let</a></b> будет заменена на <b><a 
href="symbols.html#x200-396544r544">let*</a></b>
и <b><a 
href="symbols.html#x200-396765r765">psetq</a></b> на <b><a 
href="symbols.html#x200-396845r845">setq</a></b>.
<hr></div>
<!--l. 7195--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.8.3   </span> <a 
href="frontmatter.html#QQ2-54-96" id="x54-870007.8.3">Простые формы циклов</a></h4>
<!--l. 7197--><p class="noindent" >Конструкции <b><a 
href="symbols.html#x200-396354r354">dolist</a></b> и <b><a 
href="symbols.html#x200-396355r355">dotimes</a></b> для каждого значения взятого для одной
переменной выполняют тело один раз. Они хоть и выражаются в терминах
<b><a 
href="symbols.html#x200-396347r347">do</a></b>, но захватывают очень простые шаблоны использования.
<!--l. 7201--><p class="indent" >   И <b><a 
href="symbols.html#x200-396354r354">dolist</a></b> и <b><a 
href="symbols.html#x200-396355r355">dotimes</a></b> циклично выполняют тело. На каждой итерации
заданная переменная связывается с элементом, которая затем может
использоваться в теле. <b><a 
href="symbols.html#x200-396354r354">dolist</a></b> использует элементы списка, и <b><a 
href="symbols.html#x200-396355r355">dotimes</a></b>
использует целые числа от 0 по <span class="math">n− 1</span>, при некотором указанном положительном
целом <em>n</em>.
<!--l. 7206--><p class="indent" >   Результат двух этих конструкций может быть указан с помощью
необязательной формы результата. Если эта форма опущена результат равен
<b><a 
href="symbols.html#x200-396670r670">nil</a></b>.
<!--l. 7209--><p class="indent" >   Выражение <b><a 
href="symbols.html#x200-396816r816">return</a></b> может быть использовано для немедленного возврата
из форм <b><a 
href="symbols.html#x200-396354r354">dolist</a></b> или <b><a 
href="symbols.html#x200-396355r355">dotimes</a></b>, игнорируя все оставшиеся итерации, которые
должны были быть выполнены. <b><a 
href="symbols.html#x200-396148r148">block</a></b> с именем <b><a 
href="symbols.html#x200-396670r670">nil</a></b> окружает конструкцию.
Тело цикла неявно обернуто конструкцией <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>. Таким образом тело
может содержать теги и <b><a 
href="symbols.html#x200-396476r476">go</a></b> выражения. Декларации могут быть указаны
перед телом цикла.
<div class="defmac">
<div class="defmacheader">
<!--l. 7217--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>dolist</b> <a 
 id="dx54-87001"></a>(var listform [resultform]){declaration}* {tag | statement}*
   <br>
<!--l. 7219--><p class="noindent" ></div>
</div>
                                                                          

                                                                          
<b>
<!--l. 7220--><p class="indent" >   <a 
href="symbols.html#x200-396354r354">dolist</a></b> предоставляет прямой цикл по списку элементов. Сначала <b><a 
href="symbols.html#x200-396354r354">dolist</a></b>
вычисляет форму <em>listform</em>, которая должна вернуть список. Затем для
каждого элемента вычисляется тело цикла. Данный элемент на каждой
итерации связывается с переменной <em>var</em>. Затем вычисляется <em>resultform</em> (одна
форма, <em>не</em> неявный <b><a 
href="symbols.html#x200-396761r761">progn</a></b>). (Когда вычисляется <em>resultform</em>, переменная <em>var</em>
все ещё связана, и имеет значение <b><a 
href="symbols.html#x200-396670r670">nil</a></b>.) Если <em>resultform</em> опущена, то результат
равен <b><a 
href="symbols.html#x200-396670r670">nil</a></b>. <div class="lisp"><tt><div class="tabbing">
(dolist (x &#x2019;(a b c d)) (prin1 x) (princ &#x0022; &#x0022;)) <span class="math"> ⇒</span> <b><a 
href="symbols.html#x200-396670r670">nil</a></b>
   <br>                         вывод «<b>a b c d </b>» (в том числе пробел в конце)<br>
<!--l. 7232--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7233--><p class="indent" >   Для завершения цикла и возврата заданного значения может использоваться
явное выражение <b><a 
href="symbols.html#x200-396816r816">return</a></b>.
<!--l. 7236--><p class="indent" >   Пользователь ограничен в создании побочных действий так, как это
описано в разделе <a 
href="clmse43.html#x55-900007.9">7.9<!--tex4ht:ref: STRUCTURE-TRAVERSAL-SECTION --></a>
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 7241--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>dotimes</b> <a 
 id="dx54-87002"></a>(var countform [resultform]){declaration}* {tag | statement}*
   <br>
<!--l. 7243--><p class="noindent" ></div>
</div>
<b>
<!--l. 7244--><p class="indent" >   <a 
href="symbols.html#x200-396355r355">dotimes</a></b> предоставляет цикл над последовательностью целых чисел.
Выражение <b>(dotimes (<em>var</em> <em>countform</em> <em>resultform</em>) . <em>progbody</em>)</b> вычисляет
форму <em>countform</em>, которая должна вернуть целое число. Затем тело
цикла выполняется по порядку один раз для каждого число от нуля
(включительно) до <em>count</em> (исключая). При этом переменная <em>var</em> связывается
с текущим целым числом. Если значение <em>countform</em> отрицательно
                                                                          

                                                                          
или равно нулю, тогда <em>progbody</em> не выполняется ни разу. Наконец
выполняется <em>resultform</em> (одна форма, <em>не</em> неявный <b><a 
href="symbols.html#x200-396761r761">progn</a></b>), и полученный
результат возвращается из формы цикла. (Когда <em>result</em> вычисляется,
переменная-индекс <em>var</em> все ещё связана и содержит количество выполненных
итераций.) Если <em>resultform</em> опущена, то результат равен <b><a 
href="symbols.html#x200-396670r670">nil</a></b>.
<!--l. 7258--><p class="indent" >   Для завершения цикла и возврата заданного значения может использоваться
выражение <b><a 
href="symbols.html#x200-396816r816">return</a></b>.
<!--l. 7261--><p class="indent" >   Пример использования <b><a 
href="symbols.html#x200-396355r355">dotimes</a></b> для обработки строк: <div class="lisp"><tt><div class="tabbing">
;;; True if the speciﬁed subsequence of the string is a
   <br>                     ;;; palindrome (reads the same forwards and backwards).<br>
<br>                                    (defun palindromep (string <b>&#x0026;optional</b><br>
                           (start 0)<br>
                           (end (length string)))<br>
  (dotimes (k (ﬂoor (- end start) 2) <b><a 
href="symbols.html#x200-396951r951">t</a></b>)<br>
    (unless (char-equal (char string (+ start k))<br>
                        (char string (- end k 1)))<br>       (return <b><a 
href="symbols.html#x200-396670r670">nil</a></b>))))<br>
<br>                          (palindromep &#x0022;Able was I ere I saw Elba&#x0022;) <span class="math"> ⇒</span> <b><a 
href="symbols.html#x200-396951r951">t</a></b><br>
<br>                  (palindromep &#x0022;A man, a plan, a canal–Panama!&#x0022;) <span class="math"> ⇒</span> <b><a 
href="symbols.html#x200-396670r670">nil</a></b><br>
<br>          (remove-if-not #&#x2019;alpha-char-p     ;Удалить знаки препинания<br>
               &#x0022;A man, a plan, a canal–Panama!&#x0022;)<br>
   <span class="math"> ⇒</span> &#x0022;AmanaplanacanalPanama&#x0022;<br>                                       <br>
(palindromep<br>                                (remove-if-not #&#x2019;alpha-char-p<br>
                &#x0022;A man, a plan, a canal–Panama!&#x0022;)) <span class="math"> ⇒</span> <b><a 
href="symbols.html#x200-396951r951">t</a></b><br><br>(palindromep<br>
 (remove-if-not<br>                                            #&#x2019;alpha-char-p<br>
   &#x0022;Unremarkable was I ere I saw Elba Kramer, nu?&#x0022;)) <span class="math"> ⇒</span> <b><a 
href="symbols.html#x200-396951r951">t</a></b><br>              <br>
(palindromep<br>                                               (remove-if-not<br>
   #&#x2019;alpha-char-p<br>                   &#x0022;A man, a plan, a cat, a ham, a yak,<br>
                   a yam, a hat, a canal–Panama!&#x0022;)) <span class="math"> ⇒</span> <b><a 
href="symbols.html#x200-396951r951">t</a></b><br>
(palindromep<br>               (remove-if-not<br>                 #&#x2019;alpha-char-p<br>
   &#x0022;Ja-da, ja-da, ja-da ja-da jing jing jing&#x0022;)) <span class="math"> ⇒</span> <b><a 
href="symbols.html#x200-396670r670">nil</a></b><br>
<!--l. 7301--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7303--><p class="indent" >   Изменение значения переменной <em>var</em> в теле цикла (с помощью <b><a 
href="symbols.html#x200-396845r845">setq</a></b>
например) будет иметь непредсказуемые последствия, возможно зависящие
                                                                          

                                                                          
от реализации. Компилятор Common Lisp&#x2019;а может вывести предупреждение о
том, что переменная-индекс используется в <b><a 
href="symbols.html#x200-396845r845">setq</a></b>.
<hr></div>
<!--l. 7309--><p class="indent" >   Смотрите также <b><a 
href="symbols.html#x200-396351r351">do-symbols</a></b>, <b><a 
href="symbols.html#x200-396350r350">do-external-symbols</a></b> и <b><a 
href="symbols.html#x200-396349r349">do-all-symbols</a></b>.
<!--l. 7312--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.8.4   </span> <a 
href="frontmatter.html#QQ2-54-97" id="x54-880007.8.4">Отображение</a></h4>
<a 
 id="dx54-88001"></a>
<!--l. 7315--><p class="noindent" >Отображение — это тип цикла, в котором заданная функция применяется к
частям одной или более последовательностей. Результатом цикла является
последовательность, полученная из результатов выполнения это функции.
Существует несколько опции для указания того, какие части списка будут
использоваться в цикле, и что будет происходить с результатом применения
функции.
<!--l. 7322--><p class="indent" >   Функция <b><a 
href="symbols.html#x200-396612r612">map</a></b> может быть использована для отображения любого
типа последовательности. Следующие же функции оперируют только
списками.
<div class="defun">
<div class="defunheader">
<a 
 id="dx54-88002"></a>
<em>
<!--l. 7327--><p class="noindent" >[Функция]</em> <b>mapcar</b> <i>function</i> <i>list</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>more-lists</i><br />
<a 
 id="dx54-88003"></a>
<em>
[Функция]</em> <b>maplist</b> <i>function</i> <i>list</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>more-lists</i><br />
<a 
 id="dx54-88004"></a>
<em>
[Функция]</em> <b>mapc</b> <i>function</i> <i>list</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>more-lists</i><br />
<a 
 id="dx54-88005"></a>
<em>
[Функция]</em> <b>mapl</b> <i>function</i> <i>list</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>more-lists</i><br />
<a 
 id="dx54-88006"></a>
<em>
[Функция]</em> <b>mapcan</b> <i>function</i> <i>list</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>more-lists</i><br />
<a 
 id="dx54-88007"></a>
                                                                          

                                                                          
<em>
[Функция]</em> <b>mapcon</b> <i>function</i> <i>list</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>more-lists</i>
</div>
<!--l. 7334--><p class="indent" >   Для каждой из этих функций отображения, первый аргумент является
функцией и оставшиеся аргументы должны быть списками. Функция в
первом аргументе должно принимать столько аргументов, сколько было
передано списков в функцию отображения.
<b>
<!--l. 7339--><p class="indent" >   <a 
href="symbols.html#x200-396617r617">mapcar</a></b> последовательно обрабатывает элементы списков. Сначала
функция применяется к <em>car</em> элементу каждого списка, затем к <em>cadr</em> элементу,
и так далее. (Лучше всего, чтобы все переданные списки имели одинаковую
длину. Если это не так, то цикл завершиться, как только закончится самый
короткий список, и все оставшиеся элементы в других списках будут
проигнорированы.) Значение, возвращаемое <b><a 
href="symbols.html#x200-396617r617">mapcar</a></b>, является списком
результатов последовательных вызовов функции из первого параметра.
Например: <div class="lisp"><tt><div class="tabbing">
(mapcar #&#x2019;abs &#x2019;(3 -4 2 -5 -6)) <span class="math"> ⇒</span> (3 4 2 5 6)
   <br>                (mapcar #&#x2019;cons &#x2019;(a b c) &#x2019;(1 2 3)) <span class="math"> ⇒</span> ((a . 1) (b . 2) (c . 3))<br>
<!--l. 7351--><p class="noindent" ></div>
</tt>
</div>
<b>
<!--l. 7353--><p class="indent" >   <a 
href="symbols.html#x200-396621r621">maplist</a></b> похожа на <b><a 
href="symbols.html#x200-396617r617">mapcar</a></b> за исключением того, что функция
применяется к спискам и последующим <em>cdr</em> элементам этих списков, а не
последовательно к элементам спискам. Например: <div class="lisp"><tt><div class="tabbing">
(maplist #&#x2019;(lambda (x) (cons &#x2019;foo x))
   <br>                                                                            &#x2019;(a b c d))<br>
   <span class="math"> ⇒</span> ((foo a b c d) (foo b c d) (foo c d) (foo d))<br>
<!--l. 7361--><p class="noindent" ></div>
</tt>
</div>
                                                                          

                                                                          
<div class="lisp">
<tt>
<!--l. 7363--><p class="indent" >   <div class="tabbing">
(maplist #&#x2019;(lambda (x) (if (member (car x) (cdr x)) 0 1)))
   <br>                        &#x2019;(a b a c d b c))<br>                  <span class="math"> ⇒</span> (0 0 1 0 1 1 1)<br>
   ;Возвращается <b>1</b>, если соответствующий элемент входящего списка<br>
   ;  появлялся последний раз в данном списке.<br>
<!--l. 7369--><p class="noindent" ></div>
</tt>
</div>
<b>
<!--l. 7371--><p class="indent" >   <a 
href="symbols.html#x200-396620r620">mapl</a></b> и <b><a 
href="symbols.html#x200-396615r615">mapc</a></b> похожи на <b><a 
href="symbols.html#x200-396621r621">maplist</a></b> и <b><a 
href="symbols.html#x200-396617r617">mapcar</a></b>, соответственно, за
исключением того, что они не накапливают результаты вызова функций.
<!--l. 7374--><p class="indent" >   Эти функции используются, когда функция в первом параметре
предназначена для побочных эффектов, а не для возвращаемого значения.
Значение возвращаемое <b><a 
href="symbols.html#x200-396620r620">mapl</a></b> или <b><a 
href="symbols.html#x200-396615r615">mapc</a></b> является вторым аргументом, то
есть первой последовательностью для отображения.
<b>
<!--l. 7379--><p class="indent" >   <a 
href="symbols.html#x200-396616r616">mapcan</a></b> и <b><a 
href="symbols.html#x200-396618r618">mapcon</a></b> похожи на <b><a 
href="symbols.html#x200-396617r617">mapcar</a></b> и <b><a 
href="symbols.html#x200-396621r621">maplist</a></b> соответственно, за
исключением того, что результат создаётся с помощью функции <b><a 
href="symbols.html#x200-396666r666">nconc</a></b>, а не
<b><a 
href="symbols.html#x200-396547r547">list</a></b>. То есть, <div class="lisp"><tt><div class="tabbing">
(mapcon <em>f </em> <em>x1</em> ... <em>xn</em>)
   <br>                                       <span class="math"> ≡</span> (apply #&#x2019;nconc (maplist <em>f </em> <em>x1</em> ... <em>xn</em>))<br>
<!--l. 7385--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7386--><p class="indent" >   Такое же различие между <b><a 
href="symbols.html#x200-396616r616">mapcan</a></b> и <b><a 
href="symbols.html#x200-396617r617">mapcar</a></b>. Концептуально, эти
функции позволяют функции отображения возвращать переменное
количество элементов. Таким образом длина результата может быть не равна
длине входного списка. Это, в частности, полезно для возврата нуля или
одного элемента: <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(mapcan #&#x2019;(lambda (x) (and (numberp x) (list x)))
   <br>                                                                   &#x2019;(a 1 b c 3 4 d 5))<br>
   <span class="math"> ⇒</span> (1 3 4 5)<br>
<!--l. 7395--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7396--><p class="indent" >   В этом случае функция действует, как фильтр. Это стандартная
Lisp&#x2019;овая идиома использования <b><a 
href="symbols.html#x200-396616r616">mapcan</a></b>. (Однако, в этом контексте
функция <b><a 
href="symbols.html#x200-396804r804">remove-if-not</a></b> также может быть полезна.) Помните, что <b><a 
href="symbols.html#x200-396666r666">nconc</a></b>
деструктивная операция, следовательно и <b><a 
href="symbols.html#x200-396616r616">mapcan</a></b> и <b><a 
href="symbols.html#x200-396618r618">mapcon</a></b> также
деструктивны. Список возвращаемый функцией <em>function</em> изменяется для
соединения и возврата результата.
<!--l. 7403--><p class="indent" >   Иногда <b><a 
href="symbols.html#x200-396347r347">do</a></b> или прямая последовательная рекурсия удобнее, чем функции
отображения. Однако, функции отображения должны быть использованы
везде, где они действительно необходимы, так как они увеличивают ясность
кода.
<!--l. 7407--><p class="indent" >   Функциональный аргумент функции отображения должен быть
подходящим для функции <b><a 
href="symbols.html#x200-396101r101">apply</a></b>. Он не может быть макросом или именем
оператора. Кроме того, в качестве функционального аргумента можно
использовать функцию, имеющую <b>&#x0026;optional</b> и <b>&#x0026;rest</b> параметры.
<!--l. 7412--><p class="indent" >   Пользователь ограничен в создании побочных действий так, как это
описано в разделе <a 
href="clmse43.html#x55-900007.9">7.9<!--tex4ht:ref: STRUCTURE-TRAVERSAL-SECTION --></a>
<hr></div>
<!--l. 7416--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.8.5   </span> <a 
href="frontmatter.html#QQ2-54-98" id="x54-890007.8.5">Использование «GOTO»</a></h4>
<!--l. 7418--><p class="noindent" >Реализации Lisp&#x2019;а начиная с Lisp&#x2019;а 1.5 содержат то, что изначально
называлось «the program feature», как будто без этого невозможно писать
программы! Конструкция <b><a 
href="symbols.html#x200-396757r757">prog</a></b> позволяет писать в Algol- или Fortran-
императивном стиле, используя выражения <b><a 
href="symbols.html#x200-396476r476">go</a></b>, которые могут ссылаться на
теги в теле <b><a 
href="symbols.html#x200-396757r757">prog</a></b>. Современный стиль программирования на Lisp&#x2019;е стремится
снизить использование <b><a 
href="symbols.html#x200-396757r757">prog</a></b>. Различные конструкции циклов, как <b><a 
href="symbols.html#x200-396347r347">do</a></b>, имеют
тела с характеристиками <b><a 
href="symbols.html#x200-396757r757">prog</a></b>. (Тем не менее, возможность использовать
выражения <b><a 
href="symbols.html#x200-396476r476">go</a></b> внутри конструкции цикла очень редко используется на
                                                                          

                                                                          
практике.)
<b>
<!--l. 7428--><p class="indent" >   <a 
href="symbols.html#x200-396757r757">prog</a></b> предоставляет три различные операции: связывание локальный
переменных, использование выражения <b><a 
href="symbols.html#x200-396816r816">return</a></b> и использование выражения
<b><a 
href="symbols.html#x200-396476r476">go</a></b>. В Common Lisp&#x2019;е эти три операции были разделены на три конструкции:
<b><a 
href="symbols.html#x200-396543r543">let</a></b>, <b><a 
href="symbols.html#x200-396148r148">block</a></b> и <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>. Эти три конструкции могут использоваться
независимо, как строительные кирпичики для других типов конструкций.
<div class="defspec">
<div class="defmacheader">
<!--l. 7438--><p class="indent" >   <div class="tabbing">
 <em>[Специальный оператор]</em> <b>tagbody</b> <a 
 id="dx54-89001"></a>{tag | statement}*
   <br>
<!--l. 7439--><p class="noindent" ></div>
</div>
<!--l. 7440--><p class="indent" >   Часть <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b> после списка переменные называется <em>телом</em>. Элемент
тела может быть символов или целым числом, и называться в этом случае
<em>тег</em>. Также элемент тела может быть списком, и называться в этом случае
<em>выражением</em>.
<!--l. 7445--><p class="indent" >   Каждый элемент тела обрабатывается слева направо. <em>Теги</em> игнорируются.
<em>Выражения</em> вычисляются и их результаты игнорируются. Если управление
достигает конца тела, <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b> возвращает <b><a 
href="symbols.html#x200-396670r670">nil</a></b>.
<!--l. 7450--><p class="indent" >   Если вычисляется форма <b>(go <em>tag</em>)</b>, управление перемещается на часть
тела, обозначенную <em>тегом</em>.
<!--l. 7453--><p class="indent" >   Область видимости тегов, устанавливаемых в <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>, является
лексической. Продолжительность видимости тегов динамическая. Когда
управление вышло из конструкции <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>, ссылка <b><a 
href="symbols.html#x200-396476r476">go</a></b> на теги в её теле
невозможны. Существует возможность для <b><a 
href="symbols.html#x200-396476r476">go</a></b> прыжка в <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>, которая
не находится внутри конструкции <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>, которая и содержала
этот <b><a 
href="symbols.html#x200-396476r476">go</a></b>. То есть возможны прыжки в родительский <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>. Теги
устанавливаемые <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b> будут только скрывать другие одноимённые
теги.
<!--l. 7462--><p class="indent" >   Лексическая область видимости для тегов (целей <b><a 
href="symbols.html#x200-396476r476">go</a></b>) полностью
полноправно и последствия могут быть сюрпризом для пользователей и
разработчиков других Lisp систем. Например, <b><a 
href="symbols.html#x200-396476r476">go</a></b> в следующем примере,
работает в Common Lisp так, как это и ожидается: <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(tagbody
   <br>         (catch &#x2019;stuﬀ<br>            (mapcar #&#x2019;(lambda (x) (if (numberp x)<br>
                                (hairyfun x)<br>
                                (go lose)))<br>                 items))<br>
   (return)<br>                                                           lose<br>
   (error &#x0022;I lost big!&#x0022;))<br>
<!--l. 7477--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7478--><p class="indent" >   В зависимости от ситуации, <b><a 
href="symbols.html#x200-396476r476">go</a></b> в Common Lisp&#x2019;е не обязательно похож на
простую машинную инструкцию «jump». Если необходимо, <b><a 
href="symbols.html#x200-396476r476">go</a></b> может
перепрыгивать ловушки исключений. Возможно так, что «замыкание»,
созданное с помощью <b><a 
href="symbols.html#x200-396446r446">function</a></b>, для лямбда-выражения ссылается на тег
(цель <b><a 
href="symbols.html#x200-396476r476">go</a></b>) так долго, сколько лексически доступен данный тег. Смотрите <a 
href="scope.html#x25-410003">3<!--tex4ht:ref: SCOPE --></a>
для понимания этого примера.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 7487--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>prog</b> <a 
 id="dx54-89002"></a>({var | (var [init])}*) {declaration}* {tag | statement}*
   <br>
<!--l. 7487--><p class="noindent" ></div>
</div>
<div class="defmacheader">
<!--l. 7487--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>prog*</b> <a 
 id="dx54-89003"></a>({var | (var [init])}*) {declaration}* {tag | statement}*
   <br>
<!--l. 7489--><p class="noindent" ></div>
</div>
<!--l. 7490--><p class="indent" >   Конструкция <b><a 
href="symbols.html#x200-396757r757">prog</a></b> является синтезом <b><a 
href="symbols.html#x200-396543r543">let</a></b>, <b><a 
href="symbols.html#x200-396148r148">block</a></b> и <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>, позволяющая
связывать переменные, использовать <b><a 
href="symbols.html#x200-396816r816">return</a></b> и <b><a 
href="symbols.html#x200-396476r476">go</a></b> в одной конструкции.
                                                                          

                                                                          
Обычно конструкция <b><a 
href="symbols.html#x200-396757r757">prog</a></b> выглядит так: <div class="lisp"><tt><div class="tabbing">
(prog (<em>var1</em> <em>var2</em> (<em>var3</em> <em>init3</em>) <em>var4</em> (<em>var5</em> <em>init5</em>))
   <br>                                                                         {<i><em>declaration</em></i>}* <br>
      <em>statement1</em><br>                                                    <em>tag1</em><br>
      <em>statement2</em><br>                                            <em>statement3</em><br>
      <em>statement4</em><br>                                                    <em>tag2</em><br>
      <em>statement5</em><br>                                                     ...<br>
      )<br>
<!--l. 7505--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7506--><p class="indent" >   Список после ключевого символа <b><a 
href="symbols.html#x200-396757r757">prog</a></b> является множеством
спецификаторов для связывания переменных <em>var1</em>, <em>var2</em>. Этот список
обрабатывается так же, как и в выражении <b><a 
href="symbols.html#x200-396543r543">let</a></b>: сначала слева направо
выполняются все формы <em>init</em> (если формы нет, берётся значение <b><a 
href="symbols.html#x200-396670r670">nil</a></b>), и затем
переменные параллельно связываются с полученными ранее значениями.
Возможно использовать <em>декларации</em> в начале дела <b><a 
href="symbols.html#x200-396757r757">prog</a></b> так же, как и в
<b><a 
href="symbols.html#x200-396543r543">let</a></b>.
<!--l. 7515--><p class="indent" >   Тело <b><a 
href="symbols.html#x200-396757r757">prog</a></b> выполняется, как обернутое в <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>. Таким образом, для
перемещения управления к <em>тегу</em> могут использоваться выражения
<b><a 
href="symbols.html#x200-396476r476">go</a></b>.
<b>
<!--l. 7518--><p class="indent" >   <a 
href="symbols.html#x200-396757r757">prog</a></b> неявно устанавливает вокруг тела <b><a 
href="symbols.html#x200-396148r148">block</a></b> с именем <b><a 
href="symbols.html#x200-396670r670">nil</a></b>. Это значит,
можно в любое время использовать <b><a 
href="symbols.html#x200-396816r816">return</a></b> для выхода из конструкции
<b><a 
href="symbols.html#x200-396757r757">prog</a></b>.
<!--l. 7521--><p class="indent" >   Вот небольшой пример того, что можно сделать с помощью <b><a 
href="symbols.html#x200-396757r757">prog</a></b>:
<div class="lisp"><tt><div class="tabbing">
(defun king-of-confusion (w)
   <br>                           &#x0022;Take a cons of two lists and make a list of conses.<br>
   Think of this function as being like a zipper.&#x0022;<br>
  (prog (x y z)     ;Инициализировать <b>x</b>, <b>y</b>, <b>z</b> в <b><a 
href="symbols.html#x200-396670r670">nil</a></b><br>
        (setq y (car w) z (cdr w))<br>                                   loop<br>
                                                                          

                                                                          
        (cond ((null y) (return x))<br>                   ((null z) (go err)))<br>
   rejoin<br>                          (setq x (cons (cons (car y) (car z)) x))<br>
        (setq y (cdr y) z (cdr z))<br>                              (go loop)<br>
   err<br>                           (cerror &#x0022;Will self-pair extraneous items&#x0022;<br>
                &#x0022;Mismatch - gleep!  S&#x0022; y)<br>                   (setq z y)<br>
        (go rejoin)))<br>
<!--l. 7540--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7541--><p class="indent" >   которые делает то же, что и: <div class="lisp"><tt><div class="tabbing">
(defun prince-of-clarity (w)
   <br>                           &#x0022;Take a cons of two lists and make a list of conses.<br>
   Think of this function as being like a zipper.&#x0022;<br>
  (do ((y (car w) (cdr y))<br>                              (z (cdr w) (cdr z))<br>
       (x &#x2019;() (cons (cons (car y) (car z)) x)))<br>                 ((null y) x)<br>
    (when (null z)<br>               (cerror &#x0022;Will self-pair extraneous items&#x0022;<br>
              &#x0022;Mismatch - gleep!  S&#x0022; y)<br>                   (setq z y))))<br>
<!--l. 7554--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7556--><p class="indent" >   Конструкция <b><a 
href="symbols.html#x200-396757r757">prog</a></b> может быть выражена в терминах более простых
конструкций <b><a 
href="symbols.html#x200-396148r148">block</a></b>, <b><a 
href="symbols.html#x200-396543r543">let</a></b> и <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>: <div class="lisp"><tt><div class="tabbing">
(prog <em>variable-list</em> {<i><em>declaration</em></i>}*  . <em>body</em>)
   <br>        <span class="math"> ≡</span> (block nil (let <em>variable-list</em> {<i><em>declaration</em></i>}*  (tagbody . <em>body</em>)))<br>
<!--l. 7561--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7563--><p class="indent" >   Оператор <b><a 
href="symbols.html#x200-396758r758">prog*</a></b> очень похож на <b><a 
href="symbols.html#x200-396757r757">prog</a></b>. Одно отличие в том, что
связывание и инициализация переменных осуществляется <em>последовательно</em>,
тем самым форма <em>init</em> использовать значения ранее связанных переменных.
Таким образом <b><a 
href="symbols.html#x200-396758r758">prog*</a></b> относится к <b><a 
href="symbols.html#x200-396757r757">prog</a></b>, как <b><a 
href="symbols.html#x200-396544r544">let*</a></b> к <b><a 
href="symbols.html#x200-396543r543">let</a></b>. Например,
<div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(prog* ((y z) (x (car y)))
   <br>                                                                             (return x))<br>
<!--l. 7571--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7572--><p class="indent" >   возвращает <em>car</em> элемент значения <b>z</b>.
<hr></div>
<div class="defspec">
<div class="defmacheader">
<!--l. 7576--><p class="indent" >   <div class="tabbing">
 <em>[Специальный оператор]</em> <b>go</b> <a 
 id="dx54-89004"></a>tag
   <br>
<!--l. 7577--><p class="noindent" ></div>
</div>
<!--l. 7578--><p class="indent" >   Оператор <b>(go <em>tag</em>)</b> используется для применения «goto» внутри
конструкции <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>. <em>tag</em> должен быть символов или целым числом. <em>tag</em> не
вычисляется. <b><a 
href="symbols.html#x200-396476r476">go</a></b> переносит управление на точку тела, которая была
помечена тегом равным <b><a 
href="symbols.html#x200-396379r379">eql</a></b> заданному. Если такого тега в теле нет, поиск
осуществляется в лексически доступном теле другой конструкции <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>.
Использоваться <b><a 
href="symbols.html#x200-396476r476">go</a></b> с тегом, которого нет, является ошибкой.
<!--l. 7586--><p class="indent" >   Форма <b><a 
href="symbols.html#x200-396476r476">go</a></b> никогда не возвращает значение.
<!--l. 7588--><p class="indent" >   В целях хорошего стиля, рекомендуется дважды подумать, прежде чем
использовать <b><a 
href="symbols.html#x200-396476r476">go</a></b>. Большинство функций <b><a 
href="symbols.html#x200-396476r476">go</a></b> могут быть заменены циклами,
вложенными условными формами или <b><a 
href="symbols.html#x200-396817r817">return-from</a></b>. Если использование <b><a 
href="symbols.html#x200-396476r476">go</a></b>
неизбежно, рекомендуется управляющую структуру реализованную с
помощью <b><a 
href="symbols.html#x200-396476r476">go</a></b> «упаковать» в определении макроса.
<hr></div>
                                                                          

                                                                          
<!--l. 7595--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse43.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse41.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse41.html#tailclmse41.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse42.html" >В-начало</a>&#x003E;&#x003C;<a 
href="contrl.html#clmse42.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse42.html"></a>
 
</body></html> 
