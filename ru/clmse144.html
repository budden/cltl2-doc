<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Функции для работы с CLOS</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2013-01-10 13:49:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="condition.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse143.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse143.html#tailclmse143.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse144.html">В-конец</a>&#x003E;&#x003C;<a 
href="clos.html#clmse144.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">27.2
</span> <a 
href="clm.html#QQ2-176-346" id="x176-30200027.2">Функции для работы с CLOS</a></h3>
<!--l. 8089--><p class="noindent" >Данный раздел описывает функции, макросы, специальные операторы и
обобщённые функции для работы с CLOS. Данный интерфейс охватывает
функции и макросы, которых достаточно для написания большинства
объектно-ориентированных программ.
<!--l. 8093--><p class="indent" >   Описание каждой функции, макроса, специального оператора и
обобщённой функции включает предназначение, синтаксис, семантику
аргументов, возвращаемые значения и часто примеры и ссылки на связанные
функции.
<!--l. 8097--><p class="indent" >   Описание синтаксиса для функции, макроса или специального оператора
содержит информацию о их параметрах. Описание обобщённой функции
включает описание методов, которые для этой функции определены в
CLOS. <em>Сигнатура метода</em> используется для описания параметров и их
специализаторов для каждого метода.
<!--l. 8103--><p class="indent" >   Следующий пример показывает формат описания обобщённой функции с
сигнатурой для главного метода.
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302001"></a>
<em>
<!--l. 8107--><p class="noindent" >[Обобщённая функция]</em> <b>f</b> <i>x</i> <i>y</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>z</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;key</a></tt> <i>:k</i><br />
<a 
 id="dx176-302002"></a>
<em>
[Главный метод]</em> <b>f</b> (<i>x</i> class) (<i>y</i> t) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>z</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;key</a></tt> <i>:k</i>
</div>
<!--l. 8110--><p class="indent" >   Данное описание показывается, что обобщённая функция <b><a 
href="symbols.html#x188-380395r395">f</a></b> имеет
два обязательных параметра: <em>x</em> и <em>y</em>. Кроме того присутствуют один
необязательный параметр <em>z</em> и именованный параметр <b>:k</b>.
<!--l. 8114--><p class="indent" >   Сигнатура метода показывает, что этот метод для обобщённой функции <b><a 
href="symbols.html#x188-380395r395">f</a></b>
                                                                          

                                                                          
имеет два обязательных параметра, <em>x</em>, который должен быть экземпляром
класса <b>class</b>, и <em>y</em>, который может быть любым объектом. Кроме того
присутствуют один необязательный параметр <em>z</em> и именованный параметр <b>:k</b>.
Сигнатура также показывает, что этот метод <b><a 
href="symbols.html#x188-380395r395">f</a></b> является главным и не имеет
квалификаторов.
<!--l. 8120--><p class="indent" >   Описание синтаксиса для обобщённой функции описывает лямбда-список
самой функции, тогда как сигнатура метода описывает лямбда-списки
определённых методов.
<hr></div>
<!--l. 8124--><p class="indent" >   Обобщённые функции, описанные в данной книге, являются
стандартными. Все они используют стандартный механизм сочетания
методов.
<!--l. 8127--><p class="indent" >   Любая реализация CLOS может предоставлять дополнительные методы
для описанных здесь обобщённых функций.
<!--l. 8130--><p class="indent" >   Функции и макросы можно распределить по категориям так:
      <ul class="itemize1">
      <li class="itemize"><em>Инструменты           используемые           для           простого
      объектно-ориентированного программирования</em>
      <!--l. 8137--><p class="noindent" >Эти инструменты позволяют определять новые классы, методы и
      обобщённые функции, и создавать экземпляры классов. Также
      перечислены некоторые функции, используемые внутри тел методов.
      Некоторые из ниже перечисленных макросов, имеют соответствующие
      функции, которые выполняют ту же задачу но на более низком уровне
      абстракции.
      <div class="flushleft" 
>
<!--l. 8142--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" ><b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b></td><td align="left" ><b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b></td></tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380214r214">change-class</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x188-380595r595">make-instance</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380310r310">defclass</a></b>            </td><td align="left" ><b><a 
href="symbols.html#x188-380669r669">next-method-p</a></b>   </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>         </td><td align="left" ><b><a 
href="symbols.html#x188-380871r871">slot-boundp</a></b>       </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>        </td><td align="left" ><b><a 
href="symbols.html#x188-380887r887">slot-value</a></b>          </td></tr><tr><td align="left" > </td> <td align="left" ><b><a 
href="symbols.html#x188-381013r1013">with-accessors</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380452r452">generic-function</a></b> </td><td align="left" >                       </td>
</tr><tr><td align="left" >                      </td><td align="left" ><b><a 
href="symbols.html#x188-381023r1023">with-slots</a></b>          </td></tr></table>
</div></div>
      </li>
      <li class="itemize"><em>Функции, лежащие под часто основными макросами</em>
                                                                          

                                                                          
      <div class="flushleft" 
>
<!--l. 8162--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" ><b><a 
href="symbols.html#x188-380090r90">add-method</a></b>                      </td><td align="left" ><b><a 
href="symbols.html#x188-380794r794">reinitialize-instance</a></b>                    </td></tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380244r244">class-name</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x188-380805r805">remove-method</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380270r270">compute-applicable-methods</a></b></td><td align="left" ><b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b>                         </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380376r376">ensure-generic-function</a></b>       </td><td align="left" ><b><a 
href="symbols.html#x188-380882r882">slot-exists-p</a></b>                              </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380415r415">ﬁnd-class</a></b>                         </td><td align="left" ><b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b>                       </td></tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380418r418">ﬁnd-method</a></b> </td> <td align="left" ><b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380448r448">function-keywords</a></b>              </td><td align="left" ><b><a 
href="symbols.html#x188-380886r886">slot-unbound</a></b>                            </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380596r596">make-instances-obsolete</a></b>      </td><td align="left" ><b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b> </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380673r673">no-applicable-method</a></b>         </td><td align="left" ><b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380674r674">no-next-method</a></b>                 </td><td align="left" >                                             </td></tr></table>
</div></div>
      </li>
      <li class="itemize"><em>Инструменты для декларации сочетания методов</em>
      <div class="flushleft" 
>
<!--l. 8181--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" ><b><a 
href="symbols.html#x188-380189r189">call-method</a></b>                    </td><td align="left" ><b><a 
href="symbols.html#x188-380632r632">method-combination-error</a></b></td></tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b></td> <td align="left" ><b><a 
href="symbols.html#x188-380636r636">method-qualiﬁers</a></b></td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380508r508">invalid-method-error</a></b>         </td><td align="left" >                                   </td></tr></table>
</div></div>
      </li>
      <li class="itemize"><em>Основные Common Lisp&#x2019;овые функции</em>
      <div class="flushleft" 
>
<!--l. 8193--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" ><b><a 
href="symbols.html#x188-380245r245">class-of</a></b>          </td><td align="left" ><b><a 
href="symbols.html#x188-380751r751">print-object</a></b>      </td>
</tr><tr><td align="left" ><b><a 
href="symbols.html#x188-380352r352">documentation</a></b></td><td align="left" ><b><a 
href="symbols.html#x188-380944r944">symbol-macrolet</a></b></td></tr></table>
</div></div>
      </li></ul>
<!--l. 8202--><p class="noindent" >[At this point the original CLOS report contained a description of the [[<i> </i>]] and <span class="math"> ↓</span><i></i>
notation; that description is omitted here. I have adopted the notation for use
throughout this book. It is described in section <a 
href="clmse2.html#x8-120001.2.5">1.2.5<!--tex4ht:ref: FUNCTION-HEADER-NOTATION-SECTION --></a>.—GLS]
<div class="defun">
<div class="defunheader">
                                                                          

                                                                          
<a 
 id="dx176-302003"></a>
<em>
<!--l. 8210--><p class="noindent" >[Обобщённая функция]</em> <b>add-method</b> <i>generic-function</i> <i>method</i><br />
<a 
 id="dx176-302004"></a>
<em>
[Главный метод]</em> <b>add-method</b> (<i>generic-function</i> standard-generic-function)
(<i>method</i> method)
</div>
<!--l. 8213--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380090r90">add-method</a></b> добавляет метод в обобщённую
функцию. Она деструктивно модифицирует обобщённую функцию и
возвращает её в качестве результата.
<!--l. 8217--><p class="indent" >   Аргумент <em>generic-function</em> является объектом обобщённой функции.
<!--l. 8219--><p class="indent" >   Аргумент <em>method</em> является объектом метода. Лямбда-список функции
метода должен быть согласован с лямбда-списком обобщённой функции,
иначе будет сигнализирована ошибка.
<!--l. 8223--><p class="indent" >   Функция возвращает модифицированный объект обобщённой функции.
Результата функции <b><a 
href="symbols.html#x188-380090r90">add-method</a></b> равен <b><a 
href="symbols.html#x188-380378r378">eq</a></b> аргументу <em>generic-function</em>.
<!--l. 8226--><p class="indent" >   Если заданный метод совпадает с уже существующим в данной обобщённой
функции методом в специализаторах параметров и квалификаторах, то он
заменяется на новый. Смотрите раздел <a 
href="clmse143.html#x175-27100027.1.6">27.1.6<!--tex4ht:ref: Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION --></a> для подробного описания
механизма.
<!--l. 8232--><p class="indent" >   Если объект метода принадлежит другой обобщённой функции,
сигнализируется ошибка.
<!--l. 8235--><p class="indent" >   Смотрите раздел <a 
href="clmse143.html#x175-27100027.1.6">27.1.6<!--tex4ht:ref: Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION --></a>.
<!--l. 8238--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>, <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>, <b><a 
href="symbols.html#x188-380418r418">ﬁnd-method</a></b> и <b><a 
href="symbols.html#x188-380805r805">remove-method</a></b>.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 8244--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>call-method</b> <a 
 id="dx176-302005"></a>method next-method-list
   <br>
<!--l. 8245--><p class="noindent" ></div>
</div>
<!--l. 8246--><p class="indent" >   Макрос <b><a 
href="symbols.html#x188-380189r189">call-method</a></b> используется в сочетании методов. Данный макрос
скрывает платформоспецифичные штучки о том, как происходят вызовы
                                                                          

                                                                          
методов. Он может быть использован только внутри формы метода, так как
имя <b><a 
href="symbols.html#x188-380189r189">call-method</a></b> определено только в лексической области данной
формы.
<!--l. 8251--><p class="indent" >   Макрос <b><a 
href="symbols.html#x188-380189r189">call-method</a></b> вызывает указанный метод, передавая ему
аргументы и определения для <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> и для <b><a 
href="symbols.html#x188-380669r669">next-method-p</a></b>.
Аргументы те же, что и переданные в метод содержащий вызов данного
макроса. Определения <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> и <b><a 
href="symbols.html#x188-380669r669">next-method-p</a></b> опираются на
список объектов методов, переданный в качестве второго аргумента
<b><a 
href="symbols.html#x188-380189r189">call-method</a></b>.
<!--l. 8257--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>, доступная для метода из первой подформы,
вызовет первый метод из списка из второй подформы. Функция
<b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>, доступная в этом методе, в свою очередь, вызовет второй
метод в списке из второй подформы, и так далее, пока список методов не
закончится.
<!--l. 8263--><p class="indent" >   Аргумент <em>method</em> является объектом метода. Аргумент <em>next-method-list</em>
является списком объектов методов.
<!--l. 8266--><p class="indent" >   Список, у которого первый элемент является символом <b>make-method</b>, и
второй элемент которого является Lisp&#x2019;овой формой, может использоваться
вместо объекта метода на месте первой подформы макроса <b><a 
href="symbols.html#x188-380189r189">call-method</a></b>
или в качестве элемента списка во второй подформе. Такой список
<b>(make-method lisp-form)</b> задаёт объект метода, тело которого состоит из
формы <em>lisp-form</em>.
<!--l. 8272--><p class="indent" >   Результатом <b><a 
href="symbols.html#x188-380189r189">call-method</a></b> является значение(я), возвращённые
вызываемым методом.
<!--l. 8275--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>, <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b> и
<b><a 
href="symbols.html#x188-380669r669">next-method-p</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302006"></a>
<em>
<!--l. 8280--><p class="noindent" >[Функция]</em> <b>call-next-method</b> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>args</i>
</div>
<!--l. 8282--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> может использоваться внутри тела метода
для вызова следующего метода.
<!--l. 8285--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> возвращает значение(я), которые были
                                                                          

                                                                          
возвращены вызванным методом. Если следующего метода не оказалось,
вызывается обобщённая функция <b><a 
href="symbols.html#x188-380674r674">no-next-method</a></b>.
<!--l. 8289--><p class="indent" >   Для определения того, какие методы могут вызывать <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>
используется тип сочетания методов. Стандартный тип сочетания
методов позволяет использовать <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> в главных и <b>:around</b>
методах.
<!--l. 8293--><p class="indent" >   Стандартный тип сочетания методов находит следующий метод в
соответствие с правилами:
      <ul class="itemize1">
      <li class="itemize">Если                                                            <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>
      используется  в  <b>:around</b>  методе,  следующим  методом  является
      наиболее специфический метод, который может быть применён к
      использованным аргументам.
      </li>
      <li class="itemize">Если  <b>:around</b>  методов  нет,  или  если  <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>  был
      вызван  самым  последним  специфическим  <b>:around</b>  методом,  то
      вызываются другие методы, как показано ниже:
           <ul class="itemize2">
           <li class="itemize">Вызываются   все   <b>:before</b>   методы   в   порядке   убывания
           специфичности. Функция <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> не может быть
           использована в <b>:before</b> методах.
           </li>
           <li class="itemize">Вызывается наиболее специфический главный метод. Внутри
           тела                главного                метода                может
           использоваться <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> для передачи управления
           следующему   наиболее   специфическому   главному   методу.
           Если  была  использована  <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>  и  больше  не
           осталось главных методов, вызывается Обобщённая функция
           <b><a 
href="symbols.html#x188-380674r674">no-next-method</a></b>.
           </li>
           <li class="itemize">Все                               <b>:after</b>                           методы
           вызываются в порядке возрастания специфичности. Функция
           <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> не может использоваться в <b>:after</b> методах.</li></ul>
                                                                          

                                                                          
      </li></ul>
<!--l. 8327--><p class="indent" >   Часть описания <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> содержится в разделах <a 
href="clmse143.html#x175-27600027.1.7">27.1.7<!--tex4ht:ref: Standard-Method-Combination-SECTION --></a>
и <a 
href="clmse143.html#x175-27800027.1.7">27.1.7<!--tex4ht:ref: Built-in-Method-Combination-Types-SECTION --></a>.
<!--l. 8331--><p class="indent" >   Когда <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> вызывается без аргументов, она передаёт
аргументы для текущего метода в следующий метод. Ни значения
аргументов по-умолчанию, ни использование <b><a 
href="symbols.html#x188-380845r845">setq</a></b>, ни пересвязывания
переменных с теми же именами, что и параметры текущего метода не влияют
на значения, передаваемые функцией <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> в следующий
метод.
<!--l. 8337--><p class="indent" >   Если <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> вызывается с аргументами, они передаются при
вызове в следующий метод. При указании аргументов для <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>
должно выполняться следующее правило, иначе будет сигнализирована
ошибка: Упорядоченное множество методов, которые применимы к
аргументам указанным в <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> должно быть эквивалентно
множеству аргументов, которые применимы к оригинальным аргументам,
указанным в текущий метод. Допускаются оптимизации проверки данной
ошибки, но они не должны изменять семантики <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>.
<!--l. 8346--><p class="indent" >   Если <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> вызывается с аргументами, но необязательные
параметры не указываются, следующий метод будет вызван со значениями
по-умолчанию для данных аргументов.
<!--l. 8350--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> возвращает значение(я), которые были
возвращены следующим методом.
<!--l. 8353--><p class="indent" >   После того, как <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> возвращает управление, можно
проводить дальнейшие вычисления.
<!--l. 8356--><p class="indent" >   Определение функции <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> имеет лексическую область
видимости (она определена только внутри тела метода) и неограниченную
продолжительность видимости.
<!--l. 8359--><p class="indent" >   Для обобщённых функций, которые используют сочетания методов,
определённые с помощью формы <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>,
<b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> может использоваться только в <b>:around</b> методах.
<!--l. 8363--><p class="indent" >   Для проверки, существует ли следующий метод, может использоваться
функция <b><a 
href="symbols.html#x188-380669r669">next-method-p</a></b>.
<!--l. 8366--><p class="indent" >   Если <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b> используется в методах, которые её не
поддерживают, сигнализируется ошибка.
<!--l. 8369--><p class="indent" >   Смотрите разделы <a 
href="clmse143.html#x175-27400027.1.7">27.1.7<!--tex4ht:ref: Method-Selection-and-Combination-SECTION --></a>, <a 
href="clmse143.html#x175-27600027.1.7">27.1.7<!--tex4ht:ref: Standard-Method-Combination-SECTION --></a> и <a 
href="clmse143.html#x175-27800027.1.7">27.1.7<!--tex4ht:ref: Built-in-Method-Combination-Types-SECTION --></a>. Смотрите функции
<b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>, <b><a 
href="symbols.html#x188-380669r669">next-method-p</a></b> и <b><a 
href="symbols.html#x188-380674r674">no-next-method</a></b>.
<hr></div>
                                                                          

                                                                          
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302007"></a>
<em>
<!--l. 8379--><p class="noindent" >[Обобщённая функция]</em> <b>change-class</b> <i>instance</i> <i>new-class</i><br />
<a 
 id="dx176-302008"></a>
<em>
[Главный метод]</em> <b>change-class</b> (<i>instance</i> standard-object) (<i>new-class</i> standard-class)<br />
<a 
 id="dx176-302009"></a>
<em>
[Главный метод]</em> <b>change-class</b> (<i>instance</i> t) (<i>new-class</i> symbol)
</div>
<!--l. 8383--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380214r214">change-class</a></b> изменяет класс экземпляра <em>instance</em>
на новый класс <em>new-class</em>. Функция деструктивно модифицирует и
возвращает экземпляр.
<!--l. 8387--><p class="indent" >   Если в старом классе были какие-либо слоты с теми же именами, что и
локальные слоты в новом классе, тогда значения таких слотов остаются
прежними. Это значит, что если в слоте было значение, тогда значение,
возвращаемое <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b> после вызова <b><a 
href="symbols.html#x188-380214r214">change-class</a></b>, будет равно <b><a 
href="symbols.html#x188-380379r379">eql</a></b>
значение, возвращаемому <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b> перед вызовом <b><a 
href="symbols.html#x188-380214r214">change-class</a></b>. Если слот
не имел связывания, то после изменения класса он также не будет иметь
связывания. Другие слоты будут инициализированы так, как описано в
разделе <a 
href="clmse143.html#x175-29600027.1.11">27.1.11<!--tex4ht:ref: Changing-the-Class-of-an-Instance-SECTION --></a>.
<!--l. 8396--><p class="indent" >   Аргумент <em>instance</em> является Lisp&#x2019;овым объектом.
<!--l. 8398--><p class="indent" >   Аргумент <em>new-class</em> является объектом класса или символом, указывающим
на класс.
<!--l. 8401--><p class="indent" >   Если применяется второй из перечисленных выше методов, то этот
метод вызывает <b><a 
href="symbols.html#x188-380214r214">change-class</a></b> для экземпляра <em>instance</em> и <b>(ﬁnd-class
<em>new-class</em>)</b>.
<!--l. 8404--><p class="indent" >   В качестве результата возвращается модифицированный экземпляр.
Результат <b><a 
href="symbols.html#x188-380214r214">change-class</a></b> равен <b><a 
href="symbols.html#x188-380378r378">eq</a></b> аргументу <em>instance</em>.
<!--l. 8407--><p class="indent" >   Например:
<div class="lisp">
<tt>
<!--l. 8409--><p class="indent" >   <div class="tabbing">
                                                                          

                                                                          
(defclass position () ())
   <br>                           <br>                           (defclass x-y-position (position)<br>
  ((x :initform 0 :initarg :x)<br>                    (y :initform 0 :initarg :y)))<br>
<br>                                     (defclass rho-theta-position (position)<br>
  ((rho :initform 0)<br>                                   (theta :initform 0)))<br>
<br>                      (defmethod update-instance-for-diﬀerent-class :before<br>
           ((old x-y-position)<br>
            (new rho-theta-position)<br>                            &#x0026;key)<br>
  ;; Copy the position information from old to new to make new<br>
  ;; be a rho-theta-position at the same position as old.<br>
  (let ((x (slot-value old &#x2019;x))<br>                       (y (slot-value old &#x2019;y)))<br>
    (setf (slot-value new &#x2019;rho) (sqrt (+ (* x x) (* y y)))<br>
          (slot-value new &#x2019;theta) (atan y x))))<br>
<!--l. 8430--><p class="noindent" ></div>
</tt>
</div>
<div class="lisp">
<tt>
<!--l. 8431--><p class="indent" >   <div class="tabbing">
;;; С помощью change-class экземпляр класса x-y-position
   <br> ;;; может быть изменён так, чтобы классом<br> ;;; стал rho-theta-position<br>
<br>                           (setq p1 (make-instance &#x2019;x-y-position :x 2 :y 0))<br>
<br>                                       (change-class p1 &#x2019;rho-theta-position)<br>
<br>                  ;;; Результатом является то, что экземпляр связанный<br>
;;; с символом p1 сейчас является экземпляром класса<br>
;;; rha-theta-position.<br>;;; Метод update-instance-for-diﬀerent-class выполнил<br>
;;; инициализацию слотов rho и theta, основываясь ;;; на значениях слотов x и y, которые были в старом ;;; экземпляре.<br>
<!--l. 8447--><p class="noindent" ></div>
</tt>
</div>
<!--l. 8449--><p class="indent" >   После завершения всех других операций, <b><a 
href="symbols.html#x188-380214r214">change-class</a></b> вызывает
обобщённую функцию <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b>. Обобщённая
                                                                          

                                                                          
функция <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b> может быть использована для
присваивания значений слотам в трансформированном экземпляре
класса.
<!--l. 8454--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380214r214">change-class</a></b> имеет несколько семантических
сложностей. Первое, она выполняет деструктивную операцию, которая может
быть вызвана внутри метода для экземпляра, который использовался для
выбора применяемого метода. Если была произведено сочетание методов, то
следующие методы могут оказаться неприменимыми. Второе, некоторые
реализации могут использовать оптимизацию при компилировании в
доступах к слотам, и когда класс экземпляра изменяется, то этот код «может
поломаться». Вывод такое, что программист не должен использовать
<b><a 
href="symbols.html#x188-380214r214">change-class</a></b> внутри методов, если любой метод для текущей обобщённой
функции оперирует слотами этого экземпляра. В противном случае
результаты непредсказуемы.
<!--l. 8467--><p class="indent" >   Смотрите раздел <a 
href="clmse143.html#x175-29600027.1.11">27.1.11<!--tex4ht:ref: Changing-the-Class-of-an-Instance-SECTION --></a>.
<!--l. 8469--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302010"></a>
<em>
<!--l. 8473--><p class="noindent" >[Обобщённая функция]</em> <b>class-name</b> <i>class</i><br />
<a 
 id="dx176-302011"></a>
<em>
[Главный метод]</em> <b>class-name</b> (<i>class</i> class)
</div>
<!--l. 8476--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380244r244">class-name</a></b> принимает объект класса и возвращает
его имя.
<!--l. 8479--><p class="indent" >   Аргумент <em>class</em> является объектом класса.
<!--l. 8481--><p class="indent" >   Функция возвращает имя заданного класса.
<!--l. 8483--><p class="indent" >   Именем для анонимного класса является символ <b><a 
href="symbols.html#x188-380670r670">nil</a></b>.
<!--l. 8485--><p class="indent" >   Если <em>S</em> является таким символом, что <em>S</em> =<b>(class-name <em>C</em>)</b> и
<em>C</em> =<b>(ﬁnd-class <em>S</em>)</b>, тогда <em>S</em> является именем собственным для <em>C</em>. Смотрите
раздел <a 
href="clmse143.html#x175-25400027.1.2">27.1.2<!--tex4ht:ref: Classes-SECTION --></a>.
<hr></div>
<div class="defun">
                                                                          

                                                                          
<div class="defunheader">
<a 
 id="dx176-302012"></a>
<em>
<!--l. 8491--><p class="noindent" >[Обобщённая функция]</em> <b>(setf class-name)</b>  <i>new-value</i> <i>class</i><br />
<a 
 id="dx176-302013"></a>
<em>
[Главный метод]</em> <b>(setf class-name)</b>  <i>new-value</i> (<i>class</i> class)
</div>
<!--l. 8494--><p class="indent" >   Обобщённая функция <b>(setf class-name)</b> принимает объект класса и
устанавливает его имя. Аргумент <em>class</em> является объектом класса. Аргумент
<em>new-value</em> является любым объектом.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302014"></a>
<em>
<!--l. 8501--><p class="noindent" >[Функция]</em> <b>class-of</b> <i>object</i>
</div>
<!--l. 8503--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380245r245">class-of</a></b> возвращает класс, к которому принадлежит экземпляр
класса <em>object</em>. Аргументом для <b><a 
href="symbols.html#x188-380245r245">class-of</a></b> может быть любой Common Lisp&#x2019;овый
объект.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302015"></a>
<em>
<!--l. 8509--><p class="noindent" >[Функция]</em> <b>compute-applicable-methods</b> <i>generic-function</i> <i>function-arguments</i>
</div>
<!--l. 8511--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380270r270">compute-applicable-methods</a></b> принимает обобщённую функцию
и аргументы для неё и возвращает множество методов, которые применимы
для данных аргументов.
<!--l. 8515--><p class="indent" >   Методы сортируются в соответствии с precedence order. Смотрите
раздел <a 
href="clmse143.html#x175-27400027.1.7">27.1.7<!--tex4ht:ref: Method-Selection-and-Combination-SECTION --></a>.
                                                                          

                                                                          
<!--l. 8518--><p class="indent" >   Аргумент <em>generic-function</em> должен быть объектом обобщённой функции.
Аргумент <em>function-arguments</em> является списком аргументов для обобщённой
функции. Результатом является списком применимых методов в порядке
приоритетности. Смотрите раздел <a 
href="clmse143.html#x175-27400027.1.7">27.1.7<!--tex4ht:ref: Method-Selection-and-Combination-SECTION --></a>.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 8526--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>defclass</b> <a 
 id="dx176-302016"></a>class-name ({superclass-name}*)({slot-speciﬁer}*) [[<span class="math"> ↓</span>class-option]]
   <br>
<!--l. 8528--><p class="noindent" ></div>
</div>
<!--l. 8529--><p class="indent" >   <div class="tabbing">
<em>class-name</em> ::= <em>symbol</em>
   <br>                                                       <em>superclass-name</em> ::= <em>symbol</em><br>
<em>slot-speciﬁer</em> ::= <em>slot-name</em> | (<em>slot-name</em> <span class="math">[[↓slot − option ]]</span>)<br>
<em>slot-name</em> ::= <em>symbol</em><br>     <em>slot-option</em> ::=  {<i><b>:reader</b> <em>reader-function-name</em></i>}* <br>
|  {<i><b>:writer</b> <em>writer-function-name</em></i>}* <br>   |  {<i><b>:accessor</b> <em>reader-function-name</em></i>}* <br>
|  {<i><b>:allocation</b> <em>allocation-type</em></i>} <br>                     |  {<i><b>:initarg</b> <em>initarg-name</em></i>}* <br>
|  {<i><b>:initform</b> <em>form</em></i>} <br>                                         |  {<i><b>:type</b> <em>type-speciﬁer</em></i>} <br>
|  {<i><b>:documentation</b> <em>string</em></i>} <br>
<!--l. 8543--><p class="noindent" ></div>
<div class="tabbing">
<em>reader-function-name</em> ::= <em>symbol</em>
   <br>                                       <em>writer-function-name</em> ::= <em>function-name</em><br>
<em>function-name</em> ::=  {<i><em>symbol</em> | <b>(setf <em>symbol</em>)</b></i>} <br>
<em>initarg-name</em> ::= <em>symbol</em><br>              <em>allocation-type</em> ::= <b>:instance | :class</b><br>
<em>class-option</em> ::= <b>(:default-initargs <em>initarg-list</em>)</b><br>
| <b>(:documentation <em>string</em>)</b><br>                 | <b>(:metaclass <em>class-name</em>)</b><br>
<em>initarg-list</em> ::=  {<i><em>initarg-name default-initial-value-form</em></i>}* <br>
                                                                          

                                                                          
<!--l. 8555--><p class="noindent" ></div>Макрос <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> определяет именованный класс. В качестве результата он
возвращает объект нового класса.
<!--l. 8559--><p class="indent" >   Синтаксис <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> содержит параметры для указания инициализационных
аргументов для слотов, для указания инициализационных значений
по-умолчанию для слотов и для указания автоматически сгенерировать
обобщённые функции для чтения и записи значений слотов. Функция для
чтения или записи по-умолчанию не создаются. Из генерация должна быть
указана явно.
<!--l. 8565--><p class="indent" >   Определение нового класса также создаёт определение типа с таким же
именем. Предикат <b>(typep <em>object class-name</em>)</b> возвращает истину, если класс
данного объекта <em>object</em> является классом или подклассом с именем
<em>class-name</em>. Объект класса может использоваться в качестве спецификаторы
типа. Таким образом <b>(typep <em>object class</em>)</b> возвращает истину, если <em>object</em>
является классом или подклассом <em>class</em>.
<!--l. 8572--><p class="indent" >   Аргумент <em>class-name</em> является не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> символом. Он становится для класса
именем собственным. Если класс с таким же именем собственным уже
существует, и этот класс является экземпляром класса <b>standard-class</b>, и
если форма <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> определяет класс от класса <b>standard-class</b>, определение
нового класса заменяет старый.
<!--l. 8578--><p class="indent" >   Каждый аргумент <em>superclass-name</em> является не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> символом, который
указывает прямые суперклассы для нового класса. Новый класс будет
наследовать слоты и методы от каждого их этих суперклассов, от
их суперклассов и так далее. Смотрите раздел <a 
href="clmse143.html#x175-25900027.1.3">27.1.3<!--tex4ht:ref: Inheritance-SECTION --></a> для описания
наследования слотов и методов.
<!--l. 8584--><p class="indent" >   Каждый аргумент <em>slot-speciﬁer</em> является или просто именем слота, или
списком, который содержит имя слота и ноль и более его параметров.
Аргумент <em>slot-name</em> является символом, который синтаксически корректен,
то есть мог бы использоваться для имён переменных. Если один и тот же
слот был указан дважды, будет сигнализирована ошибка.
<!--l. 8590--><p class="indent" >   В описании слота можно использовать следующие параметры:
      <ul class="itemize1">
      <li class="itemize">Параметр слота <b>:reader</b> указывает на то, что автоматически будет
      определён неквалифицированный метод для обобщённой функции
      с  именем  <em>reader-function-name</em>.  Метод  будет  использоваться  для
      чтения  значения  слота.  Аргумент  <em>read-function-name</em>  является
      не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> символом. Параметр слота <b>:reader</b> для одного слота может
                                                                          

                                                                          
      быть указан несколько раз.
      </li>
      <li class="itemize">Параметр слота <b>:writer</b> указывает на то, что автоматически будет
      определён неквалифицированный метод для обобщённой функции
      с  именем  <em>writer-function-name</em>.  Метод  будет  использоваться  для
      записи значения в слот. Аргумент <em>writer-function-name</em> является
      не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> символом. Параметр слота <b>:writer</b> для одного слота может
      быть указан несколько раз.
      </li>
      <li class="itemize">Параметр  слота  <b>:accessor</b> указывает  на  то,  что  автоматически
      будут      определены      два      неквалифицированных      метода
      для обобщённых функций с именами <em>reader-function-name</em> и <b>(setf
      <em>reader-function-name</em>)</b>. Первый метод будет использоваться для
      чтения значения слота, а второй в связке с <b><a 
href="symbols.html#x188-380844r844">setf</a></b> для модификации
      значения  слота.  Аргумент  <em>reader-function-name</em>  является  не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b>
      символом. Параметр слота <b>:accessor</b> для одного слота может быть
      указан несколько раз.
      </li>
      <li class="itemize">Параметр  слота  <b>:allocation</b>  используется  для  указания  того,
      где  будет  хранятся  значение  данного  слота.  Хранение  значения
      слота может быть осуществлено, например, в каждом экземпляре
      класса  или  в  самом  классе.  Значением  аргумента  <em>allocation-type</em>
      может быть или <b>:instance</b>, или <b>:class</b>. Параметр слота <b>:allocation</b>
      для одного слота может быть указан максимум один раз. Если
      параметр  <b>:allocation</b>  не  указан,  то  это  значит  то  же,  что  и
      <b>:allocation :instance</b>.
           <ul class="itemize2">
           <li class="itemize">Если  <em>allocation-type</em>  равен  <b>:instance</b>,  в  каждом  экземпляре
           класса создаётся одноимённый слот.
           </li>
           <li class="itemize">Если  <em>allocation-type</em>  равен  <b>:class</b>,  в  самом  классе  создаётся
           разделяемый  слот.  Значение  слота  используется  совместно
           всем экземплярами данного класса. Если класс <span class="math">C<sub>1</sub></span> определяет
                                                                          

                                                                          
           такой  разделяемый  слот,  любой  подкласс  <span class="math">C<sub>2</sub></span>  от  <span class="math">C<sub>1</sub></span>  будет
           также  совместно  использовать  данный  слот,  пока  форма
           <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> для <span class="math">C<sub>2</sub></span>  не определит слот с тем же именем, или у
           <span class="math">C<sub>2</sub></span> будет иметь суперкласс, который стоит перед <span class="math">C<sub>1</sub></span> в списке
           приоритетности классов <span class="math">C<sub>2</sub></span> и который содержит одноимённый
           слот.</li></ul>
      </li>
      <li class="itemize">Параметр слота <b>:initform</b> используется для указания инициализационного
      значения для слота по-умолчанию. Параметр слота <b>:initform</b> для
      одного слота может быть указан максимум один раз. Данная форма
      вычисляется каждый раз, когда необходима инициализация слота.
      Лексическое окружение для вычисления данной формы совпадает с
      тем, в котором выполнялась формы <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>. Следует отметить, что
      лексическое окружение ссылается и на переменные, и на функции. Для
      локальных слотов, динамическое окружение совпадает с тем, в котором
      вызывается функция <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>. Для разделяемых слотов,
      динамическое окружение совпадает с тем, в котором вычисляется
      форма <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>. Смотрите раздел <a 
href="clmse143.html#x175-28300027.1.9">27.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
      <!--l. 8657--><p class="noindent" >Реализациям не разрешено дополнять синтаксис <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> так, чтобы
      <b>(<em>slot-name</em> :initform <em>form</em>)</b> можно было записать сокращённо
      <b>(<em>slot-name form</em>)</b>.
      </li>
      <li class="itemize">Параметр слота <b>:initarg</b> декларирует инициализационный аргумент
      <em>initarg-name</em> и указывает на то, что данный аргумент инициализирует
      данный слот. Если инициализационный аргумент содержит некоторое
      значение в вызове <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b>, это значение будет сохранено
      в данном слоте, и если был указан параметр слота <b>:initform</b>,
      то этот параметр [<b>:initform</b>] вычисляться не будет. Если ни
      один из инициализационных аргументов не имеет значения, слот
      инициализируется в соответствие с параметром слота <b>:initform</b>, если
      последний был указан. Параметр слота <b>:initarg</b> для одного слота может
      быть использован более одного раза. Аргумент <em>initarg-name</em> может быть
      любым символом.
      </li>
      <li class="itemize">Параметр слота <b>:type</b> указывает но то, что содержимое слота будет
                                                                          

                                                                          
      всегда принадлежать указанному типу данных. Данный параметр
      также декларирует тип результата для обобщённой функции чтения
      слота применительно к данному класса. Результат попытки сохранить в
      слоте значение неподходящего типа непредсказуем. Параметр
      слота <b>:type</b> для одного слота может быть указан максимум
      один раз. Подробное описание параметра слота <b>:type</b> дано в
      разделе <a 
href="clmse143.html#x175-26100027.1.3">27.1.3<!--tex4ht:ref: Inheritance-of-Slots-and-Slot-Options-SECTION --></a>.
      </li>
      <li class="itemize">Параметр слота <b>:documentation</b> указывает строку документации для
      данного слота.</li></ul>
<!--l. 8688--><p class="indent" >   Каждый параметр класса относится к классу в целом или ко всем слотам.
Доступны следующие параметры:
      <ul class="itemize1">
      <li class="itemize">Параметр
      класса <b>:default-initargs</b> с последующим списком альтернативных
      имён  инициализационных  аргументов  и  их  инициализационных
      значений  по-умолчанию.  Если  любой  какой-либо  аргументов  из
      этого списка не будет указан в аргументах <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>, то будет
      вычислена  форма  инициализационного  значения  по-умолчанию
      и   эта   пара:   аргумент,   значение,   будет   добавлена   в   список
      инициализационных  аргументов  перед  тем  как  будет  создан
      экземпляр  класса.  Смотрите  раздел <a 
href="clmse143.html#x175-28300027.1.9">27.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.  Инициализационное
      значение по-умолчанию вычисляется каждый раз при обращении к
      нему. Лексическое окружение для данной формы совпадает с тем,
      в котором выполнялась форма <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>. Динамическое окружение
      для  данной  формы  совпадает  с  тем,  в  котором  выполнялся
      вызов <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>. Если имя инициализационного аргумента
      в  параметре  класса  <b>:default-initargs</b>  встречается  более  одно
      раза, сигнализируется ошибка. Параметр класса <b>:default-initargs</b>
      может быть использован максимум один раз.
      </li>
      <li class="itemize">Параметр                                                                      класса
      <b>:documentation</b>  определяет  строку  документации  для  данного
      имени  класса.  Тип  документации  для  данного  символа  будет
                                                                          

                                                                          
      <b>type</b>. Для получения данной строки может использовать форму
      <b>(documentation <em>class-name</em> &#x2019;type)</b>. Параметр <b>:documentation</b>
      может быть указан максимум один раз.
      </li>
      <li class="itemize">Параметр  класса  <b>:metaclass</b>  используется  для  указания  того,
      что  экземпляры  данного  класса  имеют  отличный  от  системного
      (<b>standard-class</b>)  метакласс.  Аргумент  <em>class-name</em>  указывает  на
      этот метакласс.</li></ul>
<!--l. 8723--><p class="indent" >   В качестве результата возвращается созданный объект класса.
<!--l. 8725--><p class="indent" >   Если класс с таким же именем собственным уже существует, и этот класс
является экземпляром <b>standard-class</b> и если форма <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> с определением
нового класса также использует <b>standard-class</b>, существующий класс
переопределяется, и экземпляры данного класса (и всех подклассов)
обновляются до нового определения класса во время следующего к ним
обращения. Смотрите раздел <a 
href="clmse143.html#x175-29100027.1.10">27.1.10<!--tex4ht:ref: Redefining-Classes-SECTION --></a>.
<!--l. 8732--><p class="indent" >   Для стандартных классов применяются следующие правила:
      <ul class="itemize1">
      <li class="itemize">Необязательно  определять  все  суперклассы  класса  прежде,  чем
      будет вычислена для данного класса форма <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>.
      </li>
      <li class="itemize">Все  суперклассы  класса  должны  быть  определены  прежде,  чем
      будут создаваться экземпляры данного класса.
      </li>
      <li class="itemize">Класс должен быть определён прежде, чем он будет использован в
      специализаторе параметра в форме <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>.</li></ul>
<!--l. 8749--><p class="indent" >   Объектная система может быть расширены для обработки ситуаций не
описанные данными правилами.
<!--l. 8752--><p class="indent" >   Некоторые параметры слота наследуются от суперклассов, и некоторые из
них могут быть затенены или изменены в текущем описании слота.
Параметры класса, кроме <b>:default-initargs</b>, не наследуются. Для подробного
описания того, как наследуются слоты и их параметры, смотрите
раздел <a 
href="clmse143.html#x175-26100027.1.3">27.1.3<!--tex4ht:ref: Inheritance-of-Slots-and-Slot-Options-SECTION --></a>.
                                                                          

                                                                          
<!--l. 8758--><p class="indent" >   Реализация может добавлять свои параметры формы <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>. Однако
если реализация сталкивается с неподдерживаемым параметром, они должна
сигнализировать ошибку.
<!--l. 8762--><p class="indent" >   В описании слота можно использовать несколько раз параметры функции
чтения, записи, аксессора или инициализации. Однако другие параметры в
описании слота должны встречаться только один раз, иначе будет
сигнализирована ошибка.
<!--l. 8766--><p class="indent" >   Если для слота не определены ни функции чтения, записи, ни аксессор,
тогда к нему можно получить доступ только с помощью функции
<b><a 
href="symbols.html#x188-380887r887">slot-value</a></b>.
<!--l. 8769--><p class="indent" >   Смотрите разделы <a 
href="clmse143.html#x175-25400027.1.2">27.1.2<!--tex4ht:ref: Classes-SECTION --></a>, <a 
href="clmse143.html#x175-25900027.1.3">27.1.3<!--tex4ht:ref: Inheritance-SECTION --></a>, <a 
href="clmse143.html#x175-29100027.1.10">27.1.10<!--tex4ht:ref: Redefining-Classes-SECTION --></a>, <a 
href="clmse143.html#x175-26500027.1.5">27.1.5<!--tex4ht:ref: Determining-the-Class-Precedence-List-SECTION --></a>, <a 
href="clmse143.html#x175-28300027.1.9">27.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<!--l. 8775--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b>, <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b> и <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b>.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 8781--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>defgeneric</b> <a 
 id="dx176-302017"></a>function-name lambda-list[[<span class="math"> ↓</span>option | {method-description}*]]
   <br>
<!--l. 8783--><p class="noindent" ></div>
</div>
<!--l. 8784--><p class="indent" >   <div class="tabbing">
<em>function-name</em> ::=  {<i><em>symbol</em> | <b>(setf <em>symbol</em>)</b></i>}
   <br>                                                               <em>lambda-list</em> ::= <b>(</b> {<i>var</i>}* <br>
                 [<i><b>&optional</b> {<i>var | <b>(<em>var</em>)</b></i>}*</i>] <br>                        [<i><b>&rest</b> <em>var</em></i>] <br>
                 [<i><b>&key</b> {<i>keyword-parameter</i>}*  [<i><b>&allow-other-keys</b></i>]</i>] <b>)</b><br>
<!--l. 8790--><p class="noindent" ></div><div class="tabbing">
<em>keyword-parameter</em> ::= <em>var</em> | <b>( {<i>var | <b>(<em>keyword</em> <em>var</em>)</b></i>} )</b>
   <br>
<em>option</em> ::= <b>(:argument-precedence-order  {<i>parameter-name</i>}+ )</b>
   <br>
                                                                          

                                                                          
| <b>(declare  {<i>declaration</i>}+ )</b>
   <br>                                                 | <b>(:documentation <em>string</em>)</b><br>
| <b>(:method-combination <em>symbol</em> {<i>arg</i>}* )</b><br>
| <b>(:generic-function-class <em>class-name</em>)</b><br>| <b>(:method-class <em>class-name</em>)</b><br>
<em>method-description</em> ::= <b>(:method </b> {<i>method-qualiﬁer</i>}*
   <br>          <em>specialized-lambda-list</em><br>          [[<i> {<i>declaration</i>}* | documentation</i>]] <br>
 {<i>form</i>}* <b>)</b><br>
<em>method-qualiﬁer</em> ::= <em>non-nil-atom</em>
   <br>
<em>specialized-lambda-list</em> ::=
   <br>                                     <b>(</b> {<i>var | <b>(</b>var parameter-specializer-name<b>)</b></i>}* <br>
 [<i><b>&optional</b> {<i>var | <b>(</b>var [<i>initform [<i>supplied-p-parameter</i>]</i>]<b>)</b></i>}*</i>] <br>
 [<i><b>&rest <em>var</em></b></i>] <br>
 [<i><b>&key</b> {<i>specialized-keyword-parameter</i>}*  [<i><b>&allow-other-keys</b></i>]</i>] <br>
 [<i><b>&aux</b> {<i>var | <b>(<em>var</em>  [<i>initform</i>])</b></i>}*</i>] <b>)</b><br>
<em>specialized-keyword-parameter</em> ::=
   <br>       <em>var</em> | <b>(</b> {<i>var | <b>(<em>keyword</em> <em>var</em><b>)</b></b></i>}  [<i>initform [<i>supplied-p-parameter</i>]</i>] <b>)</b><br>
<em>parameter-specializer-name</em> ::= <em>symbol</em> | <b>(eql <em>eql-specializer-form</em>)</b>
   <br>
<!--l. 8814--><p class="noindent" ></div>Макрос <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> используется для определения функции или для указания
параметров и деклараций, которые относятся к обобщённой функции в
целом.
<!--l. 8818--><p class="indent" >   Если <b>(fboundp <em>function-name</em>)</b> является <b><a 
href="symbols.html#x188-380670r670">nil</a></b>, тогда создаётся новая
обобщённая функция. Если <b>(fdeﬁnition <em>function-speci er</em>)</b> является
обобщённой функцией, тогда она модифицируется. Если <em>function-name</em>
задаёт необобщённую функцию, макрос или специальный оператор, то
сигнализируется ошибка.
<!--l. 8823--><p class="indent" >   Каждый <em>method-description</em> определяет метод для обобщённой функции.
Лямбда-список каждого метода должен соответствовать лямбда-списку,
заданному в параметре <em>lambda-list</em>. Если это условие не выполняется,
сигнализируется ошибка. Смотрите раздел <a 
href="clmse143.html#x175-27200027.1.6">27.1.6<!--tex4ht:ref: Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION --></a> для определения
соответствия лямбда-списков в данном контексте.
<!--l. 8831--><p class="indent" >   Макрос <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> в качестве результата возвращает объект обобщённой
функции.
<!--l. 8834--><p class="indent" >   Аргумент <em>function-name</em> является не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> символом или списком вида <b>(setf
<em>symbol</em>)</b>.
                                                                          

                                                                          
<!--l. 8837--><p class="indent" >   Аргумент <em>lambda-list</em> является обычным лямбда-списком со следующими
ограничениями:
      <ul class="itemize1">
      <li class="itemize">Нельзя использовать <b>&#x0026;aux</b>.
      </li>
      <li class="itemize">Необязательные   и   именованные   аргументы   могут   не   иметь
      формы первоначальных значений по-умолчанию и не использовать
      параметры supplied-p. Обобщённая функция передаёт в метод все
      переданные  ей  значения  аргументов  и  ничего  более.  Значения
      по-умолчанию  не  поддерживаются.  Однако,  обратите  внимание,
      что  необязательные  и  именованные  аргументы  в  определении
      метода  могут  использовать  формы  первоначальных  значений
      по-умолчанию и могут использовать supplied-p параметры.</li></ul>
<!--l. 8855--><p class="indent" >   Также предоставляются следующие параметры. Данные параметры
могут использоваться только один раз, иначе будет сигнализирована
ошибка.
      <ul class="itemize1">
      <li class="itemize">Параметр                                    <b>:argument-precedence-order</b>
      используется  для  указания  порядка,  в  котором  обязательные
      аргументы в вызове обобщённой функции будут проверятся для
      выбора некоторого метода. Каждый обязательный аргумент, как
      указано  в  аргументе  <em>lambda-list</em>,  должен  быть  включён  только
      единожды  как  <em>parameter-name</em>,  чтобы  был  указан  полный  и
      недвусмысленный порядок приоритетности. Если данное условие
      не выполняется, то сигнализируется ошибка.
      </li>
      <li class="itemize">Параметр   <b><a 
href="symbols.html#x188-380307r307">declare</a></b>   используется   для   указания   деклараций,
      которые относятся к обобщённой функции. Разрешены следующий
      стандартные Common Lisp&#x2019;овые декларации:
           <ul class="itemize2">
           <li class="itemize">Декларация <b>optimize</b> указывает, должен ли механизм выбора
                                                                          

                                                                          
           метода  быть  оптимизирован  для  скорости  или  потребления
           памяти.  Данная  декларация  не  влияет  на  методы.  Для
           указания   того,   как   оптимизируется   метод,   декларация
           <b>optimize</b> должна использоваться прямо в форме <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>
           или в описании метода. Стандарт требует только два свойства
           оптимизации <b>speed</b> и <b>space</b>, реализации могут предоставлять
           другие  свойства.  Простая  реализация,  которая  содержит
           только   один   механизм   выбора   методов   и   игнорируется
           <b>optimize</b>, является корректной.</li></ul>
      <!--l. 8884--><p class="noindent" >Декларации <b>special</b>, <b>ftype</b>, <b><a 
href="symbols.html#x188-380446r446">function</a></b>, <b>inline</b>, <b>notinline</b> и <b>declaration</b> не
      разрешены. Отдельные реализации могут поддерживать дополнительные
      декларации в параметре <b><a 
href="symbols.html#x188-380307r307">declare</a></b>. Если реализация указывает на то, что
      декларация не поддерживается и она не была указана в прокламации
      <b>declaration</b> как нестандартная, реализация должна выдать
      предупреждение.
      </li>
      <li class="itemize">Аргумент <b>:documentation</b> ассоциирует строку документации с данной
      обобщённой функцией. Тип документации для этой строки <b><a 
href="symbols.html#x188-380446r446">function</a></b>.
      Для получения этой строки можно использовать <b>(documentation
      <em>function-name</em> &#x2019;function)</b>.
      </li>
      <li class="itemize">Параметр <b>:generic-function-class</b> может использоваться для указания
      того, что обобщённая функция имеет особенный, не стандартный
      (<b>standard-generic-function</b>) класс. Аргумент <em>class-name</em> является
      именем класса, который может использоваться для объектов
      обобщённых функций. Если <em>function-name</em> указывает на уже
      существующую обобщённую функцию, которая имеет другое значение
      данного параметра, и класс новой функции совместим со старым, то для
      изменения класса будет вызвана функция <b><a 
href="symbols.html#x188-380214r214">change-class</a></b>, иначе будет
      сигнализирована ошибка.
      </li>
      <li class="itemize">Параметр <b>:method-class</b> используется для указания того, что
      все методы данной обобщённой функции имеют особенный, не
      стандартный (<b>standard-method</b>) класс. Аргумент <em>class-name</em>
      является именем класса, который может выступать таковым для
                                                                          

                                                                          
      метода.
      </li>
      <li class="itemize">Параметр <b>:method-combination</b> и последующий символ указывают на
      тип сочетания методов. Аргументы (если есть), которые следуют за
      данным символом зависят от данного типа сочетания методов. Следует
      отметить, что стандартный тип сочетания методов не поддерживает
      каких-либо аргументов. Однако, все типы сочетаний методов,
      определённые с помощью краткой формы <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>
      принимают необязательный аргумент с именем <em>order</em>, по-умолчанию
      равный <b>:most-speciﬁc-ﬁrst</b>, где значение <b>:most-speciﬁc-last</b> меняет
      порядок главных методов на противоположный, но не касается
      вспомогательных методов.</li></ul>
<!--l. 8925--><p class="indent" >   Аргументы <em>method-description</em> определяет методы, которые будут
связаны с данной обобщённой функцией. Аргументы <em>method-qualiﬁer</em> и
<em>specialized-lambda-list</em> в описании метода значат то же, что и в <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>.
<!--l. 8930--><p class="indent" >   Аргументы <em>form</em> определяют тело метода. Тело метода заключается в
неявный блок. Если <em>function-name</em> является символом, данный блок будет
с тем же именем, что и обобщённая функция. Если <em>function-name</em>
является списком формы <b>(setf <em>symbol</em>)</b>, имя блока будет совпадать с
<em>symbol</em>.
<!--l. 8935--><p class="indent" >   Результатом является объект обобщённой функции.
<!--l. 8937--><p class="indent" >   Следствием макроса <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> является выполнение следующих трёх
шагов: первое, методы определённые с помощью предыдущей <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>
удаляются; второе, вызывается <b><a 
href="symbols.html#x188-380376r376">ensure-generic-function</a></b>; и третье, методы,
определённые в данной форме <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> добавляются в обобщённую
функцию.
<!--l. 8942--><p class="indent" >   Если ни одно описание метода не было указано и обобщённая функция до
этого не существовала, создаётся обобщённая функция без методов.
<!--l. 8945--><p class="indent" >   Аргумент <em>lambda-list</em> формы <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> указывает форму лямбда-списков
для методов данной обобщённой функции. Все её методы должны иметь
лямбда-списки согласованные с данной формой. Если форма <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>
вычисляется и некоторые методы для этой обобщённой функции содержат не
согласующиеся с этим аргументом лямбда-списки, сигнализируется ошибка.
Для подробностей смотрите раздел <a 
href="clmse143.html#x175-27200027.1.6">27.1.6<!--tex4ht:ref: Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION --></a>.
<!--l. 8953--><p class="indent" >   Реализации могут расширять <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> дополнительными параметрами.
Однако реализация должна сигнализировать ошибку при столкновении с
неподдерживаемым параметром.
                                                                          

                                                                          
<!--l. 8957--><p class="indent" >   Смотрите раздел <a 
href="clmse143.html#x175-27200027.1.6">27.1.6<!--tex4ht:ref: Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION --></a>.
<!--l. 8960--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>, <b><a 
href="symbols.html#x188-380376r376">ensure-generic-function</a></b> и <b><a 
href="symbols.html#x188-380452r452">generic-function</a></b>.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 8965--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>deﬁne-method-combination</b> <a 
 id="dx176-302018"></a>name [[<span class="math"> ↓</span>short-form-option]]
   <br>
<!--l. 8965--><p class="noindent" ></div>
</div>
<div class="defmacheader">
<!--l. 8965--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>deﬁne-method-combination</b> <a 
 id="dx176-302019"></a>name lambda-list({method-group-speciﬁer}*)[(<b>:arguments</b> <b>.</b> lambda-list)][(<b>:generic-function</b> generic-fn-symbol)][[{declaration}* | doc-string]]{form}*
   <br>
<!--l. 8972--><p class="noindent" ></div>
</div>
<!--l. 8973--><p class="indent" >   <div class="tabbing">
<em>short-form-option</em> ::= <b>:documentation <em>string</em></b>
   <br>   | <b>:identity-with-one-argument <em>boolean</em></b><br>   | <b>:operator <em>operator</em></b><br>
<em>method-group-speciﬁer</em> ::= <b>(</b><em>variable</em> {<i> {<i>qualiﬁer-pattern</i>}+ | predicate</i>} <br>
                            [[<i><span class="math"> ↓</span><i>long-form-option</i></i>]] <b>)</b><br>
<em>long-form-option</em> ::= <b>:description <em>format-string</em></b><br>         | <b>:order <em>order</em></b><br>
| <b>:required <em>boolean</em></b><br>
<!--l. 8983--><p class="noindent" ></div>Макрос <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b> используется для определения новых
типов сочетаний методов.
<!--l. 8987--><p class="indent" >   Макрос <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b> имеет две формы. Краткая форма
предоставляет упрощённую функциональность для частого и быстрого
использования. Длинная форма более мощная, но и более подробная. Макрос
схож с <b><a 
href="symbols.html#x188-380320r320">defmacro</a></b> в том, что тело является выражением, обычно с
использованием обратной кавычки, которое вычисляется в Lisp&#x2019;овую форму.
                                                                          

                                                                          
Таким образом, реализованы могут быть любые управляющие конструкции.
Длинная форма также позволяет произвольную обработку квалификаторов
методов.
<!--l. 8995--><p class="indent" >   В обеих формах <em>name</em> является символом. По соглашению, оно не может
быть ключевым символом или <b><a 
href="symbols.html#x188-380670r670">nil</a></b>.
<!--l. 8998--><p class="indent" >   Если вторая подформа является не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> символом или не представлена
вовсе, используется синтаксис краткой формы <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>.
Когда используется краткая форме, <em>name</em> определяется как тип сочетания
методов, который создаёт Lisp&#x2019;овую форму <b>(<em>operator method-call
method-call <span class="math">…</span> </em>)</b>. <em>operator</em> является символом, которые может быть именем
функции, макроса или специального оператора. <em>operator</em> может быть указан
ключевым параметров, по-умолчанию он равен <em>name</em>.
<!--l. 9006--><p class="indent" >   Ключевые параметры для краткой формы:
      <ul class="itemize1">
      <li class="itemize">Параметр  <b>:documentation</b> используется  для  документирования
      типа сочетания методов.
      </li>
      <li class="itemize">Параметр <b>:identity-with-one-argument</b> включает оптимизацию,
      когда  <em>boolean</em> является  истиной  (значение  по-умолчанию  ложь).
      Если существует только один применимый метод, и он является
      главным, тогда метод расценивается как рабочий, и <em>operator</em> не
      вызывается. Эта оптимизация исключает необходимость создания
      нового рабочего метода и расхода ресурсов на вызов функции. Этот
      параметр спроектирован для использования с такими операторами,
      как <b><a 
href="symbols.html#x188-380761r761">progn</a></b>, <b><a 
href="symbols.html#x188-380098r98">and</a></b>, <b><a 
href="symbols.html#x188-380060r60">+</a></b> и <b><a 
href="symbols.html#x188-380624r624">max</a></b>.
      </li>
      <li class="itemize">Параметр <b>:operator</b> указывает имя оператора. Аргумент <em>operator</em>
      является символом, которые может быть именем функции, макроса
      или специального оператора. По соглашению, чаще всего символы
      <em>name</em> и <em>operator</em> совпадают, но это не обязательно.</li></ul>
<!--l. 9031--><p class="indent" >   Ни одна из подформ не вычисляется.
<!--l. 9033--><p class="indent" >   Эти типы сочетания методов требуют только одного квалификатора для
одного метода. В случае наличия применимых методов без квалификаторов,
или с неподдерживаемыми данными типом сочетания квалификаторами,
сигнализируется ошибка.
                                                                          

                                                                          
<!--l. 9038--><p class="indent" >   Определённая таким образом процедура сочетания методов для методов
определяет две роли. Метод, у которого единственный квалификатор
является таким же символом, что и тип сочетания, считается главным.
Как минимум один главный метод должен быть применимым, иначе
сигнализируется ошибка. Метод с единственным квалификатором <b>:around</b>
является вспомогательным, и его поведение совпадает с такими же методами
в стандартном типе сочетания методов. Функция <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>
может быть вызвана только в <b>:around</b> методах. Она не может быть
использована в главных методах, определённых краткой формой макроса
<b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>.
<!--l. 9048--><p class="indent" >   Определённая таким образом процедура сочетания методов, принимает
необязательный аргумент с именем <em>order</em>, который по-умолчанию равен
<b>:most-speciﬁc-ﬁrst</b>. Значение <b>:most-speciﬁc-last</b> изменяет порядок главный
метод на обратный, порядок же вспомогательных методов остаётся
прежним.
<!--l. 9053--><p class="indent" >   Краткая форма автоматически включает проверку ошибок и поддержку
для <b>:around</b> методов.
<!--l. 9056--><p class="indent" >   Описание встроенных типов сочетания методов смотрите в разделе <a 
href="clmse143.html#x175-27800027.1.7">27.1.7<!--tex4ht:ref: Built-in-Method-Combination-Types-SECTION --></a>.
<!--l. 9059--><p class="indent" >   Если вторая подформа является списком, используется синтаксис
длинной формы <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>.
<!--l. 9062--><p class="indent" >   Аргумент <em>lambda-list</em> является обычным лямбда-списком. Он принимает
любые аргументы, указанные после имени сочетания методов в параметре
<b>:method-combination</b> в форме <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>.
<!--l. 9066--><p class="indent" >   Далее следует список спецификаторов группирования методов. Каждый
спецификатор или с помощью сравнения квалификаторов с некоторыми
шаблонами, или проверкой квалификаторов с помощью предиката выделяет
подмножество применимых для некоторой роли методов. Эти спецификаторы
группирования методов определяют все квалификаторы, которые
могут использоваться для данного типа сочетания методов. Если
применимый метод не попадает ни в одну из групп, система сигнализирует
ошибку о том, что метод некорректен для использования с этим типом
сочетания.
<!--l. 9075--><p class="indent" >   Каждый спецификатор группирования методов указывает на переменную.
В процессе выполнения форм в теле <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>,
эта переменная связывается со списком методов в данной группе.
Методы в данном списке отсортированы от наиболее специфичного к
наименее.
<!--l. 9080--><p class="indent" >   Квалификационный шаблон является списком или символом <b><a 
href="symbols.html#x188-380011r11">*</a></b>. Метод
                                                                          

                                                                          
подходит под шаблон, если список квалификаторов метода равен <b><a 
href="symbols.html#x188-380381r381">equal</a></b>
шаблону (за исключением того, что символ <b><a 
href="symbols.html#x188-380011r11">*</a></b> указывает на любой
квалификатор). Таким образом квалификационный шаблон может
быть одним из следующих: пустой список <b>()</b>, который указывает на
неквалифицированный метод; символ <b><a 
href="symbols.html#x188-380011r11">*</a></b>, который указывает на все методы; Ъ
список, который указывает на метод с таким же количеством таких же что и
в нём квалификаторов или список с точкой, который заканчивается
символом <b><a 
href="symbols.html#x188-380011r11">*</a></b> (<b><a 
href="symbols.html#x188-380011r11">*</a></b> указывает на любое количество дополнительный
квалификаторов).
<!--l. 9092--><p class="indent" >   Каждый применимый метод проверяется на соотвествие квалификационным
шаблонам и предикатам в порядке слева направо. Как только метод
удовлетворяет квалификационному шаблону или предикату, метод
становится элементом соответствующей группировки методов и больше ни на
что не проверяется. Таким образом, если метод может быть элементом более
одной группы, он включается только в первую группу. Если группировка
методов содержит более одного квалификационного шаблона, метод должен
удовлетворить только одному шаблону.
<!--l. 9100--><p class="indent" >   В спецификаторе группирования методов вместо квалификационных
шаблонов может быть указано имя предиката. Предикат вызывается для
каждого метода, который ещё не входит ни в одну группу. Он вызывается с
одним аргументом: списком квалификаторов метода. Предикат должен
вернуть истину, если метод принадлежит некоторой группе методов.
Предикат может быть отличён от квалификационного шаблона, потому что
это символ не может быть <b><a 
href="symbols.html#x188-380670r670">nil</a></b> или <b><a 
href="symbols.html#x188-380011r11">*</a></b>.
<!--l. 9107--><p class="indent" >   Если для данного типа сочетания методов у применимых методов
квалификаторы не являются корректными, вызывается функция
<b><a 
href="symbols.html#x188-380508r508">invalid-method-error</a></b>.
<!--l. 9110--><p class="indent" >   Спецификаторы группирования методов после квалификационных
шаблонов или предиката могут содержать ключевые параметры. Ключевые
параметры могут быть отличены от дополнительных квалификационных
шаблонов, потому что не являются списками или символом <b><a 
href="symbols.html#x188-380011r11">*</a></b>. Ключевые
параметры:
      <ul class="itemize1">
      <li class="itemize">Параметр <b>:description</b> используется для указания описания роли
      методов  в  группе.  Инструменты  программного  окружения  для
      вывода  этого  описания  используют  <b>(apply  #&#x2019;format  stream
                                                                          

                                                                          
      <em>format-string</em> (method-qualiﬁers <em>method</em>))</b>. Данный ключевой
      параметр позволяет определить описание квалификатора метода в
      том        же        модуле,        в        котором        определяется
      смысл этого квалификатора. В большинстве случаев, <em>format-string</em>
      не  содержит  каких-либо  директив,  но  в  целом  использовать
      директивы  можно.  Если  <b>:description</b>  не  указан,  генерируется
      описание по-умолчанию. При этом используются имя переменной
      и  квалификационные  шаблоны  и  условие,  принимаются  ли  в
      группу неквалифицированные методы. Аргумент <em>format-string</em> не
      вычисляется.
      </li>
      <li class="itemize">Параметр  <b>:order</b>  указывает  порядок  методов.  Аргумент  <em>order</em>
      является  формой,  которая  вычисляется  в  <b>:most-speciﬁc-ﬁrst</b>
      или   <b>:most-speciﬁc-last</b>.   Если   форма   вычисляется   в   любое
      другое  значение,  сигнализируется  ошибка.  Данный  ключевой
      параметр  введён  для  удобства  и  не  предоставляет  излишней
      функциональности. Если <b>:order</b> не указан, используется значение
      <b>:most-speciﬁc-ﬁrst</b>.
      </li>
      <li class="itemize">Параметр <b>:required</b> указывает требуется ли в данной группе хотя
      бы  один  метод.  Если  аргумент  <em>boolean</em>  равен  не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b>  и  группа
      методов пуста (то есть, ни один применимый метод не подошёл
      к квалификационному шаблону или не удовлетворил предикату),
      сигнализируется  ошибка.  Этот  ключевой  параметр  введён  для
      удобства и не предоставляет излишней функциональности. Если
      <b>:required</b> не указан, используется значение <b><a 
href="symbols.html#x188-380670r670">nil</a></b>. Аргумент <em>boolean</em>
      не вычисляется.</li></ul>
<!--l. 9146--><p class="indent" >   Использование спецификаторов группирования методов предоставляет
удобный синтаксис для выбора методов, разделения их на возможные роли, и
выполнения необходимой проверки ошибок. Возможно выполнение
дальнейшей фильтрации методов в теле с помощью использования
обычных операций обработки списком и функций <b><a 
href="symbols.html#x188-380636r636">method-qualiﬁers</a></b> и
<b><a 
href="symbols.html#x188-380508r508">invalid-method-error</a></b>. Возможно использования <b><a 
href="symbols.html#x188-380845r845">setq</a></b> для переменных,
указанных в спецификаторах группирования методов и связывание
дополнительных переменных. Также возможно выполнение любых форм.
Можно использовать только одну группу методов с шаблоном <b><a 
href="symbols.html#x188-380011r11">*</a></b>. В этом
                                                                          

                                                                          
случае переменная будет связана со списком всех применимых методов в
порядке от наиболее специфичного к наименее.
<!--l. 9157--><p class="indent" >   Тело из форм <em>forms</em> выполняет вычисления и возвращает Lisp&#x2019;овую
форму, которая определяет то, как сочетаются методы, то есть возвращает
рабочий метод. Рабочий метод используется макрос <b><a 
href="symbols.html#x188-380189r189">call-method</a></b>.
Определение этого макроса имеет лексическую область видимости и доступно
только внутри рабочего метода. Учитывая метод объекта в одном
из списков, полученных с помощью спецификатора группирования
методов и список следующих методов, макрос <b><a 
href="symbols.html#x188-380189r189">call-method</a></b> будет
вызывать метод так, что для вызова следующего метода будет доступна
<b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>.
<!--l. 9167--><p class="indent" >   Когда рабочий метод не имеет никакого эффекта, кроме того как вызвать
один метод, некоторые реализации используют оптимизацию, которая
использует единственный метод непосредственно в качестве рабочего метода,
что позволяет избежать необходимости создать новый рабочий метод. Эта
оптимизация является активным, если форма рабочего метода состоит
полностью из вызова макроса <b><a 
href="symbols.html#x188-380189r189">call-method</a></b>, первая подформа которого
является объектом метода и вторая является подчинённой <b><a 
href="symbols.html#x188-380670r670">nil</a></b>. Если
требуется оптимизация каждое тело <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>
несёт ответственность за удаление избыточных вызовов <b><a 
href="symbols.html#x188-380761r761">progn</a></b>, <b><a 
href="symbols.html#x188-380098r98">and</a></b>,
<b><a 
href="symbols.html#x188-380659r659">multiple-value-prog1</a></b>, и тому подобных.
<!--l. 9179--><p class="indent" >   Список <b>(:arguments . <em>lambda-list</em>)</b> может быть указан перед любой
декларацией или строкой документации. Эта форма полезна, когда тип
сочетания методов выполняет некоторое особенное поведение как часть
объединённого метода, и это поведение требует доступа к аргументам
обобщённой функции. Каждая переменная параметра, определённый в
<em>lambda-list</em>, связывается с формой, которая может быть вставлена в рабочий
метод. Когда эта форма вычисляется в процессе выполнения рабочего
метода, её значение является соответствующим аргументом к обобщённой
функции. Если <em>lambda-list</em> не согласован с лямбда-списком обобщённой
функции, для согласования будут вставлены дополнительные игнорируемые
параметры. Таким образом, <em>lambda-list</em> может получать меньше аргументов,
чем ожидает обобщённая функция.
<!--l. 9191--><p class="indent" >   Ошибочные условия, обнаруженные в теле, должны быть опубликованы с
помощью <b><a 
href="symbols.html#x188-380632r632">method-combination-error</a></b> или <b><a 
href="symbols.html#x188-380632r632">method-combination-error</a></b>. Эти
функции добавляют любую необходимую контекстную информацию с
сообщением об ошибке и сигнализируют соответствующую ошибку.
<!--l. 9196--><p class="indent" >   Тело <em>forms</em> вычисляется внутри связываний, созданных лямбда-списком и
                                                                          

                                                                          
спецификаторами группирования методов. Декларации в начале тела
помещаются напрямую внутрь связывании, созданных лямбда-списком, и вне
связываний переменных группирования методов. Таким образом переменные
группирования методов не могут быть задекларированы.
<!--l. 9202--><p class="indent" >   Внутри тела <em>form</em>, <em>generic-function-symbol</em> связан с объектом обобщённой
функции.
<!--l. 9205--><p class="indent" >   Если указан аргумент <em>doc-string</em>, он содержит строку документации для
типа сочетания методов.
<!--l. 9208--><p class="indent" >   Из тела <em>forms</em> или из функций, вызванных в этом теле, могут быть
вызваны функции <b><a 
href="symbols.html#x188-380632r632">method-combination-error</a></b> и <b><a 
href="symbols.html#x188-380508r508">invalid-method-error</a></b>.
Действия этих двух функций зависят от динамических переменных, которые
были автоматически связаны перед вызовом обобщённой функции
<b><a 
href="symbols.html#x188-380275r275">compute-eﬀective-method</a></b>.
<!--l. 9213--><p class="indent" >   Результатом вычисления макроса <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b> является
новый объект сочетания методов.
<!--l. 9216--><p class="indent" >   Большинство примеров использования длинной формы
<b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b> также иллюстрируют использования
связанных функций, которые предоставлены как часть функционала
декларативного сочетания методов.
<div class="lisp">
<tt>
<!--l. 9220--><p class="indent" >   <div class="tabbing">
;;; Примеры краткой формы deﬁne-method-combination
   <br>                                                                                               <br>
(deﬁne-method-combination and :identity-with-one-argument t)<br>            <br>
(defmethod func and ((x class1) y)<br>                                     ...)<br>
<br>                         ;;; Эквивалент этого примера в длинной форме:<br>
<br>                                          (deﬁne-method-combination and<br>
        (&#x0026;optional (order &#x2019;:most-speciﬁc-ﬁrst))<br>
        ((around (:around))<br>         (primary (and) :order order :required t))<br>
  (let ((form (if (rest primary)<br>                  ‘(and ,@(mapcar #&#x2019;(lambda (method)<br>
                                      ‘(call-method ,method ()))<br>
                                  primary))<br>
                  ‘(call-method ,(ﬁrst primary) ()))))<br>
    (if around<br>                               ‘(call-method ,(ﬁrst around)<br>
                                                                          

                                                                          
                      (,@(rest around)<br>                       (make-method form)))<br>
        form)))<br>                             <br>                                       <br>
;;; Пример длинной формы deﬁne-method-combination<br>                   <br>
;;; Способ сочетания методов по-умолчанию<br>                             <br>
(deﬁne-method-combination standard ()<br>              ((around (:around))<br>
         (before (:before))<br>                      (primary () :required t)<br>
         (after (:after)))<br>                   (ﬂet ((call-methods (methods)<br>
           (mapcar #&#x2019;(lambda (method)<br>                       ‘(call-method ,method ()))<br>
                   methods)))<br>    (let ((form (if (or before after (rest primary))<br>
                    ‘(multiple-value-prog1<br>
                       (progn ,@(call-methods before)<br>
                              (call-method ,(ﬁrst primary)<br>
                                           ,(rest primary)))<br>
                       ,@(call-methods (reverse after)))<br>
                    ‘(call-method ,(ﬁrst primary) ()))))<br>
      (if around<br>                            ‘(call-method ,(ﬁrst around)<br>
                        (,@(rest around)<br>                         (make-method form)))<br>
          form))))<br>
<!--l. 9271--><p class="noindent" ></div>
</tt>
</div>
<div class="lisp">
<tt>
<!--l. 9274--><p class="indent" >   <div class="tabbing">
;;; Простой путь вызова нескольких методов, пока не вернётся не-nil
   <br>                          <br>                          (deﬁne-method-combination or ()<br>
        ((methods (or)))<br>            ‘(or ,@(mapcar #&#x2019;(lambda (method)<br>
                     ‘(call-method ,method ()))<br>
                 methods)))<br>                                           <br>
;;; Более полная версия предыдущего примера<br>
<br>                                            (deﬁne-method-combination or<br>
        (&#x0026;optional (order &#x2019;:most-speciﬁc-ﬁrst))<br>
        ((around (:around))<br>                             (primary (or)))<br>
  ;; Process the order argument<br>     (case order<br>       (:most-speciﬁc-ﬁrst)<br>
    (:most-speciﬁc-last (setq primary (reverse primary)))<br>
                                                                          

                                                                          
    (otherwise (method-combination-error<br>                 &#x0022;~S is an invalid order.~@<br>
                  :most-speciﬁc-ﬁrst and :most-speciﬁc-last ~<br>
                    are the possible values.&#x0022;<br>
                                         order)))<br>
  ;; Must have a primary method<br>                          (unless primary<br>
    (method-combination-error &#x0022;A primary method is required.&#x0022;))<br>
  ;; Construct the form that calls the primary methods<br>
  (let ((form (if (rest primary)<br>                  ‘(or ,@(mapcar #&#x2019;(lambda (method)<br>
                                     ‘(call-method ,method ()))<br>
                                 primary))<br>
                  ‘(call-method ,(ﬁrst primary) ()))))<br>
    ;; Wrap the around methods around that form<br>
    (if around<br>                               ‘(call-method ,(ﬁrst around)<br>
                      (,@(rest around)<br>                       (make-method form)))<br>
        form)))<br>
<!--l. 9313--><p class="noindent" ></div>
</tt>
</div>
<div class="lisp">
<tt>
<!--l. 9316--><p class="indent" >   <div class="tabbing">
;;; То же, с использованием ключевых параметров :order и :required
   <br>                                                       (deﬁne-method-combination or<br>
        (&#x0026;optional (order &#x2019;:most-speciﬁc-ﬁrst))<br>
        ((around (:around))<br>         (primary (or) :order order :required t))<br>
  (let ((form (if (rest primary)<br>                  ‘(or ,@(mapcar #&#x2019;(lambda (method)<br>
                                     ‘(call-method ,method ()))<br>
                                 primary))<br>
                  ‘(call-method ,(ﬁrst primary) ()))))<br>
    (if around<br>                               ‘(call-method ,(ﬁrst around)<br>
                      (,@(rest around)<br>                       (make-method form)))<br>
        form)))<br>                                                          <br>
;;; This short-form call is behaviorally identical to the preceding.<br>
(deﬁne-method-combination or :identity-with-one-argument t)<br>             <br>
;;; Сортировка методов по положительному целому квалификатору; :around<br>
                                                                          

                                                                          
;;; метода для краткости примера отключены.<br>                           <br>
(deﬁne-method-combination example-method-combination ()<br>
        ((methods positive-integer-qualiﬁer-p))<br>
  ‘(progn ,@(mapcar #&#x2019;(lambda (method)<br>                        ‘(call-method ,method ()))<br>
                    (stable-sort methods #&#x2019;&#x003C;<br>
                      :key #&#x2019;(lambda (method)<br>
                               (ﬁrst (method-qualiﬁers<br>
                                        method)))))))<br>
<br>                      (defun positive-integer-qualiﬁer-p (method-qualiﬁers)<br>
  (and (= (length method-qualiﬁers) 1)<br>       (typep (ﬁrst method-qualiﬁers) &#x2019;(integer 0 *))))<br>
<br>                                    ;;; Пример использования :arguments<br>
(deﬁne-method-combination progn-with-lock ()<br>
        ((methods ()))<br>                              (:arguments object)<br>
  ‘(unwind-protect<br>                     (progn (lock (object-lock ,object))<br>
              ,@(mapcar #&#x2019;(lambda (method)<br>
                            ‘(call-method ,method ()))<br>
                        methods))<br>     (unlock (object-lock ,object))))<br>
<!--l. 9362--><p class="noindent" ></div>
</tt>
</div>
<!--l. 9364--><p class="indent" >   Параметр <b>:method-combination</b> <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> используется для указания
того, что обобщённая функция должна использовать специальный тип
сочетания методов. Аргумент в параметре <b>:method-combination</b> является
именем этого типа сочетания методов.
<!--l. 9369--><p class="indent" >   Смотрите разделы <a 
href="clmse143.html#x175-27400027.1.7">27.1.7<!--tex4ht:ref: Method-Selection-and-Combination-SECTION --></a> и <a 
href="clmse143.html#x175-27800027.1.7">27.1.7<!--tex4ht:ref: Built-in-Method-Combination-Types-SECTION --></a>.
<!--l. 9372--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380189r189">call-method</a></b>, <b><a 
href="symbols.html#x188-380636r636">method-qualiﬁers</a></b>, <b><a 
href="symbols.html#x188-380632r632">method-combination-error</a></b>,
<b><a 
href="symbols.html#x188-380508r508">invalid-method-error</a></b> и <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 9380--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>defmethod</b> <a 
 id="dx176-302020"></a>function-name {method-qualiﬁer}*specialized-lambda-list[[{declaration}* | doc-string]] {form}*
   <br>
<!--l. 9383--><p class="noindent" ></div>
</div>
                                                                          

                                                                          
<!--l. 9384--><p class="indent" >   <div class="tabbing">
<em>function-name</em> ::=  {<i><em>symbol</em> | <b>(setf <em>symbol</em>)</b></i>}
   <br>                                                   <em>method-qualiﬁer</em> ::= <em>non-nil-atom</em><br>
<em>parameter-specializer-name</em> ::= <em>symbol</em> | <b>(eql <em>eql-specializer-form</em>)</b><br>
<!--l. 9388--><p class="noindent" ></div>Макрос <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> определяет метод для обобщённой функции.
<!--l. 9391--><p class="indent" >   Если форма <b>(fboundp <em>function-name</em>)</b> равна <b><a 
href="symbols.html#x188-380670r670">nil</a></b>, создаётся обобщённая
функция со значениями по-умолчанию: для списка приоритетности
аргументов (каждый аргумент более специфический чем те, которые в
списке стоят справа от него), для класса обобщённой функции (класс
<b>standard-generic-function</b>), для класса метод (класс <b>standard-class</b>) и
для типа сочетания методов (стандартный тип сочетания методов).
Лямбда-список обобщённой функция будет согласован с лямбда-списком
определяемого метода. Если форма <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> содержит именованные
параметры, лямбда-список обобщённой функции будет содержать <b>&#x0026;key</b> (но
не сами именованные параметры). Если <em>function-name</em> указывает на
необобщённую функцию, макрос или специальный оператор, сигнализируется
ошибка.
<!--l. 9403--><p class="indent" >   Если обобщённая функция <em>function-name</em> уже существует (где
<em>function-name</em> является символом или списком типа <b>(setf <em>symbol</em>)</b>),
лямбда-список метода должен быть согласован с её лямбда-списком. Если это
условие не выполняется, сигнализируется ошибка. Для определения
согласованности смотрите раздел <a 
href="clmse143.html#x175-27200027.1.6">27.1.6<!--tex4ht:ref: Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION --></a>.
<!--l. 9410--><p class="indent" >   Аргумент <em>function-name</em> является не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> символом или списком формы
<b>(setf <em>symbol</em>)</b>. Он указывает на обобщённую функцию, для которой
определяется метод.
<!--l. 9414--><p class="indent" >   Каждый аргумент <em>method-qualiﬁer</em> является объектом, который
используется объектом сочетания методов для определения данного
метода. Квалификатор метода является не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> атомом. Тип сочетания
методов может ограничивать допустимые значения квалификаторов.
Стандартный тип сочетания методов допускает неквалифицированные
методы или методы, у которых назначено исключительно <b>:before</b>, <b>:after</b> или
<b>:around</b>.
<em>
<!--l. 9421--><p class="indent" >   specialize-lambda-list</em> является обычным лямбда-списком за исключением
того, что имена обязательных параметров могут быть заменены
                                                                          

                                                                          
специализированными параметрами, а, именно, списком вида <b>(<em>variable-name
parameter-specializer-name</em>)</b>. Специализированы могут быть только
обязательные параметры. Имя специализатора параметра является
символом, указывающим на класс или <b>(eql <em>eql-specializer-form</em>)</b>.
Специализатор параметра вида <b>(eql <em>eql-specializer-form</em>)</b> указывает на то,
что соответствующий аргумент должен быть равен <b><a 
href="symbols.html#x188-380379r379">eql</a></b> объекту, который
является значением <em>eql-specializer-form</em> для применяемого метода. Если для
некоторого обязательного параметра не указан специализатор, то в
предполагается список вида <b>(<em>variable-name <b><a 
href="symbols.html#x188-380951r951">t</a></b></em>)</b>. Смотрите раздел <a 
href="clmse143.html#x175-27000027.1.6">27.1.6<!--tex4ht:ref: Introduction-to-Methods-SECTION --></a>.
<!--l. 9434--><p class="indent" >   Аргументы <em>form</em> задают тело метода. Тело метода заключается в неявный
блок. Если <em>function-name</em> является символом, этот блок будет иметь такое же
имя, как и обобщённая функция. Если <em>function-name</em> является списком вида
<b>(setf <em>symbol</em>)</b>, имя блока будет равно <em>symbol</em>.
<!--l. 9440--><p class="indent" >   Результатом <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> является объект метода.
<!--l. 9442--><p class="indent" >   Классом объекта метода, будет является класс, который указан
в параметре обобщённой функции, для которой создаётся данный
метод.
<!--l. 9445--><p class="indent" >   Если обобщённая функция уже содержит метод, который согласуется с
текущим в специализаторах параметров и квалификаторах, <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>
заменяет существующий метод новым. Для термина «согласование» в данном
контексте смотрите раздел <a 
href="clmse143.html#x175-27100027.1.6">27.1.6<!--tex4ht:ref: Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION --></a>.
<!--l. 9450--><p class="indent" >   Специализаторы параметров описаны в разделе <a 
href="clmse143.html#x175-27000027.1.6">27.1.6<!--tex4ht:ref: Introduction-to-Methods-SECTION --></a>.
<!--l. 9452--><p class="indent" >   Раскрытие макроса <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b> ссылается на каждый специализированный
параметр (смотрите спецификатор декларации <b>ignore</b>), включая параметры,
которые содержат явное имя специализатора <b><a 
href="symbols.html#x188-380951r951">t</a></b>. Это означает, что
предупреждений компилятора не будет, если тело метода не ссылается на
специализированный параметр. Следует отметить, что параметр, который
специализирован классом <b><a 
href="symbols.html#x188-380951r951">t</a></b>, в этом контексте не является синонимом для
неспециализированного параметра (который неявно специализируется к
классу <b><a 
href="symbols.html#x188-380951r951">t</a></b>).
<!--l. 9461--><p class="indent" >   Смотрите разделы <a 
href="clmse143.html#x175-27000027.1.6">27.1.6<!--tex4ht:ref: Introduction-to-Methods-SECTION --></a>, <a 
href="clmse143.html#x175-27200027.1.6">27.1.6<!--tex4ht:ref: Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION --></a> и <a 
href="clmse143.html#x175-27100027.1.6">27.1.6<!--tex4ht:ref: Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION --></a>.
<hr></div>
<!--l. 9467--><p class="indent" >   [At this point the original CLOS report <span class="cite">[<a 
href="bib.html#XSIGPLAN-CLOS">5</a>, <a 
href="bib.html#XLASC-CLOS-PART-2">7</a>]</span> contained a speciﬁcation for
<b><a 
href="symbols.html#x188-380337r337">describe</a></b> as a generic function. This speciﬁcation is omitted here because X3J13
voted in March 1989 <a 
 id="dx176-302021"></a>not to make <b><a 
href="symbols.html#x188-380337r337">describe</a></b> a generic function after all (see
<b><a 
href="symbols.html#x188-380338r338">describe-object</a></b>).—GLS]
<div class="defun">
                                                                          

                                                                          
<div class="defunheader">
<a 
 id="dx176-302022"></a>
<em>
<!--l. 9474--><p class="noindent" >[Обобщённая функция]</em> <b>documentation</b> <i>x</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302023"></a>
<em>
[Главный метод]</em> <b>documentation</b> (<i>method</i> standard-method) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt>
<i>doc-type</i><br />
<a 
 id="dx176-302024"></a>
<em>
[Главный метод]</em> <b>documentation</b> (<i>generic-function</i> standard-generic-function)
<tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302025"></a>
<em>
[Главный метод]</em> <b>documentation</b> (<i>class</i> standard-class) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt>
<i>doc-type</i><br />
<a 
 id="dx176-302026"></a>
<em>
[Главный метод]</em> <b>documentation</b> (<i>method-combination</i> method-combination)
<tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302027"></a>
<em>
[Главный метод]</em> <b>documentation</b> (<i>slot-description</i> standard-slot-description)
<tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302028"></a>
<em>
[Главный метод]</em> <b>documentation</b> (<i>symbol</i> symbol) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302029"></a>
<em>
[Главный метод]</em> <b>documentation</b> (<i>list</i> list) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i>
</div>
<!--l. 9483--><p class="indent" >   Обычная функция <b><a 
href="symbols.html#x188-380352r352">documentation</a></b> (смотрите раздел ??) была заменена
обобщённой функцией. Обобщённая функция <b><a 
href="symbols.html#x188-380352r352">documentation</a></b> возвращает
строку документации, связанную с данным объектом. Если строка
документации не доступна возвращает <b><a 
href="symbols.html#x188-380670r670">nil</a></b>.
<!--l. 9488--><p class="indent" >   Первый аргумент функции может быть символом, именем функции в
форме <b>(setf <em>symbol</em>)</b>, объектом метода, объектом класса, объектом
                                                                          

                                                                          
обобщённой функции, объектом сочетания методов или объектом описания
слота. Необходимо ли указывать второй аргумент зависит от типа первого
аргумента.
      <ul class="itemize1">
      <li class="itemize">Второй  аргумент  должен  быть  указан,  если  первый  аргумент
      является объектом метода, объектом класса, объектом обобщённой
      функции,  объектом  сочетания  методов  или  объектом  описания
      слота, иначе будет сигнализирована ошибка.
      </li>
      <li class="itemize">Второй  аргумент  должен  быть  указан,  если  первый  аргумент
      является символом или списком вида <b>(setf <em>symbol</em>)</b>.
      </li>
      <li class="itemize">Формы <div class="lisp"><tt><div class="tabbing">
      (documentation <em>symbol</em> &#x2019;function)
      <br>
      <!--l. 9507--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 9508--><p class="noindent" >и <div class="lisp"><tt><div class="tabbing">
      (documentation &#x2019;(setf <em>symbol</em>) &#x2019;function)
      <br>
      <!--l. 9511--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 9512--><p class="noindent" >возвращают строку документации для функции, обобщённой функции,
      специального оператора или макроса, которые указываются символом
      или списком.
                                                                          

                                                                          
      </li>
      <li class="itemize">Форма <b>(documentation <em>symbol</em> &#x2019;variable)</b> возвращает строку
      документации специальной переменной или константы, которые
      указываются символом.
      </li>
      <li class="itemize">Форма <b>(documentation <em>symbol</em> &#x2019;structure)</b> возвращает строку
      документации для структуры <b><a 
href="symbols.html#x188-380325r325">defstruct</a></b>, которая указывается
      символом.
      </li>
      <li class="itemize">Форма <b>(documentation <em>symbol</em> &#x2019;type)</b> возвращает строку документации
      для объекта класса, который указывается символом, если такой класс
      имеется. Если класс не был найден, функция возвращает строку
      документации для спецификатора типа, который указывается
      символом.
      </li>
      <li class="itemize">Форма <b>(documentation <em>symbol</em> &#x2019;setf)</b> возвращает строку документации
      для связанных с символом определений <b><a 
href="symbols.html#x188-380324r324">defsetf</a></b> или <b><a 
href="symbols.html#x188-380318r318">deﬁne-setf-method</a></b>
      .
      </li>
      <li class="itemize">Форма <b>(documentation <em>symbol</em> &#x2019;method-combination)</b> возвращает
      строку документации для типа сочетания методов, который
      указывается символом.</li></ul>
<!--l. 9537--><p class="indent" >   Реализация может дополнять множество символов, использующихся во
втором аргументе. Если реализация не поддерживает символ, переданный во
втором аргументе, должна быть сигнализирована ошибка.
<!--l. 9541--><p class="indent" >   Функция возвращает связанную строку документации. Если такой строки
нет, возвращается <b><a 
href="symbols.html#x188-380670r670">nil</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302030"></a>
<em>
                                                                          

                                                                          
<!--l. 9547--><p class="noindent" >[Обобщённая функция]</em> <b>(setf documentation)</b>  <i>new-value</i> <i>x</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt>
<i>doc-type</i><br />
<a 
 id="dx176-302031"></a>
<em>
[Главный метод]</em> <b>(setf documentation)</b>  <i>new-value</i> (<i>method</i> standard-method)
<tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302032"></a>
<em>
[Главный метод]</em> <b>(setf documentation)</b>  <i>new-value</i>
(<i>generic-function</i> standard-generic-function) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302033"></a>
<em>
[Главный метод]</em> <b>(setf documentation)</b>  <i>new-value</i> (<i>class</i> standard-class)
<tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302034"></a>
<em>
[Главный метод]</em> <b>(setf documentation)</b>  <i>new-value</i>
(<i>method-combination</i> method-combination) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302035"></a>
<em>
[Главный метод]</em> <b>(setf documentation)</b>  <i>new-value</i>
(<i>slot-description</i> standard-slot-description) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302036"></a>
<em>
[Главный метод]</em> <b>(setf documentation)</b>  <i>new-value</i> (<i>symbol</i> symbol)
<tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>doc-type</i><br />
<a 
 id="dx176-302037"></a>
<em>
[Главный метод]</em> <b>(setf documentation)</b>  <i>new-value</i> (<i>list</i> list) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt>
<i>doc-type</i>
</div>
<!--l. 9556--><p class="indent" >   Обобщённая функция <b>(setf documentation)</b> используется для установки
строк документации.
<!--l. 9559--><p class="indent" >   Первый аргумент <b>(setf documentation)</b> новая строка документации.
<!--l. 9561--><p class="indent" >   Второй аргумент <b><a 
href="symbols.html#x188-380352r352">documentation</a></b> может быть символом, именем функции
в виде <b>(setf <em>symbol</em>)</b>, объектом метода, объектом класса, объектом
обобщённой функции, объектом сочетания методов, объектом описания
                                                                          

                                                                          
слота. Должен ли третий необязательный аргумент быть указан зависит от
типа второго аргумента.
<!--l. 9566--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380352r352">documentation</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302038"></a>
<em>
<!--l. 9571--><p class="noindent" >[Функция]</em> <b>ensure-generic-function</b> <i>function-name</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;key</a></tt> <i>:lambda-list</i>
<i>:argument-precedence-order</i> <i>:declare</i> <i>:documentation</i> <i>:generic-function-class</i>
<i>:method-combination</i> <i>:method-class</i> <i>:environment</i>
</div>
<!--l. 9580--><p class="indent" >   <div class="tabbing">
<em>function-name</em> ::=  {<i><em>symbol</em> | <b>(setf <em>symbol</em>)</b></i>}
   <br>
<!--l. 9582--><p class="noindent" ></div>Функция <b><a 
href="symbols.html#x188-380376r376">ensure-generic-function</a></b> используется для определения глобальной
обобщённой функции без методов или для изменения параметров и
деклараций, которые применяются для глобальной обобщённой функции в
целом.
<!--l. 9587--><p class="indent" >   Если <b>(fboundp <em>function-name</em>)</b> равна <b><a 
href="symbols.html#x188-380670r670">nil</a></b>, создаётся новая обобщённая
функция. Если <b>(fdeﬁnition <em>function-name</em>)</b> является необобщённой
функцией, макросом или специальным оператором, сигнализируется
ошибка.
<!--l. 9591--><p class="indent" >   [X3J13 voted in March 1989 <a 
 id="dx176-302039"></a>to use <b><a 
href="symbols.html#x188-380398r398">fdeﬁnition</a></b> in the previous paragraph, as
shown, rather than <b><a 
href="symbols.html#x188-380943r943">symbol-function</a></b>, as it appeared in the original report on
CLOS <span class="cite">[<a 
href="bib.html#XSIGPLAN-CLOS">5</a>, <a 
href="bib.html#XLASC-CLOS-PART-2">7</a>]</span>. The vote also changed all occurrences of <em>function-speciﬁer</em> in the
original report to <em>function-name</em>; this change is reﬂected here.—GLS]
<!--l. 9597--><p class="indent" >   Если <em>function-name</em> указывает на обобщённую функцию и
значения: <b>:argument-precedence-order</b>, <b>:declare</b>, <b>:documentation</b>,
<b>:method-combination</b>, отличаются от старых значений функции, тогда она
модифицируется.
<!--l. 9602--><p class="indent" >   Если <em>function-name</em> указывает на обобщённую функцию и значение
<b>:lambda-list</b> отличается от старого, но при этом согласуется со
                                                                          

                                                                          
лямбда-списками всех методов (или если методы отсутствуют), тогда
устанавливается новое значение, иначе сигнализируется ошибка.
<!--l. 9607--><p class="indent" >   Если <em>function-name</em> указывает на обобщённую функцию и значение
<b>:generic-function-class</b> отличается от старого и если новая обобщённая
функция совместима со старой, тогда вызывается <b><a 
href="symbols.html#x188-380214r214">change-class</a></b> для
изменения её класса, иначе сигнализируется ошибка.
<!--l. 9612--><p class="indent" >   Если <em>function-name</em> указывает на обобщённую функцию и значение
<b>:method-class</b> отличается от старого, значение изменяется, но классы
существующих методов не изменяются.
<!--l. 9616--><p class="indent" >   Аргумент <em>function-name</em> является символом или списком вида <b>(setf
<em>symbol</em>)</b>.
<!--l. 9619--><p class="indent" >   Именованные параметры соответствуют аргументам <em>option</em> <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>, за
исключением того, что аргумента <b>:method-class</b> и <b>:generic-function-class</b>
могут быть как объектами класса, так и его именами.
<!--l. 9623--><p class="indent" >   Аргумент <b>:environment</b> такой же как аргумент <b>&#x0026;environment</b> для
функции раскрытия макросов. Обычно он используется для различия между
временем компиляции и временем выполнения.
<!--l. 9627--><p class="indent" >   Аргумент <b>:method-combination</b> является объектом сочетания
методов.
<!--l. 9629--><p class="indent" >   В качестве результата возвращает объект обобщённой функции.
<!--l. 9631--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302040"></a>
<em>
<!--l. 9635--><p class="noindent" >[Функция]</em> <b>ﬁnd-class</b> <i>symbol</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>errorp</i> <i>environment</i>
</div>
<!--l. 9637--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380415r415">ﬁnd-class</a></b> возвращает объект класса, на который указывает
заданный символ в заданном окружении.
<!--l. 9640--><p class="indent" >   Первый аргумент функции является символом.
<!--l. 9642--><p class="indent" >   Если объект класса не найден и аргумент <em>errorp</em> не задан или равен не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b>
значению, <b><a 
href="symbols.html#x188-380415r415">ﬁnd-class</a></b> сигнализирует ошибку. Если объект класса не найден и
аргумент <em>errorp</em> равен <b><a 
href="symbols.html#x188-380670r670">nil</a></b>, <b><a 
href="symbols.html#x188-380415r415">ﬁnd-class</a></b> возвращает <b><a 
href="symbols.html#x188-380670r670">nil</a></b>. По-умолчанию аргумент
<em>errorp</em> равен <b><a 
href="symbols.html#x188-380951r951">t</a></b>.
<!--l. 9648--><p class="indent" >   Результатом <b><a 
href="symbols.html#x188-380415r415">ﬁnd-class</a></b> является объект класса, который связан с
                                                                          

                                                                          
заданным символом.
<!--l. 9651--><p class="indent" >   Связь объекта класса и символа может быть изменена с помощью <b><a 
href="symbols.html#x188-380844r844">setf</a></b>
в связке с <b><a 
href="symbols.html#x188-380415r415">ﬁnd-class</a></b>. Если пользователь пытается изменить класс
ассоциированный с символом, который является спецификатором типа из
главы <a 
href="dtspec.html#x26-420004">4<!--tex4ht:ref: DTSPEC --></a>, то результат не определён. Смотрите раздел <a 
href="clmse143.html#x175-26400027.1.4">27.1.4<!--tex4ht:ref: Integrating-Types-and-Classes-SECTION --></a>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302041"></a>
<em>
<!--l. 9660--><p class="noindent" >[Обобщённая функция]</em> <b>ﬁnd-method</b> <i>generic-function</i> <i>method-qualiﬁers</i>
<i>specializers</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>errorp</i><br />
<a 
 id="dx176-302042"></a>
<em>
[Главный метод]</em> <b>ﬁnd-method</b> (<i>generic-function</i> standard-generic-function)
<i>method-qualiﬁers</i> <i>specializers</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>errorp</i>
</div>
<!--l. 9664--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380418r418">ﬁnd-method</a></b> принимает обобщённую функцию и
возвращает объект метода, который согласуется с квалификаторами
<em>method-qualiﬁers</em> и специализаторами параметров <em>specializers</em>. Смотрите
раздел <a 
href="clmse143.html#x175-27100027.1.6">27.1.6<!--tex4ht:ref: Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION --></a> для определения в данном контексте понятия согласования.
<!--l. 9670--><p class="indent" >   Аргумент <em>generic-function</em> должен быть обобщённой функцией.
<!--l. 9672--><p class="indent" >   Аргумент <em>method-qualiﬁers</em> является списком квалификаторов метода.
Порядок квалификаторов важен.
<!--l. 9675--><p class="indent" >   Аргумент <em>specializers</em> является списком специализаторов параметров. Он
должен содержать одинаковое количество обязательных аргументов, что и
обобщённая функция, иначе будет сигнализирована ошибка. Это означает,
что для получения метода по-умолчанию для данной обобщённой функции,
должен быть указан список, элементы которого являются классами с именем
<b><a 
href="symbols.html#x188-380951r951">t</a></b>.
<!--l. 9681--><p class="indent" >   Результатом <b><a 
href="symbols.html#x188-380418r418">ﬁnd-method</a></b> является объект метода, у которого заданные
квалификаторы и специализаторы параметров.
<!--l. 9684--><p class="indent" >   Смотрите раздел <a 
href="clmse143.html#x175-27100027.1.6">27.1.6<!--tex4ht:ref: Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION --></a>.
<hr></div>
<div class="defun">
                                                                          

                                                                          
<div class="defunheader">
<a 
 id="dx176-302043"></a>
<em>
<!--l. 9689--><p class="noindent" >[Обобщённая функция]</em> <b>function-keywords</b> <i>method</i><br />
<a 
 id="dx176-302044"></a>
<em>
[Главный метод]</em> <b>function-keywords</b> (<i>method</i> standard-method)
</div>
<!--l. 9692--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380448r448">function-keywords</a></b> используется для получения
спецификаторов именованных параметров для заданного метода.
<!--l. 9695--><p class="indent" >   Аргумент <em>method</em> должен быть объектом метода.
<!--l. 9697--><p class="indent" >   Обобщённая функция возвращает два значение: список явно определённых
именованных параметров, и булево значение, которое обозначает содержит
ли определение метода <b>&#x0026;allow-other-keys</b>.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 9703--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>generic-function</b> <a 
 id="dx176-302045"></a>lambda-list [[<span class="math"> ↓</span>option | {method-description}*]]
   <br>
<!--l. 9704--><p class="noindent" ></div>
</div>
<!--l. 9705--><p class="indent" >   <div class="tabbing">
<em>option</em> ::= <b>(:argument-precedence-order  {<i>parameter-name</i>}+ )</b>
   <br>      | <b>(declare  {<i>declaration</i>}+ )</b><br>      | <b>(:documentation <em>string</em>)</b><br>
    | <b>(:method-combination <em>symbol</em> {<i>arg</i>}* )</b><br>
    | <b>(:generic-function-class <em>class-name</em>)</b><br>
    | <b>(:method-class <em>class-name</em>)</b><br>                                      <br>
<em>method-description</em> ::= <b>(:method </b> {<i>method-qualiﬁer</i>}*  <em>specialized-lambda-list</em> {<i>declaration | documentation</i>}*  {<i>form</i>}* <b>)</b><br>
<!--l. 9716--><p class="noindent" ></div>Макрос <b><a 
href="symbols.html#x188-380452r452">generic-function</a></b> создаёт анонимную обобщённую функцию.
Обобщённая функция создаётся с набором методов, заданных в части
описания методов.
                                                                          

                                                                          
<!--l. 9720--><p class="indent" >   Аргументы <em>option</em>, <em>method-qualiﬁer</em> и <em>specialized-lambda-lisp</em> значат то же,
что и в <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b>.
<!--l. 9723--><p class="indent" >   В качестве результата возвращается объект обобщённой функции.
<!--l. 9725--><p class="indent" >   Если часть описания методов не указана, то обобщённая функция
создаётся без методов.
<!--l. 9728--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380312r312">defgeneric</a></b> и <b><a 
href="symbols.html#x188-380321r321">defmethod</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302046"></a>
<em>
<!--l. 9733--><p class="noindent" >[Обобщённая функция]</em> <b>initialize-instance</b> <i>instance</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>initargs</i><br />
<a 
 id="dx176-302047"></a>
<em>
[Главный метод]</em> <b>initialize-instance</b> (<i>instance</i> standard-object) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt>
<i>initargs</i>
</div>
<!--l. 9736--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b> вызывается в функции
<b><a 
href="symbols.html#x188-380595r595">make-instance</a></b> для инициализации создаваемого экземпляра объекта.
Обобщённая функция <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b> применяется к экземпляру класса и
инициализационным аргументам.
<!--l. 9741--><p class="indent" >   Системный главный метод <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b> инициализирует слоты
экземпляра объекта со значениями в соответствие с инициализационными
аргументами и формами слотов <b>:initform</b>. Он производит это с помощью
вызова обобщённой функции <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b> со следующими аргументами:
экземпляр класса, <b><a 
href="symbols.html#x188-380951r951">t</a></b> (это указывает на то, что все слоты, для которых не
указаны инициализационные аргументы, должны быть инициализированы в
соотвествие с их формами <b>:initform</b> и инициализационные аргументы.
<!--l. 9750--><p class="indent" >   Аргумент <em>instance</em> является объектом, который будет инициализирован.
<!--l. 9752--><p class="indent" >   Аргумент <em>initargs</em> состоит из чередующихся имён инициализационных
аргументов и их значений.
<!--l. 9755--><p class="indent" >   В качестве результата возвращается модифицированный экземпляр
класса.
<!--l. 9757--><p class="indent" >   Программисты могут определять методы <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b> для указания
дополнительных действий при инициализации экземпляра класса. Если
определены только <b>:after</b> методы, они будут вызваны после системного
                                                                          

                                                                          
главного метода инициализации и таким образом не будут изменять
поведение по-умолчанию <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b>.
<!--l. 9763--><p class="indent" >   Смотрите разделы <a 
href="clmse143.html#x175-28300027.1.9">27.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>, <a 
href="clmse143.html#x175-28700027.1.9">27.1.9<!--tex4ht:ref: Rules-for-Initialization-Arguments-SECTION --></a> и <a 
href="clmse143.html#x175-28500027.1.9">27.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>.
<!--l. 9767--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b>, <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>, <b><a 
href="symbols.html#x188-380871r871">slot-boundp</a></b> и
<b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302048"></a>
<em>
<!--l. 9774--><p class="noindent" >[Функция]</em> <b>invalid-method-error</b> <i>method</i> <i>format-string</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>args</i>
</div>
<!--l. 9776--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380508r508">invalid-method-error</a></b> используется для сигнализирования
ошибки, в тех случаях, когда у применяемого метода некорректные
квалификаторы для типа сочетания методов. Сообщение об ошибке
составляется с помощью форматирующей строки и любого количества
аргументов к ней. Так как реализации может быть необходимо добавить
дополнительную контекстную информацию в сообщение об ошибке,
<b><a 
href="symbols.html#x188-380508r508">invalid-method-error</a></b> должна вызываться только внутри динамической
продолжительности видимости функции сочетания методов.
<!--l. 9784--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380508r508">invalid-method-error</a></b> вызывается автоматически, когда
метод не удовлетворяет всем шаблонам квалификаторов и предикату в
форме <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>. Функция сочетания методов,
которая налагает дополнительные ограничения, должна явно вызывать
<b><a 
href="symbols.html#x188-380508r508">invalid-method-error</a></b>, если столкнулась с методом, который она не может
принять.
<!--l. 9791--><p class="indent" >   Аргумент <em>method</em> является объектом некорректного метода.
<!--l. 9793--><p class="indent" >   Аргумент <em>format-string</em> является форматирующей строкой, которая может
передаваться в <b><a 
href="symbols.html#x188-380438r438">format</a></b>, и <em>args</em> является любыми аргументами, необходимыми
данной строке.
<!--l. 9797--><p class="indent" >   Возвращает ли <b><a 
href="symbols.html#x188-380508r508">invalid-method-error</a></b> управление или завершается с
помощью <b><a 
href="symbols.html#x188-380961r961">throw</a></b> зависит от реализации.
<!--l. 9800--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b> .
<hr></div>
<div class="defun">
                                                                          

                                                                          
<div class="defunheader">
<a 
 id="dx176-302049"></a>
<em>
<!--l. 9804--><p class="noindent" >[Обобщённая функция]</em> <b>make-instance</b> <i>class</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>initargs</i><br />
<a 
 id="dx176-302050"></a>
<em>
[Главный метод]</em> <b>make-instance</b> (<i>class</i> standard-class) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>initargs</i><br />
<a 
 id="dx176-302051"></a>
<em>
[Главный метод]</em> <b>make-instance</b> (<i>class</i> symbol) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>initargs</i>
</div>
<!--l. 9808--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b> создаёт новый экземпляр заданного
класса.
<!--l. 9810--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b> может использоваться, как это
описано в разделе <a 
href="clmse143.html#x175-28300027.1.9">27.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<!--l. 9813--><p class="indent" >   Аргумент <em>class</em> является объектом класса или символом, который на него
указывает. Остальные аргументы формируют список из чередующихся имён
инициализационных аргументов и их значений.
<!--l. 9817--><p class="indent" >   Если из вышеуказанного списка выбран второй метод, то он вызывает
<b><a 
href="symbols.html#x188-380595r595">make-instance</a></b> с аргументами <b>(ﬁnd-class <em>class</em>)</b> и <em>initargs</em>.
<!--l. 9821--><p class="indent" >   Инициализационные аргументы проверяются внутри <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>.
Смотрите раздел <a 
href="clmse143.html#x175-28300027.1.9">27.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<!--l. 9824--><p class="indent" >   В качестве результата возвращается созданный экземпляр класса.
<!--l. 9826--><p class="indent" >   Для определения новых методов для функции <b><a 
href="symbols.html#x188-380595r595">make-instance</a></b>
и соответственно изменения протокола создания объектом может
использоваться метаобъектный протокол.
<!--l. 9830--><p class="indent" >   Смотрите раздел <a 
href="clmse143.html#x175-28300027.1.9">27.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<!--l. 9832--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>, <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b> и <b><a 
href="symbols.html#x188-380245r245">class-of</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302052"></a>
<em>
<!--l. 9836--><p class="noindent" >[Обобщённая функция]</em> <b>make-instances-obsolete</b> <i>class</i><br />
<a 
 id="dx176-302053"></a>
<em>
                                                                          

                                                                          
[Главный метод]</em> <b>make-instances-obsolete</b> (<i>class</i> standard-class)<br />
<a 
 id="dx176-302054"></a>
<em>
[Главный метод]</em> <b>make-instances-obsolete</b> (<i>class</i> symbol)
</div>
<!--l. 9840--><p class="indent" >   Обобщённая функция <b>make-instance-obsolete</b> вызывается системой
автоматически, когда используется <b><a 
href="symbols.html#x188-380310r310">defclass</a></b> для переопределения
существующего стандартного класса и изменяется набор или порядок
локальных слотов. Также и пользователь может её вызывать явно.
<!--l. 9845--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380596r596">make-instances-obsolete</a></b> начинает процесс процесс обновления
экземпляров класса. В процессе обновления будет вызвана обобщённая
функция <b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b>.
<!--l. 9849--><p class="indent" >   Аргумент <em>class</em> является объектом класса или символом, который
на него указывает. Экземпляры данного класса обозначаются как
устаревшие.
<!--l. 9852--><p class="indent" >   Если из вышеуказанного списка выбран второй метод, то он вызывает
<b><a 
href="symbols.html#x188-380596r596">make-instances-obsolete</a></b> с аргументом <b>(ﬁnd-class <em>class</em>)</b>.
<!--l. 9855--><p class="indent" >   Результатом является модифицированный класс. Результат
<b><a 
href="symbols.html#x188-380596r596">make-instances-obsolete</a></b> равен <b><a 
href="symbols.html#x188-380378r378">eq</a></b> аргументу <em>class</em>.
<!--l. 9858--><p class="indent" >   Смотрите раздел ??.
<!--l. 9860--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302055"></a>
<em>
<!--l. 9864--><p class="noindent" >[Функция]</em> <b>method-combination-error</b> <i>format-string</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>args</i>
</div>
<!--l. 9866--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380632r632">method-combination-error</a></b> используется для сигнализирования
ошибки в сочетании методов. Сообщение об ошибке составляется с помощью
форматирующей строки и любого количества аргументов к ней. Так как
реализации может быть необходимо добавить дополнительную контекстную
информацию в сообщение об ошибке, <b>method-error</b> должна вызываться
только внутри динамической продолжительности видимости функции
сочетания методов.
                                                                          

                                                                          
<!--l. 9873--><p class="indent" >   Аргумент <em>format-string</em> является форматирующей строкой, которая может
передаваться в <b><a 
href="symbols.html#x188-380438r438">format</a></b>, и <em>args</em> является любыми аргументами, необходимыми
данной строке.
<!--l. 9877--><p class="indent" >   Возвращает ли <b><a 
href="symbols.html#x188-380632r632">method-combination-error</a></b> управление или завершается
с помощью <b><a 
href="symbols.html#x188-380961r961">throw</a></b> зависит от реализации.
<!--l. 9880--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302056"></a>
<em>
<!--l. 9884--><p class="noindent" >[Обобщённая функция]</em> <b>method-qualiﬁers</b> <i>method</i><br />
<a 
 id="dx176-302057"></a>
<em>
[Главный метод]</em> <b>method-qualiﬁers</b> (<i>method</i> standard-method)
</div>
<!--l. 9887--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380636r636">method-qualiﬁers</a></b> возвращает список
квалификаторов заданного метода.
<!--l. 9890--><p class="indent" >   Аргумент <em>method</em> является объектом метода.
<!--l. 9892--><p class="indent" >   В качестве результата возвращается список квалификаторов метода.
<!--l. 9894--><p class="indent" >   Например: <div class="lisp"><tt><div class="tabbing">
(setq methods (remove-duplicates methods
   <br>                                                             :from-end t<br>
                                 :key #&#x2019;method-qualiﬁers<br>
                                 :test #&#x2019;equal))<br>
<!--l. 9900--><p class="noindent" ></div>
</tt>
</div>
<!--l. 9902--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380316r316">deﬁne-method-combination</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
                                                                          

                                                                          
<a 
 id="dx176-302058"></a>
<em>
<!--l. 9906--><p class="noindent" >[Функция]</em> <b>next-method-p</b>
</div>
<!--l. 9908--><p class="indent" >   Локально определённая функция <b><a 
href="symbols.html#x188-380669r669">next-method-p</a></b> может использоваться
внутри тела метода для определения того, существует ли следующий
метод.
<!--l. 9911--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380669r669">next-method-p</a></b> не принимает аргументов.
<!--l. 9913--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380669r669">next-method-p</a></b> возвращает или истину, или ложь.
<!--l. 9915--><p class="indent" >   Также как и <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>, функция <b><a 
href="symbols.html#x188-380669r669">next-method-p</a></b> имеет
лексическую область видимости (определена только для тела метода) и
неограниченную продолжительность видимости.
<!--l. 9919--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302059"></a>
<em>
<!--l. 9923--><p class="noindent" >[Обобщённая функция]</em> <b>no-applicable-method</b> <i>generic-function</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt>
<i>function-arguments</i><br />
<a 
 id="dx176-302060"></a>
<em>
[Главный метод]</em> <b>no-applicable-method</b> (<i>generic-function</i> t) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt>
<i>function-arguments</i>
</div>
<!--l. 9926--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380673r673">no-applicable-method</a></b> вызывается, когда
обобщённая функция класса <b>standard-generic-function</b> вызывается и не
находит не одного применимого метода. По-умолчанию главный метод
сигнализирует ошибку.
<!--l. 9930--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380673r673">no-applicable-method</a></b> не предназначена для
вызова программистом. Программисты могут писать методы для
неё.
<!--l. 9933--><p class="indent" >   Аргумент <em>generic-function</em> является объектом обобщённой функции, в
которой не нашлось применимого метода.
<!--l. 9936--><p class="indent" >   Аргумент <em>function-arguments</em> является списком аргументов, которые были
переданы в эту функцию.
                                                                          

                                                                          
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302061"></a>
<em>
<!--l. 9941--><p class="noindent" >[Обобщённая функция]</em> <b>no-next-method</b> <i>generic-function</i> <i>method</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt>
<i>args</i><br />
<a 
 id="dx176-302062"></a>
<em>
[Главный метод]</em> <b>no-next-method</b> (<i>generic-function</i> standard-generic-function)
(<i>method</i> standard-method) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>args</i>
</div>
<!--l. 9945--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380674r674">no-next-method</a></b> вызывается функцией
<b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>, когда не было обнаружено последующих методов для
вызова. Системный метод для этой функции сигнализирует ошибку.
<!--l. 9949--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380674r674">no-next-method</a></b> не предназначена для
вызова программистом. Программисты могут писать методы для
неё.
<!--l. 9952--><p class="indent" >   Аргумент <em>generic-function</em> является объектом обобщённой функции, в
которой не нашлось последующего метода.
<!--l. 9955--><p class="indent" >   Аргумент <em>method</em> является объектом метода, в котором не нашлось
последующего метода.
<!--l. 9958--><p class="indent" >   Аргумент <em>args</em> является списком аргументов, которые были переданы в
функцию <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>.
<!--l. 9961--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380190r190">call-next-method</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302063"></a>
<em>
<!--l. 9966--><p class="noindent" >[Обобщённая функция]</em> <b>print-object</b> <i>object</i> <i>stream</i><br />
<a 
 id="dx176-302064"></a>
<em>
[Главный метод]</em> <b>print-object</b> (<i>object</i> standard-object) <i>stream</i>
                                                                          

                                                                          
</div>
<!--l. 9969--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380751r751">print-object</a></b> выводит в поток текстовое
представление объекта. Функция <b><a 
href="symbols.html#x188-380751r751">print-object</a></b> вызывается с помощью
системы вывода. Она не должна вызываться пользователем.
<!--l. 9973--><p class="indent" >   Каждая реализация должно предоставлять метод для класса
<b>standard-object</b> и методы для других классов. Пользователь может
написать методы для <b><a 
href="symbols.html#x188-380751r751">print-object</a></b> для своих класса, если он не хочет
наследовать системный методы вывода.
<!--l. 9978--><p class="indent" >   Первый аргумент — любой Lisp&#x2019;овый объект. Второй аргумент является
потоком, и не может быть <b><a 
href="symbols.html#x188-380951r951">t</a></b> или <b><a 
href="symbols.html#x188-380670r670">nil</a></b>.
<!--l. 9981--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380751r751">print-object</a></b> в качестве результата возвращает первый
аргумент, а, именно, объект.
<!--l. 9984--><p class="indent" >   Методы <b><a 
href="symbols.html#x188-380751r751">print-object</a></b> должны подчиняться специальным переменным
управления вывода <b>*print-<em>xxx</em>*</b> для различных <em>xxx</em>. Далее перечислены
конкретные детали:
      <ul class="itemize1">
      <li class="itemize">Каждый метод должен реализовывать <b><a 
href="symbols.html#x188-380037r37">*print-escape*</a></b>.
      </li>
      <li class="itemize">Переменная <b><a 
href="symbols.html#x188-380044r44">*print-pretty*</a></b> может быть проигнорировать в всех
      методах, кроме метода для списка.
      </li>
      <li class="itemize">Переменная  <b><a 
href="symbols.html#x188-380036r36">*print-circle*</a></b>  обрабатывается  системой  вывода  и
      может быть проигнорирована методами.
      </li>
      <li class="itemize">Система вывода автоматически обрабатывает <b><a 
href="symbols.html#x188-380040r40">*print-level*</a></b>, таким
      образом  методы  работают  только  с  одним  уровнем,  рекурсивно
      вызывая функцию <b><a 
href="symbols.html#x188-381025r1025">write</a></b> (или эквивалентную), если необходимо
      вывести  дополнительные  уровни  с  объектами.  Решение  системы
      вывода   содержит   ли   объект   компоненты   (и   таким   образом
      не   должен   выводится   при   значении   <b><a 
href="symbols.html#x188-380040r40">*print-level*</a></b>  меньшем
      чем  глубина  его  вывода)  зависит  от  реализации.  В  некоторых
      реализациях   метода   объекта   <b><a 
href="symbols.html#x188-380751r751">print-object</a></b>  не   вызывается,   в
      некоторых  вызывается  и  на  основе  вывода  метода  строится
      предположение о структуре объекта.
                                                                          

                                                                          
      </li>
      <li class="itemize">Методы,  которые  могут  выводить  объекты  бесконечной  длины,
      должны  подчиняться  <b><a 
href="symbols.html#x188-380039r39">*print-length*</a></b>,  но  большинство  методов,
      кроме   того,   что   для   списка,   могут   игнорировать   данную
      переменную.
      </li>
      <li class="itemize">Переменные                  <b><a 
href="symbols.html#x188-380034r34">*print-base*</a></b>,                  <b><a 
href="symbols.html#x188-380045r45">*print-radix*</a></b>,
      <b><a 
href="symbols.html#x188-380035r35">*print-case*</a></b>, <b><a 
href="symbols.html#x188-380038r38">*print-gensym*</a></b> и <b><a 
href="symbols.html#x188-380033r33">*print-array*</a></b> применяются для
      конкретных типов и должны обрабатываться соответствующими
      методами.
      </li>
      <li class="itemize">X3J13 voted in June 1989 <a 
 id="dx176-302065"></a>to add the following point. All methods for
      <b><a 
href="symbols.html#x188-380751r751">print-object</a></b> must obey <b>*print-readably*</b>, which takes precedence
      over all other printer control variables. This includes both user-deﬁned
      methods and implementation-deﬁned methods.</li></ul>
<!--l. 10025--><p class="indent" >   Если эти правила не соблюдаются, результат непредсказуем.
<!--l. 10027--><p class="indent" >   В целом, система вывода и методы <b><a 
href="symbols.html#x188-380751r751">print-object</a></b> не должны пересвязывать
переменные, управляющие выводом, так как они обрабатываются рекурсивно
вместе со структурой объекта, но это зависит от реализации.
<!--l. 10031--><p class="indent" >   В некоторых реализациях аргумент потока, передаваемого в <b><a 
href="symbols.html#x188-380751r751">print-object</a></b>,
не является оригинальным потоком, а специальным, который используется
системой вывода. Таким образом методы не должны зависеть от сущности
этого потока.
<!--l. 10035--><p class="indent" >   Все существующие функции вывода (<b><a 
href="symbols.html#x188-381025r1025">write</a></b>, <b>prin1</b>, <b><a 
href="symbols.html#x188-380750r750">print</a></b>, <b><a 
href="symbols.html#x188-380748r748">princ</a></b>, <b><a 
href="symbols.html#x188-380735r735">pprint</a></b>,
<b><a 
href="symbols.html#x188-381031r1031">write-to-string</a></b>, <b>prin1-to-string</b>, <b><a 
href="symbols.html#x188-380749r749">princ-to-string</a></b>, the <b>~S</b> and <b>~A</b> <b><a 
href="symbols.html#x188-380438r438">format</a></b>
operations, and the <b>~B</b>, <b>~D</b>, <b>~E</b>, <b>~F</b>, <b>~G</b>, <b>~$</b>, <b>~O</b>, <b>~R</b>, and <b>~X</b> <b><a 
href="symbols.html#x188-380438r438">format</a></b>
операции, когда они указаны для нечислового значения) должны
использовать обобщённую функцию <b><a 
href="symbols.html#x188-380751r751">print-object</a></b>. Все реализации должны
выводить объекты с помощью методов <b><a 
href="symbols.html#x188-380751r751">print-object</a></b>. Так как некоторые
классы могут не иметь метода для вывода, реализация может определить
один метод по-умолчанию, который унаследуется всеми системными
классами.
<hr></div>
<div class="defun">
<div class="defunheader">
                                                                          

                                                                          
<a 
 id="dx176-302066"></a>
<em>
<!--l. 10049--><p class="noindent" >[Обобщённая функция]</em> <b>reinitialize-instance</b> <i>instance</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>initargs</i><br />
<a 
 id="dx176-302067"></a>
<em>
[Главный метод]</em> <b>reinitialize-instance</b> (<i>instance</i> standard-object) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt>
<i>initargs</i>
</div>
<!--l. 10052--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380794r794">reinitialize-instance</a></b> может использоваться для
изменения значений локальных слотов в соотвествие с инициализационными
аргументами. Эта обобщённая функция вызывается метаобъектным
протоколом, однако может быть вызвана также и пользователем.
<!--l. 10057--><p class="indent" >   Системный главный метод для <b><a 
href="symbols.html#x188-380794r794">reinitialize-instance</a></b> проверяет
корректность инициализационных аргументов и сигнализирует ошибку, в
случае некорректности какого-либо из них. Затем метод вызывает
обобщённую функцию <b>shared-instance</b> со следующими аргументами:
экземпляр, <b><a 
href="symbols.html#x188-380670r670">nil</a></b> (который означает, что ни один слот не должен быть
инициализирован в соответствие с формами <b>:initform</b>) и полученные
инициализационные аргументы.
<!--l. 10064--><p class="indent" >   Аргумент <em>instance</em> является объектом, который инициализируется.
<!--l. 10066--><p class="indent" >   Аргумент <em>initargs</em> состоит из чередующихся имён инициализационных
аргументов и их значений.
<!--l. 10069--><p class="indent" >   В качестве результата возвращается модифицированный экземпляр
объекта.
<!--l. 10071--><p class="indent" >   Инициализационные аргументы декларируются в параметре <b>:initarg</b> в
<b><a 
href="symbols.html#x188-380310r310">defclass</a></b> или в определении метода для <b><a 
href="symbols.html#x188-380794r794">reinitialize-instance</a></b> или
<b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b>. Имя параметра для каждого спецификаторы именованного
параметра в лямбда-списке любого метода для <b><a 
href="symbols.html#x188-380794r794">reinitialize-instance</a></b> или
<b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b> является корректным именем инициализационного
аргумента для всех классов, для которых применим данный метод.
<!--l. 10078--><p class="indent" >   Смотрите разделы <a 
href="clmse143.html#x175-30000027.1.12">27.1.12<!--tex4ht:ref: Reinitializing-an-Instance-SECTION --></a>, <a 
href="clmse143.html#x175-28700027.1.9">27.1.9<!--tex4ht:ref: Rules-for-Initialization-Arguments-SECTION --></a>, <a 
href="clmse143.html#x175-28500027.1.9">27.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>.
<!--l. 10082--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b>, <b><a 
href="symbols.html#x188-380871r871">slot-boundp</a></b>, <b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b>,
<b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b>, <b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b> и <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
                                                                          

                                                                          
<a 
 id="dx176-302068"></a>
<em>
<!--l. 10090--><p class="noindent" >[Обобщённая функция]</em> <b>remove-method</b> <i>generic-function</i> <i>method</i><br />
<a 
 id="dx176-302069"></a>
<em>
[Главный метод]</em> <b>remove-method</b> (<i>generic-function</i> standard-generic-function)
<i>method</i>
</div>
<!--l. 10093--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380805r805">remove-method</a></b> удаляет метод из обобщённой
функции. Функция деструктивно модифицирует указанную обобщённую
функцию и возвращает её в качестве результата.
<!--l. 10097--><p class="indent" >   Аргумент <em>generic-function</em> является объектом обобщённой функции.
<!--l. 10099--><p class="indent" >   Аргумент <em>method</em> является объектом метода. Функция <b><a 
href="symbols.html#x188-380805r805">remove-method</a></b>
не сигнализирует ошибку, если метод не принадлежит обобщённой
функции.
<!--l. 10102--><p class="indent" >   Результатом является объект обобщённой функции. Результат
<b><a 
href="symbols.html#x188-380805r805">remove-method</a></b> равен <b><a 
href="symbols.html#x188-380378r378">eq</a></b> аргументу <em>generic-function</em>.
<!--l. 10105--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380418r418">ﬁnd-method</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302070"></a>
<em>
<!--l. 10109--><p class="noindent" >[Обобщённая функция]</em> <b>shared-initialize</b> <i>instance</i> <i>slot-names</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt>
<i>initargs</i><br />
<a 
 id="dx176-302071"></a>
<em>
[Главный метод]</em> <b>shared-initialize</b> (<i>instance</i> standard-object) <i>slot-names</i>
<tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>initargs</i>
</div>
<!--l. 10112--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b> используется для заполнения слотов
экземпляра класса с помощью инициализационных аргументов и форм
<b>:initform</b>. Она вызывается при создании экземпляра, при переинициализации
экземпляра, при обновлении экземпляра до переопределённого класса,
при обновлении экземпляра до другого класса. Обобщённая функция
<b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b> вызывается системными главными методами
                                                                          

                                                                          
<b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b>, <b><a 
href="symbols.html#x188-380794r794">reinitialize-instance</a></b>, <b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b>
и <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b>.
<!--l. 10122--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b> принимает следующие
аргументы: экземпляр класса для инициализации, спецификацию множества
имён слотов, доступных в данном экземпляре, и любое количество
инициализационных аргументов. Аргументы после первых двух, должны
формировать список инициализационных аргументов. Системный
главный метод <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b> инициализирует слоты значениями в
соотвествие с инициализационными аргументами и указанными формами
<b>:initform</b>. Второй аргумент указывает, какие слоты должны быть
инициализированы в соотвествие с их формами <b>:initform</b>, если для них не
были инициализационные аргументы.
<!--l. 10132--><p class="indent" >   Системный главный метод ведёт себя так, как сказано ниже вне
зависимости от того, является ли слот локальным или разделяемым:
      <ul class="itemize1">
      <li class="itemize">Если инициализационный аргумент в списке указывает значение
      для такого слота, тогда значение сохраняется в слоте, даже если
      значение уже было до запуска метода в нем сохранено.
      </li>
      <li class="itemize">Любые   слоты,   указанные   во   втором   аргументе,   и   которые
      до   сих   пор   не   были   связаны   с   какими-либо   значениями,
      инициализируются в соответствие с их формами <b>:initform</b>. Для
      любых   таких   слотов,   которые   имеют   форму   <b>:initform</b>,   эта
      форма  выполняется  в  таком  же  лексическом  окружении,  что  и
      выполнялась формы <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>, и её значение сохраняется в слоте.
      Например, если <b>:before</b> метод сохраняет значение в слот, форма
      <b>:initform</b> использоваться не будет.
      </li>
      <li class="itemize">А также правила, упомянутые в разделе <a 
href="clmse143.html#x175-28700027.1.9">27.1.9<!--tex4ht:ref: Rules-for-Initialization-Arguments-SECTION --></a>.</li></ul>
<!--l. 10151--><p class="indent" >   Аргумент <em>instance</em> является объектом, для которого производится
инициализация.
<!--l. 10153--><p class="indent" >   Аргумент <em>slot-name</em> указывает слоты, которые будут инициализированы в
соотвествие с их формами <b>:initform</b>, если не были указаны инициализационные
аргументы. Он может передаваться в трёх разных формах:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">Он может быть списком имён слотов.
      </li>
      <li class="itemize">Он может быть символом <b><a 
href="symbols.html#x188-380670r670">nil</a></b>, что означает пустой список имён
      слотов.
      </li>
      <li class="itemize">Он может быть символом <b><a 
href="symbols.html#x188-380951r951">t</a></b>, который означает список всех слотов.</li></ul>
<!--l. 10166--><p class="indent" >   Аргумент <em>initargs</em> состоит из чередующихся имён инициализационных
аргументов и их значений.
<!--l. 10169--><p class="indent" >   В качестве результата возвращается модифицированный экземпляр
объекта.
<!--l. 10171--><p class="indent" >   Инициализационные аргументы корректны, если были указаны в
параметре <b>:initarg</b> <b><a 
href="symbols.html#x188-380310r310">defclass</a></b>, или в методе для функции <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b>.
<!--l. 10174--><p class="indent" >   Implementations are permitted to optimize <b>:initform</b> forms that neither
produce nor depend on side eﬀects by evaluating these forms and storing them
into slots before running any <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b> methods, rather than by
handling them in the primary <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b> method. (This optimization
might be implemented by having the <b><a 
href="symbols.html#x188-380094r94">allocate-instance</a></b> method copy a prototype
instance.)
<!--l. 10182--><p class="indent" >   Implementations are permitted to optimize default initial value forms for
initialization arguments associated with slots by not actually creating the
complete initialization argument list when the only method that would receive the
complete list is the method on <b>standard-object</b>. In this case, default initial value
forms can be treated like <b>:initform</b> forms. This optimization has no visible eﬀects
other than a performance improvement.
<!--l. 10190--><p class="indent" >   Смотрите разделы <a 
href="clmse143.html#x175-28300027.1.9">27.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>, <a 
href="clmse143.html#x175-28700027.1.9">27.1.9<!--tex4ht:ref: Rules-for-Initialization-Arguments-SECTION --></a>, <a 
href="clmse143.html#x175-28500027.1.9">27.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>.
<!--l. 10194--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b>, <b><a 
href="symbols.html#x188-380794r794">reinitialize-instance</a></b>,
<b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b>, <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b>,
<b><a 
href="symbols.html#x188-380871r871">slot-boundp</a></b> и <b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302072"></a>
<em>
                                                                          

                                                                          
<!--l. 10203--><p class="noindent" >[Функция]</em> <b>slot-boundp</b> <i>instance</i> <i>slot-name</i>
</div>
<!--l. 10205--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380871r871">slot-boundp</a></b> проверяет связан ли данный слот в экземпляре
класса с каким-либо значением.
<!--l. 10208--><p class="indent" >   Аргумент <em>instance</em> является любым объектом. Аргумент <em>slot-name</em>
являются символом.
<!--l. 10211--><p class="indent" >   Эта функция позволяет записывать <b>:after</b> методы для <b><a 
href="symbols.html#x188-380495r495">initialize-instance</a></b>
для инициализации только тех слотов, которые ещё не были связаны.
<!--l. 10215--><p class="indent" >   Если указанного слота в данном экземпляре не существует, вызывается
<b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> как показано ниже: <div class="lisp"><tt><div class="tabbing">
(slot-missing (class-of <em>instance</em>)
   <br>                            <em>instance</em><br>                           <em>slot-name</em><br>
              &#x2019;slot-makunbound)<br>
<!--l. 10222--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10224--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380871r871">slot-boundp</a></b> реализована с помощью <b><a 
href="symbols.html#x188-380872r872">slot-boundp-using-class</a></b>
<!--l. 10226--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302073"></a>
<em>
<!--l. 10231--><p class="noindent" >[Функция]</em> <b>slot-exists-p</b> <i>object</i> <i>slot-name</i>
</div>
<!--l. 10233--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380882r882">slot-exists-p</a></b> проверяет имеется ли данный слот в экземпляре
класса.
<!--l. 10236--><p class="indent" >   Аргумент <em>object</em> является любым объектом. Аргумент <em>slot-name</em> являются
символом.
<!--l. 10239--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380882r882">slot-exists-p</a></b> возвращает истину или ложь.
<!--l. 10241--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380882r882">slot-exists-p</a></b> реализована с помощью <b>slot-exists-p-using-class</b>
<hr></div>
                                                                          

                                                                          
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302074"></a>
<em>
<!--l. 10246--><p class="noindent" >[Функция]</em> <b>slot-makunbound</b> <i>instance</i> <i>slot-name</i>
</div>
<!--l. 10248--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b> устанавливает слот экземпляра <em>instance</em> в
несвязанное состояние.
<!--l. 10251--><p class="indent" >   Аргументами <b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b> являются: экземпляр и имя слота.
<!--l. 10253--><p class="indent" >   В качестве результата возвращает экземпляр класса.
<!--l. 10255--><p class="indent" >   Если указанного слота в данном экземпляре не существует, вызывается
<b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> как показано ниже: <div class="lisp"><tt><div class="tabbing">
(slot-missing (class-of <em>instance</em>)
   <br>                            <em>instance</em><br>                           <em>slot-name</em><br>
              &#x2019;slot-makunbound)<br>
<!--l. 10262--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10264--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b> реализована с помощью
<b><a 
href="symbols.html#x188-380884r884">slot-makunbound-using-class</a></b>. Смотрите <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302075"></a>
<em>
<!--l. 10270--><p class="noindent" >[Обобщённая функция]</em> <b>slot-missing</b> <i>class</i> <i>object</i> <i>slot-name</i> <i>operation</i>
<tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>new-value</i><br />
<a 
 id="dx176-302076"></a>
<em>
[Главный метод]</em> <b>slot-missing</b> (<i>class</i> t) <i>object</i> <i>slot-name</i> <i>operation</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt>
<i>new-value</i>
                                                                          

                                                                          
</div>
<!--l. 10273--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> вызывается, когда происходит
попытка доступа к слоту экземпляра класса, метакласс которого равен
<b>standard-class</b>, и этот слот отсутствует в данном экземпляре. Метод
по-умолчанию сигнализирует ошибку.
<!--l. 10278--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> не предназначения для вызова самим
программистом. Программист может написать метод для неё.
<!--l. 10281--><p class="indent" >   Аргументами <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> являются: класс экземпляра, к слоту которого
происходил доступ, сам экземпляр и имя слота и символ, который означает
операцию при котором произошёл вызов <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b>. Необязательный
аргумент <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> используется тогда, когда операцией являлась
попытка установки значения в слот.
<!--l. 10287--><p class="indent" >   Аргументами <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> являются: класс экземпляра, к слоту которого
происходил доступ, сам экземпляр и имя слота.
<!--l. 10290--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> может быть вызвана в процессе
вычисления <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b>, <b>(setf slot-value)</b>, <b><a 
href="symbols.html#x188-380871r871">slot-boundp</a></b> и <b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b>.
Для каждой из этих операций для аргумента <em>operation</em> соответствуют
символы <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b>, <b><a 
href="symbols.html#x188-380844r844">setf</a></b>, <b><a 
href="symbols.html#x188-380871r871">slot-boundp</a></b> и <b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b>.
<!--l. 10296--><p class="indent" >   Набор аргументов (в том числе класса экземпляра) облегчает определении
методов метакласса для <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302077"></a>
<em>
<!--l. 10302--><p class="noindent" >[Обобщённая функция]</em> <b>slot-unbound</b> <i>class</i> <i>instance</i> <i>slot-name</i><br />
<a 
 id="dx176-302078"></a>
<em>
[Главный метод]</em> <b>slot-unbound</b> (<i>class</i> t) <i>instance</i> <i>slot-name</i>
</div>
<!--l. 10305--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380886r886">slot-unbound</a></b> вызывается, когда происходит
попытка чтения несвязанного слота экземпляра класса, метакласс
которого равен <b>standard-class</b>. Метод по-умолчанию сигнализирует
ошибку.
<!--l. 10310--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380886r886">slot-unbound</a></b> не предназначения для вызова самим
программистом. Программист может написать метод для неё. Функция
                                                                          

                                                                          
<b><a 
href="symbols.html#x188-380886r886">slot-unbound</a></b> вызывается только функцией <b><a 
href="symbols.html#x188-380888r888">slot-value-using-class</a></b> и
соответственно неявно функцией <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b>.
<!--l. 10315--><p class="indent" >   Аргументами <b><a 
href="symbols.html#x188-380886r886">slot-unbound</a></b> являются: класс экземпляра, к слоту
которого происходил доступ, сам экземпляр и имя слота.
<!--l. 10318--><p class="indent" >   Если метод, написанный для <b><a 
href="symbols.html#x188-380886r886">slot-unbound</a></b>, возвращает значения, эти
значения возвращается в качестве значения вызова оригинальной
функции.
<!--l. 10321--><p class="indent" >   Несвязанный слот может получится, если не было формы для параметра
слота <b>:initform</b> и этот слот не был позже установлен, или был вызов
<b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b> с этим слотом.
<!--l. 10325--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380883r883">slot-makunbound</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302079"></a>
<em>
<!--l. 10330--><p class="noindent" >[Функция]</em> <b>slot-value</b> <i>object</i> <i>slot-name</i>
</div>
<!--l. 10332--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b> возвращает значение, содержащееся в слоте с именем
<em>slot-name</em> в объекте <em>object</em>. Если слота с данным именем не существует,
вызывается <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b>. Если слот не связан с каким-либо значением,
вызывается <b><a 
href="symbols.html#x188-380886r886">slot-unbound</a></b>.
<!--l. 10337--><p class="indent" >   Для изменения значения слота можно использовать <b><a 
href="symbols.html#x188-380844r844">setf</a></b> в связке с
<b><a 
href="symbols.html#x188-380887r887">slot-value</a></b>.
<!--l. 10340--><p class="indent" >   При попытке прочтения слота, которого не существует в данном
экземпляре класса, вызывается функция <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> как показано ниже:
<div class="lisp"><tt><div class="tabbing">
(slot-missing (class-of <em>instance</em>)
   <br>                            <em>instance</em><br>                           <em>slot-name</em><br>
              &#x2019;slot-value)<br>
<!--l. 10347--><p class="noindent" ></div>
</tt>
</div>
                                                                          

                                                                          
<!--l. 10349--><p class="indent" >   При попытке записи в слот, которого не существует в данном экземпляре
класса, вызывается функция <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> как показано ниже: <div class="lisp"><tt><div class="tabbing">
(slot-missing (class-of <em>instance</em>)
   <br>                                                                            <em>instance</em><br>
              <em>slot-name</em><br>                                          &#x2019;setf<br>
              <em>new-value</em>)<br>
<!--l. 10357--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10359--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b> реализована с использованием <b><a 
href="symbols.html#x188-380888r888">slot-value-using-class</a></b>.
<!--l. 10362--><p class="indent" >   Реализация может оптимизировать <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b> с помощью in-line
компиляции.
<!--l. 10364--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380885r885">slot-missing</a></b> и <b><a 
href="symbols.html#x188-380886r886">slot-unbound</a></b>.
<hr></div>
<!--l. 10367--><p class="indent" >   [At this point the original CLOS report <span class="cite">[<a 
href="bib.html#XSIGPLAN-CLOS">5</a>, <a 
href="bib.html#XLASC-CLOS-PART-2">7</a>]</span> contained a speciﬁcation for
<b><a 
href="symbols.html#x188-380944r944">symbol-macrolet</a></b>. This speciﬁcation is omitted here. Instead, a description of
<b><a 
href="symbols.html#x188-380944r944">symbol-macrolet</a></b> appears with those of related constructs in chapter <a 
href="contrl.html#x46-740007">7<!--tex4ht:ref: CONTRL --></a>.—GLS]
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302080"></a>
<em>
<!--l. 10373--><p class="noindent" >[Обобщённая функция]</em> <b>update-instance-for-diﬀerent-class</b> <i>previous</i> <i>current</i>
<tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>initargs</i><br />
<a 
 id="dx176-302081"></a>
<em>
[Главный метод]</em> <b>update-instance-for-diﬀerent-class</b> (<i>previous</i> standard-object)
(<i>current</i> standard-object) <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>initargs</i>
</div>
<!--l. 10377--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b> не должна
вызываться программистом. Однако программисты могут писать для неё
методы. Эта функция вызывается только из функции <b><a 
href="symbols.html#x188-380214r214">change-class</a></b>.
<!--l. 10381--><p class="indent" >   Системный главный метод <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b> проверяет
корректность инициализационных аргументов и в случае неуспеха
                                                                          

                                                                          
сигнализирует ошибку. Затем этот метод инициализирует слоты значениями
в соотвествие с инициализационными аргументами, а вновь добавленные
слоты значениями в соотвествие с их формами <b>:initform</b>. Это происходит в
вызове функции <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b> со следующими аргументами: экземпляр,
список имён вновь добавленных слотов, и полученные инициализационные
аргументы. Вновь добавленные слоты — это локальные слоты, для
которых не существовали одноимённые слоты в старом предыдущем
классе.
<!--l. 10391--><p class="indent" >   Для указания дополнительных действии при обновлении экземпляра
класса можно создать методы для <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b>. Если
определены только <b>:after</b> методы, то они запускаются после системного
главного метода и таким образом не воздействует на поведение системы
по-умолчанию.
<!--l. 10396--><p class="indent" >   Аргументы для <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b> вычисляются в
<b><a 
href="symbols.html#x188-380214r214">change-class</a></b>. Когда для экземпляра вызывается <b><a 
href="symbols.html#x188-380214r214">change-class</a></b>, создаётся
копия этого экземпляра. Она временно содержит старые значения слотов.
Эти аргументы имеют динамическую продолжительность видимости внутри
<b><a 
href="symbols.html#x188-380214r214">change-class</a></b>. Если после выхода из <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b> на
них остались ссылки, результат непредсказуем. Второй аргумент для
<b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b>, <em>current</em>, является модифицируемым
оригинальным экземпляром.
<!--l. 10406--><p class="indent" >   Использование <em>previous</em> заключается в получении старых значений слотов
с помощью <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b>, или <b><a 
href="symbols.html#x188-381023r1023">with-slots</a></b> или обобщённой функции чтения, или
для запуска других методов которые применимы для экземпляров
оригинального класса.
<!--l. 10411--><p class="indent" >   Аргумент <em>initargs</em> состоит из чередующихся имён инициализационных
аргументов и их значений.
<!--l. 10414--><p class="indent" >   Значение <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b> в <b><a 
href="symbols.html#x188-380214r214">change-class</a></b>
игнорируется.
<!--l. 10417--><p class="indent" >   Смотрите пример для функции <b><a 
href="symbols.html#x188-380214r214">change-class</a></b>.
<!--l. 10419--><p class="indent" >   Инициализационные аргументы корректны, если были указаны в
параметре <b>:initarg</b> или в методах для <b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b>
или <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b>.
<!--l. 10423--><p class="indent" >   Для инициализации слота по-особому могут быть определены методы для
<b><a 
href="symbols.html#x188-380990r990">update-instance-for-diﬀerent-class</a></b>. Поведение функции <b><a 
href="symbols.html#x188-380214r214">change-class</a></b>
по-умолчанию описано в разделе <a 
href="clmse143.html#x175-29600027.1.11">27.1.11<!--tex4ht:ref: Changing-the-Class-of-an-Instance-SECTION --></a>.
<!--l. 10427--><p class="indent" >   Смотрите разделы <a 
href="clmse143.html#x175-29600027.1.11">27.1.11<!--tex4ht:ref: Changing-the-Class-of-an-Instance-SECTION --></a>, <a 
href="clmse143.html#x175-28700027.1.9">27.1.9<!--tex4ht:ref: Rules-for-Initialization-Arguments-SECTION --></a> и <a 
href="clmse143.html#x175-28500027.1.9">27.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>.
<!--l. 10431--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380214r214">change-class</a></b> и <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b>.
                                                                          

                                                                          
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx176-302082"></a>
<em>
<!--l. 10435--><p class="noindent" >[Обобщённая функция]</em> <b>update-instance-for-redeﬁned-class</b> <i>instance</i>
<i>added-slots</i> <i>discarded-slots</i> <i>property-list</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>initargs</i><br />
<a 
 id="dx176-302083"></a>
<em>
[Главный метод]</em> <b>update-instance-for-redeﬁned-class</b> (<i>instance</i> standard-object)
<i>added-slots</i> <i>discarded-slots</i> <i>property-list</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;rest</a></tt> <i>initargs</i>
</div>
<!--l. 10440--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b> не должна
вызываться программистом. Однако программисты могут писать для
неё методы. Эта функция вызывается системой при использовании
<b>make-instance-obsolete</b>.
<!--l. 10444--><p class="indent" >   Системный главный метод <b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b>
проверяет корректность инициализационных аргументов и в случае неуспеха
сигнализирует ошибку. Затем этот метод инициализирует слоты значениями
в соотвествие с инициализационными аргументами, а вновь добавленные
слоты значениями в соотвествие с их формами <b>:initform</b>. Это происходит в
вызове функции <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b> со следующими аргументами: экземпляр,
список имён вновь добавленных слотов, и полученные инициализационные
аргументы. Вновь добавленные слоты — это локальные слоты, для
которых не существовали одноимённые слоты в старом предыдущем
классе.
<!--l. 10454--><p class="indent" >   При вызове <b>make-instance-obsolete</b> или при переопределении класса и
обновлении экземпляра, создаётся список свойств, который содержит имена
слотов и значения всех удалённых слотов из оригинального экземпляра.
Структура экземпляра трансформируется то, чтобы удовлетворять новому
определению класса. Аргумент <b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b>:
трансформированный экземпляр, список имён новых слотов, список имён
старых слотов, список свойств, содержащий имена и значения старых слотов.
В данных список также включается слоты, которые были локальными и
стали разделяемыми.
<!--l. 10463--><p class="indent" >   Аргумент <em>initargs</em> состоит из чередующихся имён инициализационных
                                                                          

                                                                          
аргументов и их значений.
<!--l. 10466--><p class="indent" >   Значение, возвращаемое из <b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b>
игнорируется.
<!--l. 10468--><p class="indent" >   Инициализационные аргументы корректны, если были указаны в
параметре <b>:initarg</b> или в методах для <b><a 
href="symbols.html#x188-380991r991">update-instance-for-redeﬁned-class</a></b>
или <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b>.
<!--l. 10472--><p class="indent" >   Смотрите разделы <a 
href="clmse143.html#x175-29100027.1.10">27.1.10<!--tex4ht:ref: Redefining-Classes-SECTION --></a>, <a 
href="clmse143.html#x175-28700027.1.9">27.1.9<!--tex4ht:ref: Rules-for-Initialization-Arguments-SECTION --></a> и <a 
href="clmse143.html#x175-28500027.1.9">27.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>.
<!--l. 10476--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-380849r849">shared-initialize</a></b> и <b>make-instance-obsolete</b>.
<div class="lisp">
<tt>
<!--l. 10478--><p class="indent" >   <div class="tabbing">
(defclass position () ())
   <br>                                                                                               <br>
(defclass x-y-position (position)<br>        ((x :initform 0 :accessor position-x)<br>
   (y :initform 0 :accessor position-y)))<br>
<br> ;;; Оказывается полярные координаты используются чаще декартовых<br>
;;; координат, так что представление меняется, и добавляются<br>
;;; некоторые новые методы доступа.<br>
<br>                     (defmethod update-instance-for-redeﬁned-class :before<br>
           ((pos x-y-position) added deleted plist &#x0026;key)<br>
  ;; Transform the x-y coordinates to polar coordinates<br>
  ;; and store into the new slots.<br>
  (let ((x (getf plist &#x2019;x))<br>                               (y (getf plist &#x2019;y)))<br>
    (setf (position-rho pos) (sqrt (+ (* x x) (* y y)))<br>
          (position-theta pos) (atan y x))))<br>
<br>                                           (defclass x-y-position (position)<br>
    ((rho :initform 0 :accessor position-rho)<br>
     (theta :initform 0 :accessor position-theta)))<br>
<!--l. 10501--><p class="noindent" ></div>
</tt>
</div>
<div class="lisp">
<tt>
<!--l. 10504--><p class="indent" >   <div class="tabbing">
                                                                          

                                                                          
;;; Все экземпляры старого класса x-y-position будут обновлены
   <br>                                                                      ;;; автоматически.<br>
<br>                       ;;; Новое представление имеет вид и вкус старого.<br>
<br>                                 (defmethod position-x ((pos x-y-position))<br>
   (with-slots (rho theta) pos (* rho (cos theta))))<br>
<br>                    (defmethod (setf position-x) (new-x (pos x-y-position))<br>
   (with-slots (rho theta) pos<br>                   (let ((y (position-y pos)))<br>
       (setq rho (sqrt (+ (* new-x new-x) (* y y)))<br>
             theta (atan y new-x))<br>                            new-x)))<br>
<br>                                 (defmethod position-y ((pos x-y-position))<br>
   (with-slots (rho theta) pos (* rho (sin theta))))<br>
<!--l. 10522--><p class="noindent" ></div>
</tt>
</div>
<div class="lisp">
<tt>
<!--l. 10523--><p class="indent" >   <div class="tabbing">
(defmethod (setf position-y) (new-y (pos x-y-position))
   <br>          (with-slots (rho theta) pos<br>            (let ((x (position-x pos)))<br>
       (setq rho (sqrt (+ (* x x) (* new-y new-y)))<br>
             theta (atan new-y x))<br>                            new-y)))<br>
<!--l. 10530--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 10534--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>with-accessors</b> <a 
 id="dx176-302084"></a>({slot-entry}*) instance-form{declaration}* {form}*
                                                                          

                                                                          
   <br>
<!--l. 10536--><p class="noindent" ></div>
</div>
<!--l. 10537--><p class="indent" >   Макрос <b><a 
href="symbols.html#x188-381013r1013">with-accessors</a></b> создаёт лексическое окружение, в котором
указанные слоты доступны с помощью аксессоров, как если бы они были
переменными. Для доступа к указанному слоту макрос <b><a 
href="symbols.html#x188-381013r1013">with-accessors</a></b>
вызывает соответствующий аксессор. Для установки значения в слот может
использоваться и <b><a 
href="symbols.html#x188-380844r844">setf</a></b>, и <b><a 
href="symbols.html#x188-380845r845">setq</a></b>.
<!--l. 10543--><p class="indent" >   Результатом является то, что вернут формы указанные в аргументе
<em>form</em>.
<!--l. 10545--><p class="indent" >   Например:
<div class="lisp">
<tt>
<!--l. 10547--><p class="indent" >   <div class="tabbing">
(with-accessors ((x position-x) (y position-y)) p1
   <br>                                                                                (setq x y))<br>
<!--l. 10550--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10552--><p class="indent" >   Выражение <b><a 
href="symbols.html#x188-381013r1013">with-accessors</a></b> в форме: <div class="lisp"><tt><div class="tabbing">
(with-accessors (<span class="math">slot<sub>1</sub></span> ... <span class="math">slot<sub>n</sub></span>) <em>instance</em>
   <br>                                                   <span class="math">declaration<sub>1</sub></span> ... <span class="math">declaration<sub>m</sub></span>)<br>
  <span class="math">form<sub>1</sub></span> ... <span class="math">form<sub>k</sub></span>)<br>
<!--l. 10557--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10558--><p class="indent" >   раскрывается в эквивалентное выражение <div class="lisp"><tt><div class="tabbing">
(let ((<em>in</em> <em>instance</em>))
                                                                          

                                                                          
   <br>
  (symbol-macrolet ((<span class="math">variable<sub>1</sub></span> (<span class="math">accessor<sub>1</sub></span> <em>in</em>))<br>                       ...<br>
                    (<span class="math">variable<sub>n</sub></span> (<span class="math">accessor<sub>n</sub></span> <em>in</em>)))<br>
    <span class="math">declaration<sub>1</sub></span> ... <span class="math">declaration<sub>m</sub></span>)<br>                       <span class="math">form<sub>1</sub></span> ... <span class="math">form<sub>k</sub></span>)<br>
<!--l. 10566--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10568--><p class="indent" >   [X3J13 voted in March 1989 <a 
 id="dx176-302085"></a>to modify the deﬁnition of <b><a 
href="symbols.html#x188-380944r944">symbol-macrolet</a></b>
substantially and also voted <a 
 id="dx176-302086"></a>to allow declarations before the body of
<b><a 
href="symbols.html#x188-380944r944">symbol-macrolet</a></b> but with peculiar treatment of <b>special</b> and type declarations.
The syntactic changes are reﬂected in this deﬁnition of <b><a 
href="symbols.html#x188-381013r1013">with-accessors</a></b>.—GLS]
<!--l. 10577--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-381023r1023">with-slots</a></b> и <b><a 
href="symbols.html#x188-380944r944">symbol-macrolet</a></b>.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 10582--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>with-slots</b> <a 
 id="dx176-302087"></a>({slot-entry}*) instance-form {declaration}* {form}*
   <br>
<!--l. 10583--><p class="noindent" ></div>
</div>
<!--l. 10584--><p class="indent" >   <div class="tabbing">
<em>slot-entry</em> ::= <em>slot-name</em> | <b>(<em>variable-name</em> <em>slot-name</em>)</b>
   <br>
<!--l. 10586--><p class="noindent" ></div>Макрос <b><a 
href="symbols.html#x188-381023r1023">with-slots</a></b> создаёт лексический контекст для ссылки на заданные
слоты как если бы они были переменными. Внутри такого контекста
значение слота может быть получено просто указанием имени слота, как если
бы это была лексически связанная переменная. Для установки значения в
слот может использоваться и <b><a 
href="symbols.html#x188-380844r844">setf</a></b>, и <b><a 
href="symbols.html#x188-380845r845">setq</a></b>.
<!--l. 10593--><p class="indent" >   Макрос <b><a 
href="symbols.html#x188-381023r1023">with-slots</a></b> транслирует вхождения имени слота как переменной в
вызов <b><a 
href="symbols.html#x188-380887r887">slot-value</a></b>.
<!--l. 10596--><p class="indent" >   Результатом является то, что вернут формы указанные в аргументе
<em>form</em>.
                                                                          

                                                                          
<!--l. 10598--><p class="indent" >   Например:
<div class="lisp">
<tt>
<!--l. 10600--><p class="indent" >   <div class="tabbing">
(with-slots (x y) position-1
   <br>                                                            (sqrt (+ (* x x) (* y y))))<br>
<br>                                      (with-slots ((x1 x) (y1 y)) position-1<br>
  (with-slots ((x2 x) (y2 y)) position-2<br>                        (psetf x1 x2<br>
           y1 y2))))<br>                                                    <br>
(with-slots (x y) position<br>                                   (setq x (1+ x)<br>
        y (1+ y)))<br>
<!--l. 10612--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10614--><p class="indent" >   Выражение <b><a 
href="symbols.html#x188-381023r1023">with-slots</a></b> в форме: <div class="lisp"><tt><div class="tabbing">
(with-slots (<span class="math">slot-entry<sub>1</sub></span> ... <span class="math">slot-entry<sub>n</sub></span>) <em>instance</em>
   <br>                                                   <span class="math">declaration<sub>1</sub></span> ... <span class="math">declaration<sub>m</sub></span>)<br>
  <span class="math">form<sub>1</sub></span> ... <span class="math">form<sub>k</sub></span>)<br>
<!--l. 10619--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10620--><p class="indent" >   раскрывается в эквивалентный код <div class="lisp"><tt><div class="tabbing">
(let ((<em>in</em> <em>instance</em>))
   <br>      (symbol-macrolet (<span class="math">Q<sub>1</sub></span> ... <span class="math">Q<sub>n</sub></span>)<br>        <span class="math">declaration<sub>1</sub></span> ... <span class="math">declaration<sub>m</sub></span>)<br>
    <span class="math">form<sub>1</sub></span> ... <span class="math">form<sub>k</sub></span>)<br>
<!--l. 10626--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10627--><p class="indent" >   где <span class="math">Q<sub>j</sub></span> является <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(<span class="math">slot-entry<sub>j</sub></span> (slot-value <em>in</em> &#x2019;<span class="math">slot-entry<sub>j</sub></span>))
   <br>
<!--l. 10630--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10631--><p class="indent" >   если <span class="math">slot-entry<sub>j</sub></span> является символом, или <span class="math">Q<sub>j</sub></span> является <div class="lisp"><tt><div class="tabbing">
(<span class="math">variable-name<sub>j</sub></span> (slot-value <em>in</em> &#x2019;<span class="math">slot-name<sub>j</sub></span>))
   <br>
<!--l. 10634--><p class="noindent" ></div>
</tt>
</div>
<!--l. 10635--><p class="indent" >   если <span class="math">slot-entry<sub>j</sub></span> принадлежит форме <b>(<span class="math">variable-name<sub>j</sub></span> <span class="math">slot-name<sub>j</sub></span>)</b>.
<!--l. 10638--><p class="indent" >   [X3J13 voted in March 1989 <a 
 id="dx176-302088"></a>to modify the deﬁnition of <b><a 
href="symbols.html#x188-380944r944">symbol-macrolet</a></b>
substantially and also voted <a 
 id="dx176-302089"></a>to allow declarations before the body of
<b><a 
href="symbols.html#x188-380944r944">symbol-macrolet</a></b> but with peculiar treatment of <b>special</b> and type declarations.
The syntactic changes are reﬂected in this deﬁnition of <b><a 
href="symbols.html#x188-381023r1023">with-slots</a></b>.—GLS]
<!--l. 10647--><p class="indent" >   Смотрите <b><a 
href="symbols.html#x188-381013r1013">with-accessors</a></b> и <b><a 
href="symbols.html#x188-380944r944">symbol-macrolet</a></b>.
<hr></div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
<!--l. 2963--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="condition.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse143.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse143.html#tailclmse143.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse144.html" >В-начало</a>&#x003E;&#x003C;<a 
href="clos.html#clmse144.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse144.html"></a>
 
</body></html> 
