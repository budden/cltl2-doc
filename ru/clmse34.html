<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Логические операторы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2013-01-10 13:49:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="contrl.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse33.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse33.html#tailclmse33.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse34.html">В-конец</a>&#x003E;&#x003C;<a 
href="preds.html#clmse34.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">6.4
</span> <a 
href="clm.html#QQ2-45-82" id="x45-730006.4">Логические операторы</a></h3>
<!--l. 1835--><p class="noindent" >Common Lisp содержит три логических оператора для булевых значений:
<b><a 
href="symbols.html#x188-380098r98">and</a></b>, <b><a 
href="symbols.html#x188-380703r703">or</a></b> и <b><a 
href="symbols.html#x188-380676r676">not</a></b> (и, или, не, соответственно). <b><a 
href="symbols.html#x188-380098r98">and</a></b> и <b><a 
href="symbols.html#x188-380703r703">or</a></b> являются управляющими
структурами, потому что их аргументы вычисляются в зависимости от
условия. Функции <b><a 
href="symbols.html#x188-380676r676">not</a></b> необходимо инвертировать её один аргумент, поэтому
она может быть простой функцией.
<div class="defun">
<div class="defunheader">
<a 
 id="dx45-73001"></a>
<em>
<!--l. 1843--><p class="noindent" >[Функция]</em> <b>not</b> <i>x</i>
</div>
<b>
<!--l. 1845--><p class="indent" >   <a 
href="symbols.html#x188-380676r676">not</a></b> возвращает <b><a 
href="symbols.html#x188-380951r951">t</a></b>, если <em>x</em> является <b><a 
href="symbols.html#x188-380670r670">nil</a></b>, иначе возвращает <b><a 
href="symbols.html#x188-380670r670">nil</a></b>. Таким
образом она инвертирует аргумент как булево значение.
<b>
<!--l. 1849--><p class="indent" >   <a 
href="symbols.html#x188-380696r696">null</a></b> то же, что и <b><a 
href="symbols.html#x188-380676r676">not</a></b>, обе функции включены для ясности. По
соглашению принято использовать <b><a 
href="symbols.html#x188-380696r696">null</a></b>, когда надо проверить пустой ли
список, и <b><a 
href="symbols.html#x188-380676r676">not</a></b>, когда надо инвертировать булево значение.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1855--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>and</b> <a 
 id="dx45-73002"></a>{form}*
   <br>
<!--l. 1856--><p class="noindent" ></div>
</div>
                                                                          

                                                                          
<b>
<!--l. 1857--><p class="indent" >   (and <em>form1</em> <em>form2</em> ... )</b> последовательно слева направо вычисляет
формы. Если какая-либо форма <em>formN</em> вычислилась в <b><a 
href="symbols.html#x188-380670r670">nil</a></b>, тогда немедленно
возвращается значение <b><a 
href="symbols.html#x188-380670r670">nil</a></b> без выполнения оставшихся форм. Если все
формы кроме последней вычисляются в не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> значение, <b><a 
href="symbols.html#x188-380098r98">and</a></b> возвращает то,
что вернула последняя форма. Таким образом, <b><a 
href="symbols.html#x188-380098r98">and</a></b> может использоваться,
как для логических операций, где <b><a 
href="symbols.html#x188-380670r670">nil</a></b> обозначает ложь и не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> значения
истину, так и для условных выражений. Например: <div class="lisp"><tt><div class="tabbing">
(if (and (&#x003E;= n 0)
   <br>                                                  (&#x003C; n (length a-simple-vector))<br>
         (eq (elt a-simple-vector n) &#x2019;foo))<br>                 (princ &#x0022;Foo!&#x0022;))<br>
<!--l. 1871--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1872--><p class="indent" >   Выражение выше выводит <b>Foo!</b>, если <b>n</b>-ый элемент вектора <b>a-simple-vector</b>
является символом <b>foo</b>, проверяя при этом вхождения <b>n</b> в границы вектора
<b>a-simple-vector</b>. <b><a 
href="symbols.html#x188-380367r367">elt</a></b> не будет вызвано с аргументом <b>n</b> выходящим за
границы вектора, так как <b><a 
href="symbols.html#x188-380098r98">and</a></b> гарантирует ленивую проверку аргументов
слева направо.
<!--l. 1878--><p class="indent" >   Специальная форма Lisp&#x2019;а <b><a 
href="symbols.html#x188-380098r98">and</a></b> отличается тем, что в определённых
случаях вычисляет не все аргументы.
<!--l. 1881--><p class="indent" >   Запись предыдущего примера <div class="lisp"><tt><div class="tabbing">
(and (&#x003E;= n 0)
   <br>                                                    (&#x003C; n (length a-simple-vector))<br>
     (eq (elt a-simple-vector n) &#x2019;foo)<br>                      (princ &#x0022;Foo!&#x0022;))<br>
<!--l. 1887--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1888--><p class="indent" >   будет выполнять ту же функцию. Разница в них только стилистическая.
Некоторые программисты никогда не используют в форме <b><a 
href="symbols.html#x188-380098r98">and</a></b> выражения с
побочными эффектами, предпочитая для этих целей использовать <b><a 
href="symbols.html#x188-380488r488">if</a></b> или
<b><a 
href="symbols.html#x188-381009r1009">when</a></b>.
                                                                          

                                                                          
<!--l. 1892--><p class="indent" >   Из общего определения можно сделать дедуктивный вывод о том, что
<b>(and <em>x</em>)</b> <span class="math"> ≡</span> <em>x</em>. Также <b>(and)</b> выполняется в <b><a 
href="symbols.html#x188-380951r951">t</a></b>, который тождественен этой
операции.
<!--l. 1896--><p class="indent" >   Можно определить <b><a 
href="symbols.html#x188-380098r98">and</a></b> в терминах <b><a 
href="symbols.html#x188-380281r281">cond</a></b> таким образом: <div class="lisp"><tt><div class="tabbing">
(and <em>x</em> <em>y</em> <em>z</em> ... <em>w</em>) <span class="math"> ≡</span> (cond ((not <em>x</em>) <b><a 
href="symbols.html#x188-380670r670">nil</a></b>)
   <br>                                                                               ((not <em>y</em>) <b><a 
href="symbols.html#x188-380670r670">nil</a></b>)<br>
                           ((not <em>z</em>) <b><a 
href="symbols.html#x188-380670r670">nil</a></b>)<br>                                  <span class="math">…</span><br>
                           (<b><a 
href="symbols.html#x188-380951r951">t</a></b> <em>w</em>))<br>
<!--l. 1903--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1905--><p class="indent" >   Смотрите <b>id</b> и <b><a 
href="symbols.html#x188-381009r1009">when</a></b>, которые иногда являются стилистически более
удобными, чем <b><a 
href="symbols.html#x188-380098r98">and</a></b> в целях ветвления. Если необходимо проверить
истинность предиката для всех элементов списка или вектора (element 0
<em>and</em> element 1 <em>and</em> element 2 <em>and</em> <span class="math">…</span>), можно использовать функцию
<b><a 
href="symbols.html#x188-380389r389">every</a></b>.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1913--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>or</b> <a 
 id="dx45-73003"></a>{form}*
   <br>
<!--l. 1914--><p class="noindent" ></div>
</div>
<b>
<!--l. 1915--><p class="indent" >   (or <em>form1</em> <em>form2</em> ... )</b> последовательно выполняет каждую форму слева
направо. Если какая-либо непоследняя форма выполняется в что-либо
отличное от <b><a 
href="symbols.html#x188-380670r670">nil</a></b>, <b><a 
href="symbols.html#x188-380703r703">or</a></b> немедленно возвращает это не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> значение без
выполнения оставшихся форм. Если все формы кроме последней,
вычисляются в <b><a 
href="symbols.html#x188-380670r670">nil</a></b>, <b><a 
href="symbols.html#x188-380703r703">or</a></b> возвращает то, что вернула последняя форма. Таким
образом <b><a 
href="symbols.html#x188-380703r703">or</a></b> может быть использована как для логических операций, в
который <b><a 
href="symbols.html#x188-380670r670">nil</a></b> обозначает ложь, и не-<b><a 
href="symbols.html#x188-380670r670">nil</a></b> истину, так и для условного
выполнения форм.
                                                                          

                                                                          
<!--l. 1924--><p class="indent" >   Специальная форма Lisp&#x2019;а <b><a 
href="symbols.html#x188-380703r703">or</a></b> отличается тем, что в определённых
случаях вычисляет не все аргументы.
<!--l. 1927--><p class="indent" >   Из общего определения, можно сделать дедуктивный вывод о том, что <b>(or
<em>x</em>)</b> <span class="math"> ≡</span> <em>x</em>. Также, <b>(or)</b> выполняется в <b><a 
href="symbols.html#x188-380670r670">nil</a></b>, который тождественен этой
операции.
<!--l. 1931--><p class="indent" >   Можно определить <b><a 
href="symbols.html#x188-380703r703">or</a></b> в терминах <b><a 
href="symbols.html#x188-380281r281">cond</a></b> таким образом: <div class="lisp"><tt><div class="tabbing">
(or <em>x</em> <em>y</em> <em>z</em> ... <em>w</em>) <span class="math"> ≡</span> (cond (<em>x</em>) (<em>y</em>) (<em>z</em>) ... (<b><a 
href="symbols.html#x188-380951r951">t</a></b> <em>w</em>))
   <br>
<!--l. 1934--><p class="noindent" ></div>
</tt>
</div>
<!--l. 1936--><p class="indent" >   Смотрите <b>id</b> и <b><a 
href="symbols.html#x188-380982r982">unless</a></b>, которые иногда являются стилистически более
удобными, чем <b><a 
href="symbols.html#x188-380703r703">or</a></b> в целях ветвления. Если необходимо проверить истинность
предиката для всех элементов списка или вектора (element 0 <em>or</em> element 1 <em>or</em>
element 2 <em>or</em> <span class="math">…</span>), можно использовать функцию <b><a 
href="symbols.html#x188-380891r891">some</a></b>.
<hr></div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
<!--l. 4359--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="contrl.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse33.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse33.html#tailclmse33.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse34.html" >В-начало</a>&#x003E;&#x003C;<a 
href="preds.html#clmse34.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse34.html"></a>
 
</body></html> 
