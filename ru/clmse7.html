<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Массивы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2013-03-12 14:38:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="clmse8.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse6.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse6.html#tailclmse6.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse7.html">В-конец</a>&#x003E;&#x003C;<a 
href="dtypes.html#clmse7.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">2.5
</span> <a 
href="clm.html#QQ2-14-33" id="x14-270002.5">Массивы</a></h3>
<a 
 id="dx14-27001"></a>
<b>
<!--l. 2448--><p class="noindent" >Массив (<b>array</b>)</b> является объектом с элементами расположенными в
соответствие с декартовой системой координат.
<!--l. 2451--><p class="indent" >   Количество измерений массива называется <em>ранг</em> (это терминология
взята из APL). Ранг является неотрицательных целым. Также каждое
измерение само по себе является неотрицательным целым. Общее
количество элементов в массиве является произведением размеров всех
измерений.
<!--l. 2457--><p class="indent" >   Реализация Common Lisp&#x2019;а может налагать ограничение на ранг массива,
но данное ограничение не может быть менее 7. Таким образом, любая
Common Lisp программа может использовать массивы с семью и менее
измерениями. (Программа может получить текущее ограничение для ранга
для используемой системы с помощью константы <b><a 
href="symbols.html#x200-396118r118">array-rank-limit</a></b>.)
<!--l. 2463--><p class="indent" >   Допускается существование нулевого ранга. В этом случае, массив не
содержит элементов, и любой доступ к элементам является ошибкой. При
этом другие свойства массива использоваться могут. Если ранг равен нулю,
тогда массив не имеет измерений, и их произведение приравнивается к 1
(FIXME). Таким образом массив с нулевым рангом содержит один
элемент.
<!--l. 2469--><p class="indent" >   Элемент массива задаётся последовательностью индексов. Длина
данной последовательности должна равняется рангу массива. Каждый
индекс должен быть неотрицательным целым строго меньшим размеру
соответствующего измерения. Также индексация массива начинается с нуля,
а не с единицы, как в по умолчанию Fortran&#x2019;е.
<!--l. 2475--><p class="indent" >   В качестве примера, предположим, что переменная <b>foo</b> обозначает
двумерный массив с размерами измерений 3 и 5. Первый индекс может быть
0, 1 или 2, и второй индекс может быть 0, 1, 2, 3 или 4. Обращение к
элементам массива может быть осуществлено с помощью функции <b><a 
href="symbols.html#x200-396105r105">aref</a></b>,
например, <b>(aref foo 2 1)</b> ссылается на элемент массива (2, 1). Следует
                                                                          

                                                                          
отметить, что <b><a 
href="symbols.html#x200-396105r105">aref</a></b> принимает переменное число аргументов: массив, и
столько индексов, сколько измерений у массива. Массив с нулевым рангом не
имеет измерений, и в таком случае <b><a 
href="symbols.html#x200-396105r105">aref</a></b> принимает только один параметр –
массив, и не принимает индексы, и возвращает одиночный элемент
массива.
<!--l. 2486--><p class="indent" >   В целом, массивы могут быть многомерными, могут иметь общее
содержимое с другими массивами. и могут динамически менять свой размер
после создания (и увеличивать, и уменьшать). Одномерный массив может
также иметь <em>указатель заполнения</em>.
<!--l. 2491--><p class="indent" >   Многомерные массивы хранят элементы построчно. Это значит, что
внутренне многомерный массив хранится как одномерный массив с порядком
элементов, соответствующим лексикографическому порядку их индексов. Это
важно в двух ситуациях: (1) когда массивы с разными измерениями имеют
общее содержимое, и (2) когда осуществляется доступ к очень большому
массиву в виртуальной памяти. (Первая ситуация касается семантики; вторая
— эффективности)
<!--l. 2499--><p class="indent" >   Массив, что не указывает на другой массив, не имеет указателя
заполнения и не имеет динамически расширяемого размера после создания
называется <em>простым</em> массивом. Пользователи могут декларировать
то, что конкретный массив будет простым. Некоторые реализации
могут обрабатывать простые массивы более эффективным способом,
например, простые массивы могут храниться более компактно, чем
непростые.
<!--l. 2506--><p class="indent" >   Когда вызывается <b><a 
href="symbols.html#x200-396588r588">make-array</a></b>, если один или более из <b>:adjustable</b>,
<b>:ﬁll-pointer</b> и <b>:displaced-to</b> аргументов равен истине, тогда является ли
результат простым массивом не определено. Однако если все три
аргумента равны лжи, тогда результат гарантированно будет простым
массивом.
<!--l. 2511--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.1   </span> <a 
href="frontmatter.html#QQ2-14-34" id="x14-280002.5.1">Векторы</a></h4>
<!--l. 2513--><p class="noindent" >В Common Lisp&#x2019;е одномерные массивы называется <em>векторами</em>, и составляют
тип <b>vector</b> (который в свою очередь является подтипом <b>array</b>). Вектора и
списки вместе являются <em>последовательностями</em>. Они отличаются тем, что
любой элемент одномерного массива может быть получен за константное
время, тогда как среднее время доступа к компоненту для списка
                                                                          

                                                                          
линейно зависит от длины списка, с другой стороны, добавление нового
элемента в начала списка занимает константное время, тогда как эта же
операция для массива занимает время линейно зависящее от длины
массива.
<!--l. 2522--><p class="indent" >   Обычный вектор (одномерный массив, который может содержать любой
тип объектов, но не имеющий дополнительных атрибутов) может быть
записан с помощью перечисления элементов разделённых пробелом и
окружённых <b>#(</b> и <b>)</b>. Например: <div class="lisp"><tt><div class="tabbing">
#(a b c)                    ;Вектор из трёх элементов
   <br>                              #()                         ;Пустой вектор<br>
#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)<br>                            ;Вектор содержит простые числа меньшие пятидесяти<br>
<!--l. 2532--><p class="noindent" ></div>
</tt>
</div>
<!--l. 2534--><p class="indent" >   Следует отметить, что когда функция <b><a 
href="symbols.html#x200-396778r778">read</a></b> парсит данный синтаксис, она
всегда создаёт <em>простой</em> массив.
__________________________________________<div class="rationale">
<!--l. 2538--><p class="noindent" ><b>Обоснование:</b> Многие люди рекомендовали использовать квадратные
скобки для задания векторов так: <b>[a b c]</b> вместо <b>#(a b c)</b>. Данная запись
короче, возможно более читаема, и безусловно совпадает с культурными
традициями в других областях компьютерных наук и математики. Однако, для
достижения предельной полезности от пользовательских макросимволов,
что расширяют возможности функции <b><a 
href="symbols.html#x200-396778r778">read</a></b>, необходимо было оставить
некоторые строковые символы для этих пользовательских целей. Опыт
использования MacLisp&#x2019;а показывает, что пользователи, особенно разработчики
языков для использования в исследованиях искусственного интеллекта, часто
хотят определять специальные значения для квадратных скобок. Таким
образом Common Lisp не использует квадратных и фигурных скобок в своём
синтаксисе.
</div>___________________________________________________________________________________________________________
<!--l. 2553--><p class="indent" >     Реализации могут содержать специализированные представления
массивов для достижения эффективности в случаях, когда все элементы
принадлежат одному определённому типу (например, числовому). Все
                                                                          

                                                                          
реализации содержат специальные массивы в случаях, когда все элементы
являются строковыми символами (или специализированное подмножество
строковых символов). Такие одномерные массивы называются <em>строки</em>. Все
реализации также должны содержать специализированные битовые массивы,
которые принадлежат типу <b>(array bit)</b>. Такие одномерные массивы
называются <em>битовые векторы</em>.
<!--l. 2563--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.2   </span> <a 
href="frontmatter.html#QQ2-14-35" id="x14-290002.5.2">Строки</a></h4>
<div class="lisp">
<tt>
<!--l. 2566--><p class="noindent" ><div class="tabbing">
base-string <span class="math"> ≡</span> (vector base-char)
   <br>                             simple-base-string <span class="math"> ≡</span> (simple-array base-char (*))<br>
<!--l. 2569--><p class="noindent" ></div>
</tt>
</div>
<!--l. 2571--><p class="noindent" >Реализация может поддерживать другие типы строк. Все функции
Common Lisp&#x2019;а взаимодействуют со строками одинаково. Однако
следует отметить, вставка extended character в base string является
ошибкой.
<b>
<!--l. 2575--><p class="indent" >   Строковый (<b><a 
href="symbols.html#x200-396908r908">string</a></b>)</b> тип является подтипом <b>векторного (<b><a 
href="symbols.html#x200-397002r1002">vector</a></b>)</b>
типа.
<!--l. 2577--><p class="indent" >   Строка может быть записана как последовательность символов, с
предшествующим и последующим символом двойной кавычки <b>&#x0022;</b>. Любой
символ <b>&#x0022;</b> или <b>\</b> в данной последовательности должен иметь предшествующий
символ <b>\</b>.
<!--l. 2582--><p class="indent" >   Например: <div class="lisp"><tt><div class="tabbing">
&#x0022;Foo&#x0022;                         ;Строка из трёх символов
                                                                          

                                                                          
   <br>                           &#x0022;&#x0022;                            ;Пустая строка<br>
&#x0022;\&#x0022;APL\\360?\&#x0022; he cried.&#x0022;     ;Строка из двенадцати символов<br>
&#x0022;|x| = |-x|&#x0022;                  ;Строка из десяти символов<br>
<!--l. 2589--><p class="noindent" ></div>
</tt>
</div>
<!--l. 2591--><p class="indent" >   Необходимо отметить, что символ вертикальной черты <b>|</b> в строке не
должен быть экранирован с помощью <b>\</b>. Также как и любая двойная
кавычка в имени символа, записанного с использованием вертикальных черт,
не нуждается в экранировании. Записи с помощью двойной кавычки и
вертикальной черты похожи, но используются для разных целей: двойная
кавычка указывает на строку, содержащую строковые символы, тогда как
вертикальная черта указывает на символ, имя которого содержит
последовательность строковых символов.
<!--l. 2599--><p class="indent" >   Строковые символы обрамленные двойными кавычками, считываются
слева направо. Индекс символа больше индекса предыдущего символа на 1.
Самый левый символ строки имеет индекс 0, следующий 1, следующий 2, и
т.д.
<!--l. 2603--><p class="indent" >   Следует отметить, что функция <b>prin1</b> будет выводить на печать в данном
синтаксисе любой вектор строковых символов (не только простой), но
функция <b><a 
href="symbols.html#x200-396778r778">read</a></b> при разборе данного синтаксиса будет всегда создавать
простую строку.
<!--l. 2608--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.3   </span> <a 
href="frontmatter.html#QQ2-14-36" id="x14-300002.5.3">Битовые векторы</a></h4>
<!--l. 2610--><p class="noindent" >Битовый вектор может быть записан в виде последовательности битов
заключённых в строку с предшествующей <b>#*</b>; любой разделитель,
например, как пробел завершает синтаксис битового вектора. Например:
<div class="lisp"><tt><div class="tabbing">
#*10110     ;Пятибитный битовый вектор; нулевой бит 1
   <br>                                          #*          ;Пустой битовый вектор<br>
<!--l. 2617--><p class="noindent" ></div>
                                                                          

                                                                          
</tt>
</div>
<!--l. 2619--><p class="indent" >   Биты записанные после <b>#*</b>, читаются слева направо. Индекс каждого
бита больше индекса предыдущего бита на 1. Индекс самого левого бита 0,
следующего 1 и т.д.
<!--l. 2623--><p class="indent" >   Функция <b>prin1</b> выводит любой битовый вектор (не только простой) в
этом синтаксисе, однако функция <b><a 
href="symbols.html#x200-396778r778">read</a></b> при разборе этого синтаксиса будет
всегда создавать простой битовый вектор.
                                                                          

                                                                          
<!--l. 2627--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse8.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse6.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse6.html#tailclmse6.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse7.html" >В-начало</a>&#x003E;&#x003C;<a 
href="dtypes.html#clmse7.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse7.html"></a>
 
</body></html> 
