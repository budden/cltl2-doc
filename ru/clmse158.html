<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Обзор концепций</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2013-03-12 14:38:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="clmse159.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse157.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse157.html#tailclmse157.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse158.html">В-конец</a>&#x003E;&#x003C;<a 
href="condition.html#clmse158.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">29.3
</span> <a 
href="clm.html#QQ2-192-366" id="x192-32200029.3">Обзор концепций</a></h3>
<!--l. 3084--><p class="noindent" >В этом разделе по темам обсуждаются различные аспекты системы условий,
иллюстрируя их многочисленными примерами. В следующем разделе
содержатся определения конкретных функций, макросов и других
объектов.
<!--l. 3088--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.1   </span> <a 
href="frontmatter.html#QQ2-192-367" id="x192-32300029.3.1">Сигнализирование ошибок</a></h4>
<!--l. 3090--><p class="noindent" >Концептуально, сигнализирование ошибок в программе это указание того,
что программа, не знает как продолжить выполнение и требует внешнего
вмешательства. Как только сигнализирована ошибка, любые советы о
продолжении должны прийти «извне».
<!--l. 3095--><p class="indent" >   Самый простой путь сигнализирования ошибки использовать функцию
<b><a 
href="symbols.html#x200-396383r383">error</a></b> с аргументами как для функции <b><a 
href="symbols.html#x200-396438r438">format</a></b>, описывающие ошибку для
пользовательского интерфейса. Если была вызвана <b><a 
href="symbols.html#x200-396383r383">error</a></b> и активных
обработчиков (описанных в разделах <a 
href="#x192-32400029.3.2">29.3.2<!--tex4ht:ref: TRAPPING-ERRORS --></a> и <a 
href="#x192-32500029.3.3">29.3.3<!--tex4ht:ref: HANDLING-CONDITIONS --></a>) не оказалось, то в
управление вмешивается отладчик и данное сообщение выводится
пользователю. Например: <div class="lisp"><tt><div class="tabbing">
Lisp&#x003E; (defun factorial (x)
   <br>                             (cond ((or (not (typep x &#x2019;integer)) (minusp x))<br>
               (error &#x0022;~S is not a valid argument to FACTORIAL.&#x0022;<br>
                      x))<br>                              ((zerop x) 1)<br>
              (t (* x (factorial (- x 1))))))<br>             <span class="math"> ⇒</span> FACTORIAL<br>
Lisp&#x003E; (factorial 20)<br>                             <span class="math"> ⇒</span> 2432902008176640000<br>
Lisp&#x003E; (factorial -1)<br>      Error: -1 is not a valid argument to FACTORIAL.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Return to Lisp Toplevel.<br>                                       Debug&#x003E;<br>
                                                                          

                                                                          
<!--l. 3116--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3117--><p class="indent" >   В общем, вызов <b><a 
href="symbols.html#x200-396383r383">error</a></b> не может вернуть управление в то же место. Если
не была проделана специальная работа по обработке для изменения этого
поведения, то в работу вмешается отладчик и в нем не будет возможности
просто продолжить работу.
<!--l. 3121--><p class="indent" >   Единственное исключение может быть в том, что некоторые реализации
могут содержать отладочные команды для интерактивного возврата из
конкретных мест по стеку вызовов. Однако, даже тогда такие команды не
должны использоваться за исключением того, что кто-то читает ошибочный
код и понимание последствия продолжения кода с этого места. В частности,
программист может чувствовать себя спокойно при написании примерно
такого кода: <div class="lisp"><tt><div class="tabbing">
(defun wargames:no-win-scenario ()
   <br>              (when (true) (error &#x0022;Pushing the button would be stupid.&#x0022;))<br>
  (push-the-button))<br>
<!--l. 3131--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3132--><p class="indent" >   В этом сценарии, нет никаких шансов на то, что функция <b><a 
href="symbols.html#x200-396383r383">error</a></b> вернёт
управление, и кнопка будет нажата.
_____________________________________
<!--l. 3136--><p class="noindent" ><b>Примечание:</b> It should be noted that the notion of “no chance” that the button will be
pushed is relative only to the language model; it assumes that the language is accurately
implemented. In practice, compilers have bugs, computers have glitches, and users have
been known to interrupt at inopportune moments and use the debugger to return from
arbitrary stack frames. Such violations of the language model are beyond the scope of
the condition system but not necessarily beyond the scope of potential failures that the
programmer should consider and defend against. The possibility of such unusual
failures may of course also inﬂuence the design of code meant to handle less
drastic situations, such as maintaining a database uncorrupted.—KMP and GLS__
                                                                          

                                                                          
<!--l. 3151--><p class="indent" >   В некоторых случаях, программист может один, хорошо продуманный
план о том, что делать в случае ошибки. В этом случае, он может
использовать функцию <b><a 
href="symbols.html#x200-396213r213">cerror</a></b>, которая указывает информацию о том,
что произойдёт, если пользователь просто нажмёт «продолжить» и
выполнение продолжиться сразу за вызовом этой функции. Например:
<div class="lisp"><tt><div class="tabbing">
Lisp&#x003E; (defun factorial (x)
   <br>                                                  (cond ((not (typep x &#x2019;integer))<br>
               (error &#x0022;~S is not a valid argument to FACTORIAL.&#x0022;<br>
                      x))<br>
              ((minusp x)<br>                  (let ((x-magnitude (- x)))<br>
                 (cerror &#x0022;Compute -(~D!) instead.&#x0022;<br>
                         &#x0022;(-~D)! is not deﬁned.&#x0022; x-magnitude)<br>
                 (- (factorial x-magnitude))))<br>
              ((zerop x) 1)<br>               (t (* x (factorial (- x 1))))))<br>
 <span class="math"> ⇒</span> FACTORIAL<br>      Lisp&#x003E; (factorial -3)<br>      Error: (-3)! is not deﬁned.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Compute -(3!) instead.<br>  2: Return to Lisp Toplevel.<br> Debug&#x003E; :continue 1<br>
 <span class="math"> ⇒</span> -6<br>
<!--l. 3176--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3178--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.2   </span> <a 
href="frontmatter.html#QQ2-192-368" id="x192-32400029.3.2">Перехват ошибок</a></h4>
<!--l. 3181--><p class="noindent" >По умолчанию, вызов <b><a 
href="symbols.html#x200-396383r383">error</a></b> приведёт к вмешательству отладчика. Но вы
можете различными способами воспрепятствовать этому поведению. Самый
простой (и самый грубый) инструмент для исключения вмешательства
отладчика — использование <b><a 
href="symbols.html#x200-396489r489">ignore-errors</a></b>. В обычной ситуации, формы в
теле <b><a 
href="symbols.html#x200-396489r489">ignore-errors</a></b> вычисляются последовательно и возвращает значение
последней из них. Если сигнализируется ошибка <b><a 
href="symbols.html#x200-396383r383">error</a></b>, <b><a 
href="symbols.html#x200-396489r489">ignore-errors</a></b>
немедленно возвращает два значение, <b><a 
href="symbols.html#x200-396670r670">nil</a></b> и условие, которое было
сигнализировано. Отладчик не вызывается и никакого сообщения об ошибке
не выводится. Например: <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
Lisp&#x003E; (setq ﬁlename &#x0022;nosuchﬁle&#x0022;)
   <br> <span class="math"> ⇒</span> &#x0022;nosuchﬁle&#x0022;<br>Lisp&#x003E; (ignore-errors (open ﬁlename :direction :input))<br>
 <span class="math"> ⇒</span> NIL and #&#x003C;FILE-ERROR 3437523&#x003E;<br>
<!--l. 3195--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3196--><p class="indent" >   Второе возвращённое значение является объектом, отображающим тип
ошибки. Он подробнее описан в разделе <a 
href="#x192-32600029.3.4">29.3.4<!--tex4ht:ref: OBJECT-0RIENTED-BASIS --></a>.
<!--l. 3199--><p class="indent" >   Однако, в большинстве случае <b><a 
href="symbols.html#x200-396489r489">ignore-errors</a></b> не желательна, так как она
обрабатывает слишком много типов ошибок. В отличие от утверждений
некоторых людей, программа, которая не вызывает отладчик не обязательно
лучше той, которая вызывает. Чрезмерное использование <b><a 
href="symbols.html#x200-396489r489">ignore-errors</a></b>
может удерживать программу от вмешательства отладчика, но надёжность
программы от этого не увеличится, потому что программа может
продолжить выполнение после ошибок, которые вами не учитывались. В
целом, лучше попытаться обработать ряд ошибок, которые, как вы уверены,
обязательно могут случиться. Таким образом, при появлении не ожидаемых
ошибок, вы сможете о них узнать.
<b>
<!--l. 3210--><p class="indent" >   <a 
href="symbols.html#x200-396489r489">ignore-errors</a></b> является полезным частным случаем от более общей
функциональности, <b><a 
href="symbols.html#x200-396479r479">handler-case</a></b>, которая позволяет программистам
обрабатывать отдельные виды условий (включая не ошибочные условия) без
указания того, что произойдёт при сигнализировании других видов условий.
Например, эквивалентный код, как если бы использовалась <b><a 
href="symbols.html#x200-396489r489">ignore-errors</a></b>,
представлен в следующем примере: <div class="lisp"><tt><div class="tabbing">
Lisp&#x003E; (setq ﬁlename &#x0022;nosuchﬁle&#x0022;)
   <br>  <span class="math"> ⇒</span> &#x0022;nosuchﬁle&#x0022;<br> Lisp&#x003E; (handler-case (open ﬁlename :direction :input)<br>
        (error (condition)<br>                       (values nil condition)))<br>
 <span class="math"> ⇒</span> NIL and #&#x003C;FILE-ERROR 3437525&#x003E;<br>
<!--l. 3223--><p class="noindent" ></div>
</tt>
</div>
                                                                          

                                                                          
<!--l. 3224--><p class="indent" >   Однако, при использовании <b><a 
href="symbols.html#x200-396479r479">handler-case</a></b> можно указать более
специфичный тип условия, чем просто «error». Типы условий освещены будут
освещены более подробно позже, но синтаксис примерно выглядит так:
<div class="lisp"><tt><div class="tabbing">
Lisp&#x003E; (makunbound &#x2019;ﬁlename)
   <br>  <span class="math"> ⇒</span> FILENAME<br> Lisp&#x003E; (handler-case (open ﬁlename :direction :input)<br>
        (ﬁle-error (condition)<br>                    (values nil condition)))<br>
Error: The variable FILENAME is unbound.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Retry getting the value of FILENAME.<br>
 2: Specify a value of FILENAME to use this time.<br>
 3: Specify a value of FILENAME to store and use.<br>
 4: Return to Lisp Toplevel.<br>                                       Debug&#x003E;<br>
<!--l. 3240--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3242--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.3   </span> <a 
href="frontmatter.html#QQ2-192-369" id="x192-32500029.3.3">Обработка условий</a></h4>
<!--l. 3245--><p class="noindent" >Слепая передача управления в <b><a 
href="symbols.html#x200-396479r479">handler-case</a></b> является единственно
возможным способом восстановить работу после сигнализирования условия.
Низкоуровневый механизм предоставляет большую гибкость в том,
как продолжить выполнение программы после сигнализирования
условия.
<!--l. 3250--><p class="indent" >   Основная идея в обработке условия в том, что часть кода, называемого
<em>сигнальщик</em>, распознаёт и объявление возникновение исключительной
ситуации с помощью <b><a 
href="symbols.html#x200-396854r854">signal</a></b> или другой функции на основе <b><a 
href="symbols.html#x200-396854r854">signal</a></b> (такой как
<b><a 
href="symbols.html#x200-396383r383">error</a></b>).
<!--l. 3255--><p class="indent" >   Процесс сигнализирования включает поиск для и запуск <em>обработчика</em> -
части кода, который будет пытаться соответственно справиться с
ситуацией.
<!--l. 3258--><p class="indent" >   Если обработчик найден, он может или <em>обработать</em> ситуацию с помощью
некоторой нелокальной передачи управления, или <em>отклонить</em> обработку
                                                                          

                                                                          
ситуации с помощью отказа от выполнения нелокальной передачи
управления. Если он отклонил обработку, будет выполнен поиск других
обработчиков.
<!--l. 3263--><p class="indent" >   Так как лексическое окружение сигнальщика может быть не доступным
для обработчика, для отображения состояния ситуации создаётся
структура, называемая <em>условие</em>. Условие может быть создано как
явным вызовом <b><a 
href="symbols.html#x200-396591r591">make-condition</a></b> и передачей в функцию, например,
<b><a 
href="symbols.html#x200-396854r854">signal</a></b>, так и неявно в функции <b><a 
href="symbols.html#x200-396854r854">signal</a></b> при использовании других
аргументов.
<!--l. 3269--><p class="indent" >   При обработке ошибки, обработчик может использовать любой
нелокальный выход (нелокальную передачу управления), такой как <b><a 
href="symbols.html#x200-396476r476">go</a></b> на тег
в <b><a 
href="symbols.html#x200-396952r952">tagbody</a></b>, <b><a 
href="symbols.html#x200-396816r816">return</a></b> из <b><a 
href="symbols.html#x200-396148r148">block</a></b>, или <b><a 
href="symbols.html#x200-396961r961">throw</a></b> в <b><a 
href="symbols.html#x200-396193r193">catch</a></b>. Кроме того, для удобства в
обработке исключений над этими примитивами созданы структурированные
абстракции.
<!--l. 3275--><p class="indent" >   Обработчик может быть динамически доступным для программы
если создать его с помощью <b><a 
href="symbols.html#x200-396478r478">handler-bind</a></b>. Например, для создания
обработчика для условия типа <b><a 
href="symbols.html#x200-396106r106">arithmetic-error</a></b>, можно записать:
<div class="lisp"><tt><div class="tabbing">
(handler-bind ((arithmetic-error <em>handler</em>))<em>body</em>)
   <br>
<!--l. 3287--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3288--><p class="indent" >   Обработчик является функцией одного аргумента, а, именно, условия.
Если во время выполнения форм <em>body</em> сигнализируется условие указанного
типа (и внутри не было установленных обработчиков условия), будет вызван
данный обработчик с данным условием, позволяя последнему передать
управление куда-либо. Например, можно записать макрос, который
выполняет тело, возвращая его значение(я) или два значения: <b><a 
href="symbols.html#x200-396670r670">nil</a></b> и объект
условия. <div class="lisp"><tt><div class="tabbing">
(defmacro without-arithmetic-errors (&#x0026;body forms)
                                                                          

                                                                          
   <br>                                                                  (let ((tag (gensym)))<br>
    ‘(block ,tag<br>                          (handler-bind ((arithmetic-error<br>
                         #&#x2019;(lambda (c)     ;Argument <b>c</b> is a condition<br>
                             (return-from ,tag (values nil c)))))<br>
         ,@body))))<br>                                                     <br>
<!--l. 3302--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3304--><p class="indent" >   Обработчик выполняется в динамическом контексте сигнальщика, за
исключением того, что множество доступных обработчиков условий будут
пересвязаны со значениями, которые были активны во время того
как активизировался данный обработчик. Если обработчик отклонил
(отказался) от обработки (то есть, не передал управление), то выбираются
другие обработчики. Если обработчик не был найден и условия было
сигнализировано с помощью <b><a 
href="symbols.html#x200-396383r383">error</a></b> или <b><a 
href="symbols.html#x200-396213r213">cerror</a></b> (или некоторой функции,
такой как <b><a 
href="symbols.html#x200-396127r127">assert</a></b>, которая ведёт себя также как названные), в работу
вмешивается отладчик и работает в этом же динамическом контексте
сигнальщика.
<!--l. 3314--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.4   </span> <a 
href="frontmatter.html#QQ2-192-370" id="x192-32600029.3.4">Объектно-ориентированные концепции обработки условий</a></h4>
<!--l. 3317--><p class="noindent" >Естественно, возможность обработчика качественно обработать
исключительную ситуацию зависит от того, какой полноты информацию
она предоставляет. Например, если все ошибки сигнализируется так:
<div class="lisp"><tt><div class="tabbing">
(error &#x0022;<em>some format string</em>&#x0022;)
   <br>
<!--l. 3322--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3323--><p class="indent" >   тогда всё что получит обработчик - объект типа <b><a 
href="symbols.html#x200-396860r860">simple-error</a></b>, в котором
есть слот со строкой.
                                                                          

                                                                          
<!--l. 3326--><p class="indent" >   Если пользоваться только таким способом, то для различия ошибок
придётся пользоваться функцией <b><a 
href="symbols.html#x200-396911r911">string-equal</a></b>, и при каждом изменении
строки об ошибке менять все сравнения в обработчиках, что не очень-то
способствует самочувствию программиста. Этот феномен был самым
большим фейлом в предыдущей системе обработки ошибок в Lisp&#x2019;е.
Принципиально важно отделить строки сообщений об ошибках (человеческий
интерфейс) от объектов, которые формально представляют состояние
ошибки (программный интерфейс). Таким образом мы имеем понятие
типизированных условий и формальные операции над этими условиями,
которые позволяют структурировано инспектировать эти условия.
<!--l. 3336--><p class="indent" >   Этот объектно-ориентированный подход в обработке условий имеет
следующие важные преимущества по сравнению с текстовым подходом:
      <ul class="itemize1">
      <li class="itemize">Условия   классифицируются   в   соответствии   с   отношениями
      подтипов, что делает лёгким проверку категории условия.
      </li>
      <li class="itemize">У условий есть слоты со значениями, через которые передаются
      параметры от программы, сигнализирующей ошибку в программу,
      которая её обрабатывает.
      </li>
      <li class="itemize">Наследование                              методов                              и
      слотов уменьшает количество явных спецификаций, необходимых
      для достижения интересных эффектов.</li></ul>
<!--l. 3349--><p class="indent" >   Некоторые типы условий определяются в этом документе, но их
множество может расширяться с помощью <b><a 
href="symbols.html#x200-396314r314">deﬁne-condition</a></b>. Common
Lisp&#x2019;овые типы условий фактически являются CLOS классами, и объекты
условий являются простыми CLOS объектами. <b><a 
href="symbols.html#x200-396314r314">deﬁne-condition</a></b> просто
предоставляет интерфейс абстракции, который для определения условий
чуть более удобен, чем <b><a 
href="symbols.html#x200-396310r310">defclass</a></b>.
<!--l. 3356--><p class="indent" >   Вот простой пример, мы определяем функцию двух аргументов <b>divide</b>,
которая похожа на функцию <b><a 
href="symbols.html#x200-396065r65">/</a></b>, но сигнализирует чуть стилизованные
сообщения об ошибках: <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(defun divide (numerator denominator)
   <br>                                           (cond ((or (not (numberp numerator))<br>
             (not (numberp denominator)))<br>
         (error &#x0022;(DIVIDE &#x2019;~S &#x2019;~S) - Bad arguments.&#x0022;<br>
                numerator denominator))<br>        ((zerop denominator)<br>
         (error &#x2019;division-by-zero<br>                      :operator &#x2019;divide<br>
                :operands (list numerator denominator)))<br>
        (t ...)))<br>
<!--l. 3370--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3371--><p class="indent" >   Следует отметить, что в первом выражении мы использовали <b><a 
href="symbols.html#x200-396383r383">error</a></b> со
строковым аргументом и во втором выражении мы указали конкретный
тип условия, <b><a 
href="symbols.html#x200-396346r346">division-by-zero</a></b>. В случае строкового аргумент, тип
сигнализируемого условия будет <b><a 
href="symbols.html#x200-396860r860">simple-error</a></b>.
<!--l. 3376--><p class="indent" >   Конкретный вид сигнализируемой ошибки может быть важен в
зависимости от того где находятся активные обработчики. Например,
<b><a 
href="symbols.html#x200-396860r860">simple-error</a></b> наследуется от типа <b><a 
href="symbols.html#x200-396383r383">error</a></b>, которая в свою очередь наследуется
от типа <b><a 
href="symbols.html#x200-396282r282">condition</a></b>. С другой стороны, <b><a 
href="symbols.html#x200-396346r346">division-by-zero</a></b> наследуется от
<b><a 
href="symbols.html#x200-396106r106">arithmetic-error</a></b>, которая наследуется от <b><a 
href="symbols.html#x200-396383r383">error</a></b>, которая наследуется от
<b><a 
href="symbols.html#x200-396282r282">condition</a></b>. Так что, если существует обработчик для <b><a 
href="symbols.html#x200-396106r106">arithmetic-error</a></b> в
момент когда сигнализируется <b><a 
href="symbols.html#x200-396346r346">division-by-zero</a></b>, тогда этот обработчик
будет вызван. Однако если в том же контексте будет вызвана <b><a 
href="symbols.html#x200-396860r860">simple-error</a></b>,
тип обработчика <b><a 
href="symbols.html#x200-396106r106">arithmetic-error</a></b> вызываться не будет.
<!--l. 3386--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.5   </span> <a 
href="frontmatter.html#QQ2-192-371" id="x192-32700029.3.5">Перезапуски (рестарты)</a></h4>
<!--l. 3388--><p class="noindent" >Common Lisp&#x2019;овая система условий создаёт чёткое разграничение между
сигнализированием ошибки определённого типа и сообщением о том, как
соответственно восстанавливать выполнение программы. В приведённом
выше примере с <b>divide</b> просто сигнализирование ошибки не означает
готовность сигнализатора к сотрудничеству в каких-либо корректирующих
действиях. Например, следующий пример взаимодействия показывает, что
для восстановление предлагается только «Вернуться на верхний уровень».
<div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
Lisp&#x003E; (+ (divide 3 0) 7)
   <br>                                                    Error: Attempt to divide 3 by 0.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Return to Lisp Toplevel.<br> Debug&#x003E; :continue 1<br> Returned to Lisp Toplevel.<br>
Lisp&#x003E;<br>
<!--l. 3403--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3404--><p class="indent" >   При обнаружении ошибки и была вызвана функция <b><a 
href="symbols.html#x200-396383r383">error</a></b>, выполнение не
может нормально продолжаться, потому что <b><a 
href="symbols.html#x200-396383r383">error</a></b> не будет непосредственно
возвращать управление. Управление может быть передано в другие
точки программы, однако, с помощью специально установленного
«перезапуска».
<!--l. 3409--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.6   </span> <a 
href="frontmatter.html#QQ2-192-372" id="x192-32800029.3.6">Анонимные перезапуски (рестарты)</a></h4>
<!--l. 3411--><p class="noindent" >Самый простой вид перезапуска включает в себя структурированную
передачу управления с помощью макроса с именем <b><a 
href="symbols.html#x200-396814r814">restart-case</a></b>. Форма
<b><a 
href="symbols.html#x200-396814r814">restart-case</a></b> позволяет выполнять кусок кода в контексте, где активны ноль
или более перезапусков, и где, если один из этих перезапусков будет
«вызван», управление будет передано на соответствующий пункт в
<b><a 
href="symbols.html#x200-396814r814">restart-case</a></b> формы. Например, мы могли бы переписать предыдущую
функцию <b>divide</b> например, следующим образом. <div class="lisp"><tt><div class="tabbing">
(defun divide (numerator denominator)
   <br>                                 (loop<br>                                   (restart-case<br>
        (return<br>                  (cond ((or (not (numberp numerator))<br>
                     (not (numberp denominator)))<br>
                 (error &#x0022;(DIVIDE &#x2019;~S &#x2019;~S) - Bad arguments.&#x0022;<br>
                         numerator denominator))<br>
                ((zerop denominator)<br>                 (error &#x2019;division-by-zero<br>
                        :operator &#x2019;divide<br>                        :operands (list numerator denominator)))<br>
                                                                          

                                                                          
                (t ...)))<br>                                (nil (arg1 arg2)<br>
          :report &#x0022;Provide new arguments for use by DIVIDE.&#x0022;<br>
          :interactive<br>                                       (lambda ()<br>
               (list (prompt-for &#x2019;number &#x0022;Numerator: &#x0022;)<br>
                     (prompt-for &#x2019;number &#x0022;Denominator: &#x0022;)))<br>
        (setq numerator arg1 denominator arg2))<br>            (nil (result)<br>
          :report &#x0022;Provide a value to return from DIVIDE.&#x0022;<br>
          :interactive<br>            (lambda () (list (prompt-for &#x2019;number &#x0022;Result: &#x0022;)))<br>
        (return result)))))<br>
<!--l. 3444--><p class="noindent" ></div>
</tt>
</div>
__________________________________________________________________________
<!--l. 3447--><p class="noindent" ><b>Примечание:</b> The function <b>prompt-for</b> used in this chapter in a number of places is
not a part of Common Lisp. It is used in the examples in this chapter only
to keep the presentation simple. It is assumed to accept a type speciﬁer and
optionally a format string and associated arguments. It uses the format string and
associated arguments as part of an interactive prompt, and uses <b><a 
href="symbols.html#x200-396778r778">read</a></b> to read a Lisp
object; however, only an object of the type indicated by the type speciﬁer is
accepted.
<!--l. 3456--><p class="indent" >     The question of whether or not <b>prompt-for</b> (or something like it) would be
a useful addition to Common Lisp is under consideration by X3J13, but as
of January 1989 no action has been taken. In spite of its use in a number of
examples, nothing in the Common Lisp Condition System depends on this function.
<!--l. 3463--><p class="indent" >     В примере, <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, указанный в начале каждого выражения, означает,
что это «анонимный» перезапуск. Анонимные перезапуски обычно
вызываются только из отладчика. Мы покажем позже, что возможно иметь
«именованный перезапуск», который может быть вызван из кода, без
необходимости пользовательского вмешательства.
<!--l. 3469--><p class="indent" >     Если аргументы для анонимного перезапуска являются обязательными,
тогда должна быть предоставлена специальная информация о том, что
отладчик должен использовать в качестве аргументов. Здесь для указания
этой информации используется ключевой символ <b>:interactive</b>.
<!--l. 3474--><p class="indent" >     Ключевое слово <b>:report</b> представляет информацию, для использования
когда предоставляет параметр перезапуска пользователю (в отладчике,
                                                                          

                                                                          
например).
<!--l. 3477--><p class="indent" >   Вот простое взаимодействие, которое использует перезапуски
предоставленные изменённой версией <b>divide</b>: <div class="lisp"><tt><div class="tabbing">
Lisp&#x003E; (+ (divide 3 0) 7)
   <br>                                                    Error: Attempt to divide 3 by 0.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Provide new arguments for use by the DIVIDE function.<br>
 2: Provide a value to return from the DIVIDE function.<br>
 3: Return to Lisp Toplevel.<br>             Debug&#x003E; :continue 1<br>             1<br>
Numerator: 4<br>                                              Denominator: 2<br>
 <span class="math"> ⇒</span> 9<br>
<!--l. 3491--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3493--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.7   </span> <a 
href="frontmatter.html#QQ2-192-373" id="x192-32900029.3.7">Именованные перезапуски (рестарты)</a></h4>
<!--l. 3495--><p class="noindent" >В дополнение к анонимным перезапускам, можно задавать перезапуски с
именами, которые могут быть вызваны из кода, используя это имя. В
качестве простейшего примера, для сложения <b>3</b> и <b>1</b> и возвращения <b>4</b>, можно
записать: <div class="lisp"><tt><div class="tabbing">
(restart-case (invoke-restart &#x2019;foo 3)
   <br>                                                                       (foo (x) (+ x 1)))<br>
<!--l. 3501--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3502--><p class="indent" >   Этот пример концептуально аналогичен следующему: <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(+ (catch &#x2019;something (throw &#x2019;something 3)) 1)
   <br>
<!--l. 3505--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3507--><p class="indent" >   Для более реалистичного примера, код функции <b><a 
href="symbols.html#x200-396948r948">symbol-value</a></b> может
сигнализировать ошибку несвязанной переменной так: <div class="lisp"><tt><div class="tabbing">
(restart-case (error &#x0022;The variable ~S is unbound.&#x0022; variable)
   <br>                                                                              (continue ()<br>
      :report<br>                    (lambda (s)     ;Аргумент <b>s</b> — поток<br>
          (format s &#x0022;Retry getting the value of ~S.&#x0022; variable))<br>
    (symbol-value variable))<br>                            (use-value (value)<br>
      :report<br>                    (lambda (s)     ;Аргумент <b>s</b> — поток<br>
          (format s &#x0022;Specify a value of ~S to use this time.&#x0022;<br>
                  variable))<br>          value)<br>        (store-value (value)<br>
      :report<br>                    (lambda (s)     ;Аргумент <b>s</b> — поток<br>
          (format s &#x0022;Specify a value of ~S to store and use.&#x0022;<br>
                  variable))<br>        (setf (symbol-value variable) value)<br>
    value))<br>
<!--l. 3529--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3530--><p class="indent" >   Если это будет частью реализации <b><a 
href="symbols.html#x200-396948r948">symbol-value</a></b>, тогда пользователи
смогут писать разные автоматические обработчики ошибок о несвязанных
переменных. Например, для вычисления несвязанной переменной самой в
себя, можно записать: <div class="lisp"><tt><div class="tabbing">
(handler-bind ((unbound-variable
   <br>                           #&#x2019;(lambda (c)     ;Аргумент <b>c</b> — условие<br>
                     (when (ﬁnd-restart &#x2019;use-value)<br>
                       (invoke-restart &#x2019;use-value<br>
                                       (cell-error-name c))))))<br>
  <em>body</em>)<br>
                                                                          

                                                                          
<!--l. 3541--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3543--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.8   </span> <a 
href="frontmatter.html#QQ2-192-374" id="x192-33000029.3.8">Функции перезапусков (рестартов)</a></h4>
<!--l. 3545--><p class="noindent" >Для частого использования перезапусков, удобно определить программный
интерфейс, который будет скрывать использование <b><a 
href="symbols.html#x200-396510r510">invoke-restart</a></b>.
Такой программный интерфейс для перезапусков называется <em>restart
functions</em>.
<!--l. 3549--><p class="indent" >   Обычно функция имеет такое же имя, что и перезапуск. Предопределённые
функции <b><a 
href="symbols.html#x200-396081r81">abort</a></b>, <b><a 
href="symbols.html#x200-396288r288">continue</a></b>, <b><a 
href="symbols.html#x200-396654r654">muﬄe-warning</a></b>, <b><a 
href="symbols.html#x200-396902r902">store-value</a></b> и <b><a 
href="symbols.html#x200-396996r996">use-value</a></b>
являются функциями перезапусков. Предыдущий пример может быть
записан с использованием <b><a 
href="symbols.html#x200-396996r996">use-value</a></b>: <div class="lisp"><tt><div class="tabbing">
(handler-bind ((unbound-variable
   <br>                      #&#x2019;(lambda (c)     ;Argument <b>c</b> is a condition<br>
                       (use-value (cell-error-name c)))))<br>         <em>body</em>)<br>
<!--l. 3558--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3560--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.9   </span> <a 
href="frontmatter.html#QQ2-192-375" id="x192-33100029.3.9">Сравнение перезапусков и catch/throw</a></h4>
<!--l. 3562--><p class="noindent" >Одна важная возможность в том, что предоставляет <b><a 
href="symbols.html#x200-396814r814">restart-case</a></b> (или
<b><a 
href="symbols.html#x200-396813r813">restart-bind</a></b>), и не предоставляет <b><a 
href="symbols.html#x200-396193r193">catch</a></b>, это получение информации о
доступных точках для передачи управления без самой попытки передачи.
Можно например написать так: <div class="lisp"><tt><div class="tabbing">
(ignore-errors (throw ...))
   <br>
                                                                          

                                                                          
<!--l. 3568--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3569--><p class="indent" >   что является обеднённой реализацией <div class="lisp"><tt><div class="tabbing">
(when (ﬁnd-restart &#x2019;something)
   <br>                                                         (invoke-restart &#x2019;something))<br>
<!--l. 3573--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3574--><p class="indent" >   однако с помощью <b><a 
href="symbols.html#x200-396489r489">ignore-errors</a></b> и <b><a 
href="symbols.html#x200-396961r961">throw</a></b> невозможно реализовать
следующий код: <div class="lisp"><tt><div class="tabbing">
(when (and (ﬁnd-restart &#x2019;something)
   <br>                                                  (ﬁnd-restart &#x2019;something-else))<br>
  (invoke-restart &#x2019;something))<br>
<!--l. 3580--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3581--><p class="indent" >   или даже такой: <div class="lisp"><tt><div class="tabbing">
(when (and (ﬁnd-restart &#x2019;something)
   <br>                                              (yes-or-no-p &#x0022;Do something? &#x0022;))<br>
  (invoke-restart &#x2019;something))<br>
<!--l. 3586--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3587--><p class="indent" >   так как уровень инспекции кода в простом коде <div class="lisp"><tt><div class="tabbing">
(ignore-errors (throw ...))
   <br>
                                                                          

                                                                          
<!--l. 3590--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3591--><p class="indent" >   слишком примитивный — после получения информации о переходе,
немедленно производится и сам переход.
<!--l. 3594--><p class="indent" >   Многие программисты используют ранее развивающуюся стратегию, как
например: <div class="lisp"><tt><div class="tabbing">
(defvar *foo-tag-is-available* nil)
   <br>                                                                                               <br>
(defun fn-1 ()<br>                                                  (catch &#x2019;foo<br>
    (let ((*foo-tag-is-available* t))<br>                         ... (fn-2) ...)))<br>
<br>                                                             (defun fn-2 ()<br>
  ...<br>                               (if *foo-tag-is-available* (throw &#x2019;foo t))<br>
  ...)<br>
<!--l. 3607--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3608--><p class="indent" >   Функциональность от <b><a 
href="symbols.html#x200-396814r814">restart-case</a></b> и <b><a 
href="symbols.html#x200-396421r421">ﬁnd-restart</a></b> предназначена для
стандартизированного протокол для такого типа информации, при
коммуникации между написанными независимо друг от друга программами.
Поэтому модульность и возможность отладки для этих программ не
нарушаются.
<!--l. 3613--><p class="indent" >   Другое отличие между функциональностями перезапусков и <b><a 
href="symbols.html#x200-396193r193">catch</a></b>/<b><a 
href="symbols.html#x200-396961r961">throw</a></b>
заключается в том, что <b><a 
href="symbols.html#x200-396193r193">catch</a></b> с некоторым тегом полностью скрывают
любые внешние формы <b><a 
href="symbols.html#x200-396193r193">catch</a></b> с одноимённым тегом. Из-за наличия
<b><a 
href="symbols.html#x200-396277r277">compute-restarts</a></b>, есть возможность для просмотра скрытых перезапусков,
которые могут быть полезны в некоторых ситуациях (в частности в
интерактивном отладчике).
<!--l. 3620--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.10   </span> <a 
href="frontmatter.html#QQ2-192-376" id="x192-33200029.3.10">Обобщённые перезапуски</a></h4>
<b>
                                                                          

                                                                          
<!--l. 3623--><p class="noindent" ><a 
href="symbols.html#x200-396814r814">restart-case</a></b> является механизмом, который поддерживает только
императивную передачу управления в связанные перезапуски. <b><a 
href="symbols.html#x200-396814r814">restart-case</a></b>
построена на низкоуровневом механизме с названием <b><a 
href="symbols.html#x200-396813r813">restart-bind</a></b>, который
не принуждает к передаче управления.
<b>
<!--l. 3628--><p class="indent" >   <a 
href="symbols.html#x200-396813r813">restart-bind</a></b> для <b><a 
href="symbols.html#x200-396814r814">restart-case</a></b>, как <b><a 
href="symbols.html#x200-396478r478">handler-bind</a></b> для <b><a 
href="symbols.html#x200-396479r479">handler-case</a></b>.
Синтаксис выглядит так: <div class="lisp"><tt><div class="tabbing">
(restart-bind ((<em>name</em> <em>function</em> . <em>options</em>)) . <em>body</em>)
   <br>
<!--l. 3633--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3634--><p class="indent" >   Формы <em>body</em> выполняются в динамическом окружении, внутри
которого будет вызвана функция <em>function</em>, где бы ни была вызвана
форма <b>(invoke-restart &#x2019;<em>name</em>)</b>. Аргументы <em>options</em> перечисляются с
помощью ключевых символом и используются для передачи информации,
такой, например, какую предоставляет ключевой символ <b>:report</b> в
<b><a 
href="symbols.html#x200-396814r814">restart-case</a></b>.
<b>
<!--l. 3641--><p class="indent" >   <a 
href="symbols.html#x200-396814r814">restart-case</a></b> раскрывается в вызов <b><a 
href="symbols.html#x200-396813r813">restart-bind</a></b>, где функция просто
делает безусловную передачу выполнения в конкретный код, указывая при
этом в структурированном виде «аргументную» информацию.
<!--l. 3645--><p class="indent" >   Можно также записывать перезапуски, которые не передают управления.
Такие перезапуски могут быть полезны для реализации различных
специальных команд для отладчика, которые представляют интерес только в
конкретной ситуации. Например, можно представить ситуацию, в которой
для файлов закончилось место и для продолжения операции было
освобождено место в директории <b>dir</b>: <div class="lisp"><tt><div class="tabbing">
(restart-bind ((nil #&#x2019;(lambda () (expunge-directory dir))
   <br>                                                               :report-function<br>
                      #&#x2019;(lambda (stream)<br>
                          (format stream &#x0022;Expunge ~A.&#x0022;<br>
                                                                          

                                                                          
                                  (directory-namestring dir)))))<br>
  (cerror &#x0022;Try this ﬁle operation again.&#x0022;<br>
          &#x2019;directory-full :directory dir))<br>
<!--l. 3658--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3659--><p class="indent" >   В этом случае, должен вмешаться отладчик и пользователь сначала
освободит место (это не приводит к передаче управления из отладчика
куда-либо) и затем повторит операцию: <div class="lisp"><tt><div class="tabbing">
Lisp&#x003E; (open &#x0022;FOO&#x0022; :direction :output)
   <br>                                         Error: The directory PS:&#x003C;JDOE&#x003E; is full.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Try this ﬁle operation again.<br>                 2: Expunge PS:&#x003C;JDOE&#x003E;.<br>
 3: Return to Lisp Toplevel.<br>                           Debug&#x003E; :continue 2<br>
Expunging PS:&#x003C;JDOE&#x003E; ... 3 records freed.<br>            Debug&#x003E; :continue 1<br>
 <span class="math"> ⇒</span> #&#x003C;OUTPUT-STREAM &#x0022;PS:&#x003C;JDOE&#x003E;FOO.LSP&#x0022; 2323473&#x003E;<br>
<!--l. 3672--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3674--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.11   </span> <a 
href="frontmatter.html#QQ2-192-377" id="x192-33300029.3.11">Интерактивная обработка условий</a></h4>
<!--l. 3676--><p class="noindent" >Когда программа не знает как продолжить выполнение, и нет активных
обработчиков, которые могли бы дать совет по этому поводу, тогда может
придти «интерактивный обработчик условий» или, другими словами,
«отладчик». Это неявно происходит при использовании таких функций, как
<b><a 
href="symbols.html#x200-396383r383">error</a></b> и <b><a 
href="symbols.html#x200-396213r213">cerror</a></b>, или явно с помощью функции <b><a 
href="symbols.html#x200-396509r509">invoke-debugger</a></b>.
<!--l. 3682--><p class="indent" >   Интерактивный обработчик условий никогда не возвращает управления
напрямую. Он возвращает управление с помощью нелокальной
структурированной передачи управления в специально определённые точки
перезапуска, которые могли быть установлены как системой, так и
пользовательским кодом. Механизмы, которые поддерживают создание
                                                                          

                                                                          
таких структурированных точек перезапуска для портируемого кода
изложены в разделах с <a 
href="#x192-32700029.3.5">29.3.5<!--tex4ht:ref: RESTARTS --></a> по <a 
href="#x192-33200029.3.10">29.3.10<!--tex4ht:ref: LAST-RESTARTS-SECTION --></a>.
<!--l. 3689--><p class="indent" >   Фактически, реализации могут также содержать расширенную
функциональность для отладки, которая позволяет возврат из
произвольного фрейма стека. Не смотря на то, такие команды часто
полезны на практике, их действия зависят от реализации, потому что
они нарушают абстрагированность Common Lisp&#x2019;овой программы.
Результаты использования таких команд настоящим стандартом не
определены.
<!--l. 3696--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.12   </span> <a 
href="frontmatter.html#QQ2-192-378" id="x192-33400029.3.12">Важные условия</a></h4>
<!--l. 3698--><p class="noindent" >Макрос <b><a 
href="symbols.html#x200-396489r489">ignore-errors</a></b> будет ловить условия типа <b><a 
href="symbols.html#x200-396383r383">error</a></b>. Однако существуют
также условия других типов.
<!--l. 3701--><p class="indent" >   Некоторые условия не считаются ошибками, но всё равно являются
важными. Такие условия называются <em>важными условиями</em>, и для их
представления используется тип <b><a 
href="symbols.html#x200-396835r835">serious-condition</a></b>. Условия, которые,
например, могут сигнализироваться для «переполнения стека» или
«исчерпанности хранилища», относятся к данной категории.
<!--l. 3707--><p class="indent" >   Тип <b><a 
href="symbols.html#x200-396383r383">error</a></b> является подтипом <b><a 
href="symbols.html#x200-396835r835">serious-condition</a></b>, и технически было бы
правильным использовать термин «важное условие» для ссылки на все
важные условия, будь то ошибки или нет. Однако, обычно мы используется
термин «важное условие» для ссылки на вещи типа <b><a 
href="symbols.html#x200-396835r835">serious-condition</a></b>, но не
типа <b><a 
href="symbols.html#x200-396383r383">error</a></b>.
<!--l. 3713--><p class="indent" >   Смысл в разницу между ошибками и другими серьёзными условиями в
том, что некоторые условия возникают по причинам, которые выходят за
рамки Common Lisp&#x2019;а. Например, мы знаем, что стек обычно используется
для реализации вызова функций, и мы знаем, что стеки имеют конечный
размер и могут переполнятся. Так как размер стека может меняться от
реализации к реализации, от сессии к сессии, или от вызова к вызову
функции, то выражение <b>(ignore-errors (+ a b))</b>, которое будет возвращать
разные значения, в определённый момент, например, из-за переполнения
стека. Поэтому, <b><a 
href="symbols.html#x200-396489r489">ignore-errors</a></b> ловит условия только типа <b><a 
href="symbols.html#x200-396383r383">error</a></b>, но не все
<b><a 
href="symbols.html#x200-396835r835">serious-condition</a></b>. Для обработки других условий может быть использована
низкоуровневая функциональность (такая как <b><a 
href="symbols.html#x200-396478r478">handler-bind</a></b> или
<b><a 
href="symbols.html#x200-396479r479">handler-case</a></b>).
                                                                          

                                                                          
<!--l. 3725--><p class="indent" >   По соглашению, для сигнализирования условий типа <b><a 
href="symbols.html#x200-396835r835">serious-condition</a></b>
(включая <b><a 
href="symbols.html#x200-396383r383">error</a></b>) функция <b><a 
href="symbols.html#x200-396383r383">error</a></b> предпочтительнее чем <b><a 
href="symbols.html#x200-396854r854">signal</a></b>. It is the use of
the function <b><a 
href="symbols.html#x200-396383r383">error</a></b>, and not the type of the condition being signaled, that actually
causes the debugger to be entered.
<!--l. 3731--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.13   </span> <a 
href="frontmatter.html#QQ2-192-379" id="x192-33500029.3.13">Неважные условия</a></h4>
<!--l. 3733--><p class="noindent" >Некоторые условия не являются ни ошибками, ни важными. Они
сигнализируются для того, чтобы дать другой программе возможность
вмешаться, но если никакого действия не произошло, вычисление просто
обычным образом продолжается.
<!--l. 3737--><p class="indent" >   Например, реализация может выбрать сигнализирование неважного (и
зависимого от реализации) условия, называемого <b>end-of-line</b>, когда
вывод достигает последнего символа в строке. В такой реализации,
сигнализирование такого условия позволяет другим программа вмешаться,
выполняя вывод с переводом строки.
<!--l. 3742--><p class="indent" >   По соглашению, для неважных условий используется функция <b><a 
href="symbols.html#x200-396854r854">signal</a></b>.
Возможно сигнализирование важного условия с использованием <b><a 
href="symbols.html#x200-396854r854">signal</a></b>, и
если условие не было обработано, отладчик бы не вмешивался. Однако, по
соглашению, обработчики будут всегда склонны считать, что важные
условия и ошибки сигнализируются с помощью функции <b><a 
href="symbols.html#x200-396383r383">error</a></b> (и таким
образом будет вмешиваться интерактивный обработчик условия) и, что они
должны работать во избежание этого. FIXME
<!--l. 3750--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.14   </span> <a 
href="frontmatter.html#QQ2-192-380" id="x192-33600029.3.14">Типы условий</a></h4>
<!--l. 3752--><p class="noindent" >Некоторые типы условий определены в самой системе. Все типы условий
являются подтипами <b><a 
href="symbols.html#x200-396282r282">condition</a></b>. То есть, <b>(typep <em>x</em> &#x2019;condition)</b> является
истиной тогда и только тогда, когда значение <em>x</em> является условием.
<!--l. 3756--><p class="indent" >   Типы условий допускают множественное наследование. FIXME
<!--l. 3758--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.15   </span> <a 
href="frontmatter.html#QQ2-192-381" id="x192-33700029.3.15">Сигнализирование условий</a></h4>
                                                                          

                                                                          
<!--l. 3760--><p class="noindent" >При сигнализировании условия система пытается найти наиболее
соответствующий обработчик и вызвать его.
<!--l. 3763--><p class="indent" >   Обработчики устанавливаются динамически с помощью <b><a 
href="symbols.html#x200-396478r478">handler-bind</a></b>
или абстракций над <b><a 
href="symbols.html#x200-396478r478">handler-bind</a></b>.
<!--l. 3766--><p class="indent" >   Если был найден соответствующий обработчик, то он вызывается. В
некоторых случаях, обработчик может <em>отклонить вызов</em> просто вернув
управления, и без нелокальной передачи его. В таких случаях, поиск
соответствующего обработчика продолжается в таком же стиле.
<!--l. 3771--><p class="indent" >   Если обработчик найден не быть, или если все обработчики, которые были
найдены отклонили предложение, <b><a 
href="symbols.html#x200-396854r854">signal</a></b> возвращает <b><a 
href="symbols.html#x200-396670r670">nil</a></b>.
<!--l. 3775--><p class="indent" >   Несмотря на то, как следует из описания выше, пожалуй стоит отметить
явно, что процедура поиска, описанная здесь, будет предпочитать общий, но
более (динамически) локальный обработчик, чем специфичный, но менее
(динамически) локальный обработчик. Опыт работы с существующими
системами показывает, что это разумный подход и работает должным
образом в большинстве ситуаций. Следует проявлять осторожность при
связывании обработчика для самых общих видов условий, таких, как это
делается в <b><a 
href="symbols.html#x200-396489r489">ignore-errors</a></b>. Часто более целесообразно связывание для более
специфичного типа условия, чем для <b><a 
href="symbols.html#x200-396383r383">error</a></b>.
<!--l. 3784--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.16   </span> <a 
href="frontmatter.html#QQ2-192-382" id="x192-33800029.3.16">Пересигнализирование условий</a></h4>
<!--l. 3786--><p class="noindent" >Следует отметить что сигнализирование условий не имеет побочных
эффектов для этого условия, и что динамического состояния для хранения
объекта условия тоже нет. Иногда бывает необходимо закешировать
объект условия для повторного использования, пересигнализирования
изнутри обработчиков, или сохранить где-либо для использования в
будущем.
<!--l. 3792--><p class="indent" >   Например, системе необходимо выделить память под объекты типа
<b><a 
href="symbols.html#x200-396901r901">storage-condition</a></b>, так, чтобы они могли быть сигнализированы в нужное
время без попыток выделения памяти.
<!--l. 3796--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.17   </span> <a 
href="frontmatter.html#QQ2-192-383" id="x192-33900029.3.17">Обработчики условий</a></h4>
<em>
                                                                          

                                                                          
<!--l. 3799--><p class="noindent" >Обработчик</em> является функцией одного аргумента, а именно, условия для
обработки. Обработчик может проинспектировать объект для того, чтобы
быть уверенным в «интересности» оного.
<!--l. 3803--><p class="indent" >   Обработчик вызывается в динамическом контексте сигнальщика, за
исключением того, если множество доступных обработчиков было
пересвязано перед обработкой условия. Целью является предотвращение
бесконечной рекурсии из-за ошибок в обработчике.
<!--l. 3808--><p class="indent" >   После инспекции условия, обработчик может выполнить одно из
следующих действий:
      <ul class="itemize1">
      <li class="itemize">Может <em>отклонить</em> обработку условия (просто вернув управление).
      Когда  это  происходит,  возвращённые  значения  игнорируются,  и
      процедура поиска продолжает свою работу, как будто бы ничего и
      не случилось. Выполняется следующий обработчик, а если такой
      не был найден, условие остаётся необработанным.
      </li>
      <li class="itemize">Может <em>обработать</em> условие (выполнив какую-либо нелокальную
      передачу  управления).  Это  может  быть  сделано  примитивно  с
      помощью <b><a 
href="symbols.html#x200-396476r476">go</a></b>, <b><a 
href="symbols.html#x200-396816r816">return</a></b> или <b><a 
href="symbols.html#x200-396961r961">throw</a></b>, или с помощью такой абстракции,
      как <b><a 
href="symbols.html#x200-396081r81">abort</a></b> или <b><a 
href="symbols.html#x200-396510r510">invoke-restart</a></b>.
      </li>
      <li class="itemize">Может сигнализировать другое условие.
      </li>
      <li class="itemize">Может вызвать интерактивный отладчик.</li></ul>
<!--l. 3822--><p class="noindent" >Фактически последние два действия (сигнализирование другого условия или
вызов отладчика) просто перекладывают решение на кого-либо другого. В
конечном счёте, все что обработчики могут сделать это обработать или
отклонить.
<!--l. 3826--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">29.3.18   </span> <a 
href="frontmatter.html#QQ2-192-384" id="x192-34000029.3.18">Вывод условий</a></h4>
<!--l. 3828--><p class="noindent" >Когда <b><a 
href="symbols.html#x200-396037r37">*print-escape*</a></b> является <b><a 
href="symbols.html#x200-396670r670">nil</a></b> (например, когда используются функция
<b><a 
href="symbols.html#x200-396748r748">princ</a></b> или директива <b>~A</b> для <b><a 
href="symbols.html#x200-396438r438">format</a></b>), , будет вызван метод для вывода
                                                                          

                                                                          
условия. Это будет быть сделано автоматически в функциях, таких как
<b><a 
href="symbols.html#x200-396509r509">invoke-debugger</a></b>, <b><a 
href="symbols.html#x200-396168r168">break</a></b> и <b><a 
href="symbols.html#x200-397007r1007">warn</a></b>, но иногда бывает полезно иметь
возможность повлиять на вывод условия. Например, <div class="lisp"><tt><div class="tabbing">
(let ((form &#x2019;(open &#x0022;nosuchﬁle&#x0022;)))
   <br>              (handler-case (eval form)<br>                (serious-condition (c)<br>
      (format t &#x0022;~&#x0026;Вычисление ~S неуспешно:~%~A&#x0022; form c))))<br>
<!--l. 3838--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3839--><p class="indent" >   может вывести что-то вроде <div class="lisp"><tt><div class="tabbing">
Вычисление (OPEN &#x0022;nosuchﬁle&#x0022;) неуспешно:
   <br>                                                 Файл &#x0022;nosuchﬁle&#x0022; не был найден.<br>
<!--l. 3843--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3845--><p class="indent" >   Некоторые предложения о форме текст, введённый в докладе методы:
      <ul class="itemize1">
      <li class="itemize">Сообщение  в  целом,  должно  быть  законченным  предложением,
      начиная   с   буквы   и   заканчивая   соответствующими   знаками
      препинания (обычно точкой).
      </li>
      <li class="itemize">Сообщение  <em>не  должно  включать</em>  вводный  текст,  такой  как
      «<b>Ошибка:</b>»  или  «<b>Предупреждение</b>»  и  не  должны  завершать
      символом новой строки. Такой текст будет добавлен автоматически
      в соотвествие с контекстом.
      </li>
      <li class="itemize">Исключением случаев, когда это неизбежно, символы табуляции
      не должны использоваться в сообщениях об ошибках. Его действие
      может  варьироваться  от  одной  реализации  к  другой  и  может
                                                                          

                                                                          
      вызывать проблемы даже в рамках одной реализации, поскольку
      он может делать разные вещи в зависимости от колонки, в которой
      начинается отчёт об ошибках.
      </li>
      <li class="itemize">Однострочные   сообщения   являются   предпочтительными,   но
      символ  новой  строки  в  середине  длинного  сообщения  является
      приемлемым.
      </li>
      <li class="itemize">Если
      любая программа (например, отладчик) отображает сообщения с
      отступом от преобладающее левое поле (например, с отступом семь
      символов, из-за слова «<b>Ошибка:</b>»), то программа будет заботиться
      о  вставке  соответствующего  отступа  в  дополнительные  линии
      многострочного  сообщения  об  ошибке.  Кроме  того,  программа
      выводящая сообщение об ошибках с точками с запятой, должна
      заботиться  о  вставке  точки  с  запятой  в  начале  каждой  строки
      многострочного  сообщения  об  ошибке.  (Вызывающий  <b><a 
href="symbols.html#x200-396383r383">error</a></b>  не
      может предвидеть все такие возможные стили и т.д., поэтому это
      возложено  на  выводящего  сообщение,  чтобы  произвести  любые
      необходимые изменения.)</li></ul>
<!--l. 3875--><p class="indent" >   Когда <b><a 
href="symbols.html#x200-396037r37">*print-escape*</a></b> не равно <b><a 
href="symbols.html#x200-396670r670">nil</a></b>, объект должен быть выведен в
некотором полезном виде в соотвествие со стилем реализации. Не нужно
чтобы данный вывод был считываемым с помощью <b><a 
href="symbols.html#x200-396778r778">read</a></b>. Что-нибудь вроде
<b>#&#x003C;ARITHMETIC-ERROR 1734&#x003E;</b> достаточно.
<!--l. 3880--><p class="indent" >   Указание <b>(:report <em>fn</em>)</b> для <b><a 
href="symbols.html#x200-396314r314">deﬁne-condition</a></b> при определении типа
условия <em>C</em> эквивалентно отдельному определению метода: <div class="lisp"><tt><div class="tabbing">
(defmethod print-object ((x <em>C</em>) stream)
   <br>                    (if *print-escape*<br>                        (call-next-method)<br>
      (funcall #&#x2019;<em>fn</em> x stream)))<br>
<!--l. 3888--><p class="noindent" ></div>
</tt>
</div>
                                                                          

                                                                          
<!--l. 3889--><p class="indent" >   Следует отметить, что метод использует <em>fn</em> для вывода условия только
тогда, когда <b><a 
href="symbols.html#x200-396037r37">*print-escape*</a></b> имеет значение <b><a 
href="symbols.html#x200-396670r670">nil</a></b>.
                                                                          

                                                                          
<!--l. 3892--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse159.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse157.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse157.html#tailclmse157.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse158.html" >В-начало</a>&#x003E;&#x003C;<a 
href="condition.html#clmse158.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse158.html"></a>
 
</body></html> 
