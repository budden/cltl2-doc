%Part{Progs, Root = "CLM.MSS"}
%Chapter of Spice Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\ifx \rulang\Undef
\chapter{Program Structure}
\label{PROGS}

In chapter~\ref{DTYPES} the syntax was sketched for notating data objects
in Common Lisp.  The same syntax is used for notating programs because all
Common Lisp programs have a representation as Common Lisp data objects.

Lisp programs are organized as forms and functions.  Forms are
\emph{evaluated} (relative to some context) to produce values and side
effects.  Functions are invoked by \emph{applying} them to arguments.
The most important kind of form performs a function call;
conversely, a function performs computation by evaluating forms.

In this chapter, forms are discussed first and then functions.
Finally, certain ``top level'' special operators are discussed; the most
important of these is \cdf{defun}, whose purpose is to define a
named function.

\section{Forms}

The standard unit of interaction with a Common Lisp implementation is the \emph{form},
which is simply a data object meant to be \emph{evaluated} as a program
to produce one or more \emph{values} (which are also data objects).
One may request evaluation of \emph{any} data object, but only certain ones
are meaningful.  For instance,
symbols and lists are meaningful forms, while arrays
normally are not.  Examples of meaningful forms are \cd{3},
whose value is \cd{3}, and \cd{(+ 3 4)}, whose value is \cd{7}.
We write \cd{3} \EV\ \cd{3} and \cd{(+ 3 4)} \EV\ \cd{7}
to indicate these facts.  (\EV\ means ``evaluates to.'')

Meaningful forms may be divided into three categories:
self-evaluating forms, such as numbers; symbols, which stand
for variables; and lists.  The lists in turn may be divided
into three categories: special operators, macro calls, and function calls.

\emph{All} standard Common Lisp data objects other than symbols
and lists (including \cdf{defstruct} structures defined
without the \cd{:type} option) are self-evaluating.

\subsection{Self-Evaluating Forms}

All numbers, characters, strings, and bit-vectors
are \emph{self-evaluating} forms.
When such an object is evaluated, that object
(or possibly a copy in the case of numbers or characters)
is returned as the value
of the form.  The empty list {\emptylist}, which is also the false value {\false},
is also a self-evaluating form: the value of {\false} is {\false}.
Keywords (symbols written with a leading colon) also evaluate
to themselves: the value of \cd{:start} is \cd{:start}.

It is an error to destructively modify any object that appears as a constant
in executable code, whether as
a self-evaluating form or within a \cdf{quote} special operator.

\subsection{Variables}

Symbols are used as names of variables in Common Lisp programs.
When a symbol is evaluated as a form, the value of the variable it names
is produced.  For example, after doing \cd{(setq items 3)}, which assigns
the value \cd{3} to the variable named \cdf{items}, then \cdf{items} \EV\ \cd{3}.
Variables can be \emph{assigned} to, as by \cdf{setq}, or \emph{bound},
as by \cdf{let}.
Any program construct that binds a variable effectively saves the old
value of the variable and causes it to have a new value, and on exit from
the construct the old value is reinstated.

There are actually two kinds of variables in Common Lisp, called \emph{lexical} (or
\emph{static}) variables and \emph{special} (or \emph{dynamic}) variables.
At any given time either or both kinds of variable with the same name may
have a current value.  Which of the two kinds of variable is referred to
when a symbol is evaluated depends on the context of the evaluation.
The general rule is that if the symbol occurs textually within a program
construct that creates a \emph{binding} for a variable of the same name,
then the reference is to the variable specified by the binding;
if no such program construct textually contains the reference, then
it is taken to refer to the special variable of that name.

The distinction between the two kinds of variable is one of scope
and extent.  A lexically bound variable can be referred to \emph{only}
by forms occurring at any \emph{place} textually within the program construct that
binds the variable.  A dynamically bound (special) variable can
be referred to at any \emph{time} from the time the binding is made
until the time evaluation of the construct that binds the variable
terminates.  Therefore lexical binding of variables
imposes a spatial limitation
on occurrences of references (but no temporal limitation, for the
binding continues to exist as long as the possibility of reference
remains).  Conversely, dynamic binding of variables imposes a temporal
limitation on occurrences of references (but no spatial limitation).
For more information on scope and extent, see chapter~\ref{SCOPE}.

The value a special variable has when there are currently
no bindings of that variable is called the \emph{global} value of the
(special) variable.
A global value can be given to a variable only by assignment,
because a value given by binding is by definition not global.

It is possible for a special variable to have no value at all,
in which case it is said to be \emph{unbound}.
By default, every global variable is unbound unless and until
explicitly assigned a value, except for those global variables
defined in this book or by the implementation already to have values
when the Lisp system is first started.
It is also possible to establish a binding of a special variable
and then cause that binding to be valueless by using the
function \cdf{makunbound}.  In this situation the variable
is also said to be ``unbound,'' although this is a misnomer;
precisely speaking, it is bound but valueless.
It is an error to refer to a variable that is unbound.

Reading an unbound variable or an undefined function
must be detected in the highest safety setting (see the
\cdf{safety} quality of the \cdf{optimize} declaration specifier)
but the effect is undefined in any other safety setting. That is,
reading an unbound variable should signal an error and
reading an undefined function should signal an error.
(``Reading a function'' includes
both references to the function using the \cdf{function}
special operator, such as \cdf{f} in \cd{(function~f)}, and references to the
function in a call, such as \cdf{f} in \cd{(f~x~y)}.)

For the case of \cdf{inline} functions (in implementations where they are
supported), a permitted point of view is that performing the inlining
constitutes the read of the function, so that an \cdf{fboundp}
check need not be done at
execution time. Put another way, the effect of the application of
\cdf{fmakunbound} to a function name
on potentially inlined references to that function is undefined.

When an unbound variable 
is detected an error of type \cdf{unbound-variable} is signaled,
and the \cdf{name} slot of the
\cdf{unbound-variable} condition is initialized to the name of the
offending variable.

When an undefined function
is detected an error of type \cdf{undefined-function} is signaled,
and the \cdf{name} slot of the
\cdf{undefined-function} condition is initialized to the name of the
offending function.

The condition type \cdf{unbound-slot}, which inherits from
\cdf{cell-error}, has an additional slot \cdf{instance}, which
can be initialized using the \cd{:instance} keyword to \cdf{make-condition}.
The function \cdf{unbound-slot-instance} accesses this slot.

The type of error signaled by the default primary
method for the CLOS \cdf{slot-unbound} generic function is \cdf{unbound-slot}.
The \cdf{instance} slot
of the \cdf{unbound-slot} condition is initialized to the offending instance
and the \cdf{name} slot is initialized
to the name of the offending variable.

Certain global variables are reserved as ``named constants.''
They have a global value and may not be bound or assigned to.
For example,
the symbols {\true} and {\false} are reserved.
One may not assign a value to {\true} or {\false},
and one may not bind {\true} or {\false}.  The global value of
{\true} is always {\true}, and the global value of
{\false} is always {\false}.  Constant symbols defined by
\cdf{defconstant} also become reserved and may not be further
assigned to or bound (although they may be redefined, if necessary, by
using \cdf{defconstant} again).  Keyword symbols,
which are notated with a leading colon, are reserved and
may never be assigned to or bound; a keyword always evaluates
to itself.

\subsection{Special Operators}

If a list is to be evaluated as a form, the first step is to examine
the first element of the list.  If the first element is one of
the symbols appearing in table~\ref{SPECIAL-FORM-TABLE},
then the list is called a \emph{special operator}.  (This use of the word
``special'' is unrelated to its use in the phrase ``special variable.'')

Special operators are generally environment and control constructs.
Every special operator has its own idiosyncratic syntax.  An example
is the \cdf{if} special operator:
\cd{(if p (+ x 4) 5)} in Common Lisp means what
``\textbf{if} \emph{p} \textbf{then} \emph{x}+4 \textbf{else} 5'' means in
Algol.

The evaluation of a special operator normally produces a value or values,
but the evaluation may instead call for a non-local exit; see \cdf{return-from},
\cdf{go}, and \cdf{throw}.

The set of special operators is fixed in Common Lisp; no way is provided
for the user to define more.  The user can create new syntactic
constructs, however, by defining macros.

The set of special operators in Common Lisp is purposely kept very small
because any program-analyzing program must have special knowledge
about every type of special operator.  Such a program needs no special
knowledge about macros because it is simple to expand the macro
and operate on the resulting expansion.  (This is not to say that
many such programs, particularly compilers, will not have such
special knowledge.  A compiler may be able
to produce much better code if it recognizes such constructs
as \cdf{typecase} and \cdf{multiple-value-bind} and gives them customized
treatment.)

\begin{table}[t]
\caption{Names of All Common Lisp Special Operators}
\label{SPECIAL-FORM-TABLE}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lll@{}}
\cdf{block}&\cdf{if}&\cdf{progv} \\
\cdf{catch}&\cdf{labels}&\cdf{quote} \\
&\cdf{let}&\cdf{return-from} \\
\cdf{declare}&\cdf{let*}&\cdf{setq} \\
\cdf{eval-when}&\cdf{macrolet}&\cdf{tagbody} \\
\cdf{flet}&\cdf{multiple-value-call}&\cdf{the} \\
\cdf{function}&\cdf{multiple-value-prog1}&\cdf{throw} \\
\cdf{go}&\cdf{progn}&\cdf{unwind-protect} \\
& &\cdf{symbol-macrolet} \\
&\cdf{locally}&\cdf{load-time-value}
\end{tabular*}
\vskip 4pt
\end{table}

An implementation is free to implement as a macro any construct described
herein as a special operator.  Conversely, an implementation is free
to implement as a special operator any construct described herein as a macro
if an equivalent macro definition is also provided.
The practical consequence is that the predicates \cdf{macro-function} and
\cdf{special-operator-p} may both be true of the same symbol.
It is recommended that a program-analyzing program process
a form that is a list whose \emph{car} is a symbol as follows:

\begin{enumerate}
\item
If the program has particular knowledge about the symbol,
process the form using special-purpose code.
All of the symbols listed in table~\ref{SPECIAL-FORM-TABLE}
should fall into this category. 

\item
Otherwise, if \cdf{macro-function} is true of the symbol, apply either
\cdf{macroexpand} or \cdf{macroexpand-1}, as appropriate,
to the entire form and then start over.

\item
Otherwise, assume it is a function call.
\end{enumerate}

\subsection{Macros}

If a form is a list and the first element is not the name of a special
form, it may be the name of a \emph{macro}; if so, the form is said
to be a \emph{macro call}.  A macro is essentially a function from
forms to forms that will, given a call to that macro, compute
a new form to be evaluated in place of the macro call.
(This computation is sometimes referred to as \emph{macro expansion}.)
For example, the macro named \cdf{return} will take a form such as
\cd{(return x)} and from that form compute a new form
\cd{(return-from {\nil} x)}.  We say that the old
form \emph{expands} into the new form.  The new form is then evaluated in
place of the original form; the value of the new form is returned as the
value of the original form.

Macro calls, and subforms
of macro calls, need not be proper lists, but that use of dotted forms
requires the macro definition to use ``\cd{.~\emph{var}}'' or
``\cd{\&rest~\emph{var}}'' in order to match them properly.
It is then the responsibility of the macro definition to recognize
and appropriately handle such dotted forms or subforms.

There are a number of standard macros in Common Lisp, and the user can define more
by using \cdf{defmacro}.

Macros provided by a Common Lisp implementation as described herein may expand
into code that is not portable among differing implementations.
That is, a macro call may be implementation-independent because
the macro is defined in this book, but the expansion need not be.

\beforenoterule
\begin{implementation}
Implementors are encouraged to implement the macros
defined in this book, as far as is possible, in such a way that
the expansion will not contain any implementation-dependent
special operators, nor contain as forms data objects that
are not considered to be forms in Common Lisp.
The purpose of this restriction is to ensure that the expansion
can be processed by a program-analyzing program in an
implementation-independent manner.
There is no problem with a macro expansion containing
calls to implementation-dependent functions.
This restriction is not a requirement of Common Lisp; it is recognized
that certain complex macros may be able to expand into significantly
more efficient code in certain implementations
by using implementation-dependent special operators in the macro expansion.
\end{implementation}
\afternoterule

\subsection{Function Calls}

If a list is to be evaluated as a form and the first element is
not a symbol that names a special operator or macro, then the list
is assumed to be a \emph{function call}.  The first element of the
list is taken to name a function.  Any and all remaining elements
of the list are forms to be evaluated; one value is obtained
from each form,
and these values become the \emph{arguments} to the function.
The function is then \emph{applied} to the arguments.
The functional computation normally produces a value,
but it may instead call for a non-local exit; see \cdf{throw}.
A function that does return may produce no value or several values;
see \cdf{values}.
If and when the function returns, whatever values it returns
become the values of the function-call form.

For example, consider the evaluation of the form \cd{(+ 3 (* 4 5))}.
The symbol \cdf{+} names the addition function, not a special operator or macro.
Therefore the two forms \cd{3} and \cd{(* 4 5)} are evaluated to produce
arguments.  The form \cd{3} evaluates to \cd{3}, and the form
\cd{(* 4 5)} is a function call (to the multiplication function).
Therefore the forms \cd{4} and \cd{5} are evaluated, producing arguments
\cd{4} and \cd{5} for the multiplication.  The multiplication function
calculates the number \cd{20} and returns it.  The values \cd{3} and \cd{20}
are then given as arguments to the addition function, which calculates
and returns the number \cd{23}.  Therefore we say \cd{(+ 3 (* 4 5)) \EV\ 23}.

While the arguments in a function call are always
evaluated in strict left-to-right order, whether the function to
be called is determined before or after argument evaluation
is unspecified.  Programs are in error
that rely on a particular order of evaluation
of the first element of a function call relative to the
argument forms.

\section{Functions}

There are two ways to indicate a function to be used in a function-call
form.  One is to use a symbol that names the function.  This use of
symbols to name functions is completely independent of their use in
naming special and lexical variables.  The other way is to use a
\emph{lambda-expression}, which is a list whose first element is the symbol
\cdf{lambda}.  A lambda-expression is \emph{not} a form; it cannot be
meaningfully evaluated.  Lambda-expressions and symbols, when used in
programs as names of functions, can appear only as the first element of a
function-call form, or as the second element of the \cdf{function}
special operator.  Note that symbols and lambda-expressions are treated as
\emph{names} of functions in these two contexts.  This should be
distinguished from the treatment of symbols and lambda-expressions as
\emph{function objects}, that is,
objects that satisfy the predicate \cdf{functionp},
as when giving such an object to \cdf{apply} or \cdf{funcall} to be
invoked.

\subsection{Named Functions}

A name can be given to a function in one of two ways.
A \emph{global name} can be given to a function by using the
\cdf{defun} construct.
A \emph{local name} can be given to a function by using the
\cdf{flet} or
\cdf{labels} special operator.
When a function is named, a lambda-expression is effectively
associated with that name
along with information about the entities that are lexically apparent
at that point.
If a symbol appears as the first element of a function-call form, then it
refers to the definition established by the innermost \cdf{flet} or \cdf{labels}
construct that textually contains the reference, or to the global
definition (if any) if there is no such containing construct.

\subsection{Lambda-Expressions}
\label{LAMBDA-EXPRESSIONS-SECTION}
\indexterm{lambda-expression}
\indexterm{lambda-list}
% \indexterm{{\&optional!Symbol}}
% \indexterm{{\&rest!Symbol}}
% \indexterm{{\&key!Symbol}}
% \indexterm{{\&allow-other-keys!Symbol}}
% \indexterm{{\&aux!Symbol}}

\label{lambda-expression}
\label{lambda-list}
\label{optional}
\label{rest}
\label{key}
\label{allow-other-keys}
\label{aux}

A \emph{lambda-expression} is a list with the following syntax:
\begin{lisp}
(lambda \emph{lambda-list} . \emph{body})
\end{lisp}
The first element must be the symbol \cdf{lambda}.  The second element
must be a list.  It is called the \emph{lambda-list}, and specifies
names for the \emph{parameters} of the function.  When the function
denoted by the lambda-expression is applied to arguments,
the arguments are matched with the parameters specified by the
lambda-list.  The \emph{body} may then refer to the arguments by using
the parameter names.  The \emph{body} consists of any number of
forms (possibly zero).  These forms are evaluated in sequence,
and the results of the \emph{last} form only are returned as the results
of the application (the value {\false} is returned if there are zero
forms in the body).
The complete syntax of a lambda-expression is:

\begingroup
\def\GrossOptVars{\Mstar{\emph{var} {\Mor} \cd{(}\emph{var} \Mopt{\emph{initform} \Mopt{\emph{svar}}}\cd{)}}}
\def\GrossKeyOptVars{\Mstar{\emph{var} {\Mor} \cd{(}\Mgroup{\emph{var} {\Mor} \cd{(}\emph{keyword} \emph{var}\cd{)}} \Mopt{\emph{initform} \Mopt{\emph{svar}}}\cd{)}}}
\def\GrossAuxVars{\Mstar{\emph{var} {\Mor} \cd{(}\emph{var} \Mopt{\emph{initform}}\cd{)}}}
\begin{lisp}
(lambda (\Mstar{\emph{var}} \\
~~~~~~~~~\Mopt{\cd{\&optional} \GrossOptVars} \\
~~~~~~~~~\Mopt{\cd{\&rest} \emph{var}} \\
~~~~~~~~~\Mopt{\cd{\&key} \GrossKeyOptVars 
~~~~~~~~~~~~~~\Mopt{\cd{\&allow-other-keys}}} \\
~~~~~~~~~\Mopt{\cd{\&aux} \GrossAuxVars}) \\
~~~\Mchoice{\Mstar{\emph{declaration}} {\Mor} \emph{documentation-string}} \\
~~~\Mstar{\emph{form}})
\end{lisp}
\endgroup

Each element of a lambda-list is either a \emph{parameter specifier}
or a \emph{lambda-list keyword}; lambda-list keywords begin with \cd{\&}.
(Note that lambda-list keywords are not keywords in the usual sense;
they do not belong to the keyword package.  They are ordinary symbols
each of whose names begins with an ampersand.  This terminology
is unfortunately confusing but is retained for historical reasons.)

\emph{Keyword} in the preceding specification of a lambda-list
may be any symbol whatsoever, not just a keyword symbol
in the \cdf{keyword} package.  See below.

A lambda-list has five parts, any or all of which may be empty:

\begin{itemize}
\item
Specifiers for the \emph{required} parameters.  These are all the parameter
specifiers up to the first lambda-list keyword; if there is no such
lambda-list keyword, then all the specifiers are for required parameters.

\item
Specifiers for \emph{optional} parameters.
If the lambda-list keyword \cd{\&optional} is present,
the \emph{optional} parameter specifiers are those following the
lambda-list keyword \cd{\&optional} up to the next lambda-list keyword or the
end of the list.

\item
A specifier for a \emph{rest} parameter.  The lambda-list keyword \cd{\&rest}, if present, must
be followed by a single \emph{rest} parameter specifier,
which in turn must be followed by another lambda-list keyword or the end
of the lambda-list.

\item
Specifiers for \emph{keyword} parameters.
If the lambda-list keyword \cd{\&key} is present, all specifiers up to the next lambda-list keyword
or the end of the list are \emph{keyword} parameter specifiers.
The keyword parameter specifiers may optionally be followed by the
lambda-list keyword \cd{\&allow-other-keys}.

\item
Specifiers for \emph{aux} variables.  These are not really parameters.
If the lambda-list keyword \cd{\&aux} is present, all specifiers after it are
\emph{auxiliary variable} specifiers.
\end{itemize}

When the function represented by the lambda-expression is applied
to arguments, the arguments and parameters are processed in order
from left to right.
In the simplest case, only required parameters are present
in the lambda-list; each is specified simply by a name \emph{var} for
the parameter variable.
When the function is applied,
there must be exactly as many arguments as there are parameters,
and each parameter is bound to one argument.  Here, and in general,
the parameter is bound as a lexical variable unless a
declaration has been made that it should be a special binding;
see \cdf{defvar}, \cdf{proclaim}, and \cdf{declare}.

In the more general case, if there are \emph{n} required parameters
(\emph{n} may be zero), there must be at least \emph{n} arguments,
and the required parameters are bound to the first \emph{n} arguments.
The other parameters are then processed using any remaining arguments.

If \emph{optional} parameters are specified, then each one is processed as
follows.  If any unprocessed arguments remain, then the parameter variable
\emph{var} is bound to the next remaining argument, just as for a required
parameter.  If no arguments remain, however, then the \emph{initform} part
of the parameter specifier is evaluated, and the parameter variable
is bound to the resulting value (or to {\false} if no \emph{initform} appears
in the parameter specifier).
If another variable name \emph{svar} appears in the specifier, it is bound
to \emph{true} if an argument was available, and to \emph{false} if no
argument remained (and therefore \emph{initform} had to be evaluated).
The variable \emph{svar} is called a \emph{supplied-p} parameter;
it is bound not to an argument but to a value indicating whether or not
an argument had been supplied for another parameter.

After all \emph{optional} parameter specifiers have been processed,
then there may or may not be a \emph{rest} parameter.
If there is a \emph{rest} parameter, it is bound to a list of all
as-yet-unprocessed arguments.  (If no unprocessed arguments remain,
the \emph{rest} parameter is bound to the empty list.)
If there is no \emph{rest} parameter and there are no \emph{keyword}
parameters,
then there should be no unprocessed arguments (it is an error if there are).

If a function has a \emph{rest} parameter
and is called using \cdf{apply}, then the list to which the
\emph{rest} parameter is bound is permitted, but not required,
to share top-level list structure with the list that was the last
argument to \cdf{apply}.  Programmers should be careful about performing
side effects on the top-level list structure of a \emph{rest} parameter.

This was the result of a rather long discussion within X3J13 and the
wider Lisp community.  To set it in its historical context, I must remark
that in Lisp Machine Lisp the list to which a \emph{rest} parameter was
bound had only dynamic extent; this in conjunction with the
technique of ``cdr-coding'' permitted a clever stack-allocation technique
with very low overhead.  However, the early designers of
Common Lisp, after a great deal of debate, concluded that it was dangerous
for cons cells to have dynamic extent; as an example, the ``obvious''
definition of the function \cdf{list}
\begin{lisp}
(defun list (\&rest x) x)
\end{lisp}
could fail catastrophically.  Therefore the first edition simply implied
that the list for a \emph{rest} parameter, like all other lists, would
have indefinite extent.  This still left open the flip side of the
question, namely, Is the list for a \emph{rest} parameter guaranteed fresh?
This is the question addressed by the X3J13 vote.
If it is always freshly consed, then it is permissible to destroy it,
for example by giving it to \cdf{nconc}.  However, the requirement always
to cons fresh lists could impose an unacceptable overhead in many implementations.
The clarification approved by X3J13 specifies that the programmer may
not rely on the list being fresh; if the function was called using \cdf{apply},
there is no way to know where the list came from.

Next, any \emph{keyword} parameters are processed.
For this purpose the same arguments are processed that
would be made into a list for a \emph{rest} parameter.
(Indeed, it is permitted to specify both \cd{\&rest} and \cd{\&key}.
In this case the remaining arguments are used for both purposes;
that is, all remaining arguments are made into a list for the
\cd{\&rest} parameter and are also processed for the \cd{\&key} parameters.
This is the only situation in which an argument is used
in the processing of more than one parameter specifier.)
If \cd{\&key} is specified, there must remain
an even number of arguments; these are considered as pairs,
the first argument in each pair being interpreted as a keyword name
and the second as the corresponding value.

A \emph{keyword} in a lambda-list
may be any symbol whatsoever, not just a keyword symbol
in the \cdf{keyword} package.  If, after \cd{\&key},
a variable appears alone or within only one set of parentheses
(possibly with an \emph{initform} and a \emph{svar}), then
the behavior is as before: a keyword symbol with the same name as
the variable is used as the keyword-name when matching arguments
to parameter specifiers.  Only a parameter specifier of the form
\cd{((\emph{keyword} \emph{var})~...)} can cause the keyword-name
not to be a keyword symbol, by specifying a symbol not in the \cdf{keyword}
package as the \emph{keyword}.
For example:
\begin{lisp}
(defun wager (\&key ((secret password) nil) amount) \\*
~~(format nil "You {\Xtilde}A \${\Xtilde}D" \\*
~~~~~~~~~~(if (eq password 'joe-sent-me) "win" "lose") \\*
~~~~~~~~~~amount)) \\
\\
(wager :amount 100) \EV\ "You lose \$100" \\*
(wager :amount 100 'secret 'joe-sent-me) \EV\ "You win \$100"
\end{lisp}
The \cdf{secret} word could be made even more secret in this example
by placing it in some other \cdf{obscure} package, so that one would
have to write
\begin{lisp}
(wager :amount 100 'obscure:secret 'joe-sent-me) \EV\ "You win \$100"
\end{lisp}
to win anything.

In each keyword parameter specifier must be a name \emph{var} for the
parameter variable.  If an explicit \emph{keyword} is
specified, then that is the keyword name for the parameter.  Otherwise
the name \emph{var} serves to indicate the keyword name,
in that a keyword with the same name (in the \cdf{keyword} package) is used
as the keyword.  Thus
\begin{lisp}
(defun foo (\cd{\&key} radix (type 'integer)) ...)
\end{lisp}
means exactly the same as
\begin{lisp}
(defun foo (\cd{\&key} ((:radix radix)) ((:type type) 'integer)) ...)
\end{lisp}

The keyword parameter specifiers are, like all parameter specifiers,
effectively processed from left to right.
For each keyword parameter specifier, if there is an argument
pair whose keyword name matches that specifier's keyword name
(that is, the names are \cdf{eq}),
then the parameter variable for that specifier is bound to the
second item (the value) of that argument pair.
If more than one such argument pair matches, it is not an error;
the leftmost argument pair is used.
If no such argument pair exists, then
the \emph{initform} for that specifier is evaluated
and the parameter variable is bound to that value (or to {\false} if
no \emph{initform} was specified).  The variable \emph{svar} is treated
as for ordinary \emph{optional} parameters: it is bound to \emph{true}
if there was a matching argument pair, and to \emph{false} otherwise.

It is an error if an argument pair has a keyword name not matched
by any parameter specifier, unless at least one of the following
two conditions is met:

\begin{itemize}
\item
\cd{\&allow-other-keys} was specified in the lambda-list.

\item
Somewhere among the keyword argument pairs is a pair whose keyword
is \cd{:allow-other-keys} and whose value is not {\false}.
\end{itemize}
If either condition obtains, then it is not an error
for an argument pair to match no parameter specified,
and the argument pair is simply ignored (but such an
argument pair is accessible through the \cd{\&rest} parameter if
one was specified). The purpose of these mechanisms is to
allow sharing of argument lists among several functions
and to allow either the caller or the called function
to specify that such sharing may be taking place.

After all parameter specifiers have been processed, the auxiliary
variable specifiers (those following the lambda-list keyword \cd{\&aux}) are processed from
left to right.  For each one, the \emph{initform} is evaluated and the
variable \emph{var} bound to that value (or to {\false} if no \emph{initform} was
specified).  Nothing can be done with \cd{\&aux} variables that cannot be
done with the special operator \cdf{let*}:
\begin{lisp}
(lambda (x y \&aux (a (car x)) (b 2) c) ...) \\
~~~\EQ\ (lambda (x y) (let* ((a (car x)) (b 2) c) ...))
\end{lisp}

Which to use is purely a matter of style.

Whenever any \emph{initform} is evaluated for any parameter
specifier, that form may refer to any parameter variable to the left of
the specifier in which the \emph{initform} appears, including any supplied-p
variables, and may rely on the fact that no other parameter variable
has yet been bound (including its own parameter variable).

Once the lambda-list has been processed, the forms in the body of the
lambda-expression are executed.  These forms may refer to the arguments
to the function by using the names of the parameters.  On exit from the
function, either by a normal return of the function's value(s) or by a
non-local exit, the parameter bindings, whether lexical or special, are
no longer in effect.  (The bindings are not necessarily permanently discarded,
for a lexical binding can later be reinstated if a
``closure'' over that binding was created,
perhaps by using \cdf{function}, and saved before the exit occurred.)

\noindent
Examples of \cd{\&optional} and \cd{\&rest} parameters:
\begin{lisp}
((lambda (a b) (+ a (* b 3))) 4 5) \EV\ 19 \\
((lambda (a \cd{\&optional} (b 2)) (+ a (* b 3))) 4 5) \EV\ 19 \\
((lambda (a \cd{\&optional} (b 2)) (+ a (* b 3))) 4) \EV\ 10 \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x))) \\*
~~~\EV\ (2 {\false} 3 {\false} {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6) \\*
~~~\EV\ (6 t 3 {\false} {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3) \\*
~~~\EV\ (6 t 3 t {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3 8) \\*
~~~\EV\ (6 t 3 t (8)) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3 8 9 10 11) \\*
~~~\EV\ (6 t 3 t (8 9 10 11))
\end{lisp}
Examples of \cd{\&key} parameters:
\begin{lisp}
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2) \\*
~~~\EV\ (1 2 {\nil} {\nil}) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :c 6) \\*
~~~\EV\ (1 2 6 {\nil}) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :d 8) \\*
~~~\EV\ (1 2 {\nil} 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :c 6 :d 8) \\*
~~~\EV\ (1 2 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :d 8 :c 6) \\*
~~~\EV\ (1 2 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) :a 1 :d 8 :c 6) \\*
~~~\EV\ (:a 1 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) :a :b :c :d) \\
~~~\EV\ (:a :b :d {\nil})
\end{lisp}
Examples of mixtures:
\begin{lisp}
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1)   \EV\ (1 3 {\nil} 1 ())
\end{lisp}

\begin{lisp}
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 2)   \EV\ (1 2 {\nil} 1 ()) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~:c 7)   \EV\ (:c 7 {\nil} :c ()) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :c 7)   \EV\ (1 6 7 1 (:c 7)) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :d 8)   \EV\ (1 6 {\nil} 8 (:d 8)) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :d 8 :c 9 :d 10)   \EV\ (1 6 9 8 (:d 8 :c 9 :d 10))
\end{lisp}

All lambda-list keywords are permitted, but not terribly useful, in
lambda-expressions appearing explicitly as the first element of a
function-call form.  They are extremely
useful, however, in functions given global names by \cdf{defun}.

All symbols whose names begin with \cd{\&} are conventionally reserved
for use as lambda-list keywords and should not be used as variable names.
Implementations of Common Lisp are free to provide additional lambda-list
keywords.

\begin{defun}[Constant]
lambda-list-keywords

The value of \cdf{lambda-list-keywords} is a list of all the lambda-list
keywords used in the implementation, including the additional ones
used only by \cdf{defmacro}.  This list must contain at least the symbols
\cd{\&optional}, \cd{\&rest}, \cd{\&key}, \cd{\&allow-other-keys}, \cd{\&aux}, \cd{\&body}, \cd{\&whole},
and \cd{\&environment}.
\end{defun}

As an example of the use of \cd{\&allow-other-keys} and \cd{:allow-other-keys},
consider a function that takes two keyword arguments of its own and also
accepts additional keyword arguments to be passed to \cdf{make-array}:
\begin{lisp}
(defun array-of-strings (str dims \cd{\&rest} keyword-pairs \\*
~~~~~~~~~~~~~~~~~~~~~~~~~\cd{\&key} (start 0) end \cd{\&allow-other-keys}) \\*
~~(apply \#'make-array dims \\*
~~~~~~~~~:initial-element (subseq str start end) \\
~~~~~~~~~:allow-other-keys t \\*
~~~~~~~~~keyword-pairs))
\end{lisp}

This function takes a string and dimensioning information and returns
an array of the specified dimensions, each of whose elements is the
specified string.  However, \cd{:start} and \cd{:end} keyword arguments
may be used in the usual manner (see chapter~\ref{KSEQUE}) to specify
that a substring of the given string should be used.  In addition,
the presence of \cd{\&allow-other-keys} in the lambda-list indicates that the caller
may specify additional keyword arguments; the \cd{\&rest} argument provides
access to them.  These additional keyword arguments are fed to \cdf{make-array}.
Now, \cdf{make-array} normally does not allow the keywords \cd{:start}
and \cd{:end} to be used, and it would be an error to specify such
keyword arguments to \cdf{make-array}.  However, the presence in the
call to \cdf{make-array} of the keyword argument \cd{:allow-other-keys}
with a non-{\false} value causes any extraneous keyword arguments,
including \cd{:start} and \cd{:end}, to be acceptable and ignored.

\begin{defun}[Constant]
lambda-parameters-limit

The value of \cdf{lambda-parameters-limit} is a positive integer that is
the upper exclusive bound on the number of distinct parameter names
that may appear in a single lambda-list.
This bound depends on the implementation
but will not be smaller than 50.
Implementors are encouraged to make this limit as large as practicable
without sacrificing performance.
See \cdf{call-arguments-limit}.
\end{defun}

\section{Top-Level Forms}

The standard way for the user to interact with a Common Lisp implementation is
via a \emph{read-eval-print loop}: the system repeatedly
reads a form from some input source (such as a keyboard or a disk file),
evaluates it, and then prints the value(s) to some output sink (such as a
display screen or another disk file).  Any form (evaluable
data object) is acceptable; however, certain special operators are specifically
designed to be convenient for use as \emph{top-level} forms,
rather than as forms embedded within other forms in the way
that \cd{(+ 3 4)}
is embedded within \cd{(if p (+ 3 4) 6)}.
These top-level special operators may be used to define globally named
functions, to define macros, to make declarations,
and to define global values for special variables.

While defining forms normally appear at top level,
it is meaningful to place them in non-top-level contexts.
All defining forms that create functional objects from code appearing
as argument forms must ensure that
such argument forms refer to the enclosing lexical environment.
Compilers must handle defining forms properly in all situations,
not just top-level contexts.  However, certain
compile-time side effects of these defining forms are performed only
when the defining forms occur at top level (see section~\ref{COMPILER-SECTION}).

Macros are usually defined by using the special operator \cdf{defmacro}.
This facility is fairly complicated; it is described in chapter~\ref{MACROS}.

\subsection{Defining Named Functions}

The \cdf{defun} special operator is the usual means of defining named functions.

\begin{defmac}
defun name lambda-list <{declaration}* | doc-string> {form}*

Evaluating a \cdf{defun} form causes the symbol \emph{name} to be a global name
for the function specified by the lambda-expression
\begin{lisp}
(lambda \emph{lambda-list} \Mstar{\emph{declaration} {\Mor} \emph{doc-string}} \Mstar{\emph{form}})
\end{lisp}
defined in the lexical environment in which the \cdf{defun} form was
executed.  Because \cdf{defun} forms normally appear at top level, this is
normally the null lexical environment.

While defining forms normally appear at top level,
it is meaningful to place them in non-top-level contexts;
\cdf{defun} must define the function
within the enclosing lexical environment, not within the null lexical
environment.

\cdf{defun}
can accept any function-name (a symbol or a list
whose \emph{car} is \cdf{setf}---see section~\ref{FUNCTION-NAME-SECTION})
as a \emph{name}.
Thus one may write
\begin{lisp}
(defun (setf cadr) ...)
\end{lisp}
to define a \cdf{setf}
expansion function for \cdf{cadr} 
(although it may be much more convenient to
use \cdf{defsetf} or \cdf{define-modify-macro}).

If the optional documentation string \emph{doc-string} is present,
then it is attached to the \emph{name}
as a documentation string of type \cdf{function}; see \cdf{documentation}.
If \emph{doc-string} is not
followed by a declaration, it may be
present only if at least one \emph{form} is also specified, as it is
otherwise taken to be a \emph{form}.
It is an error if more than one \emph{doc-string} is present.

The \emph{forms} constitute the body of the defined function; they are
executed as an implicit \cdf{progn}.

The body of the defined function is implicitly enclosed
in a \cdf{block} construct whose name is the same as the \emph{name}
of the function.  Therefore \cdf{return-from}
may be used to exit from the function.

Other implementation-dependent bookkeeping actions may be taken as well
by \cdf{defun}.  The \emph{name} is returned as the value of the \cdf{defun}
form.
For example:
\begin{lisp}
(defun discriminant (a b c) \\
~~(declare (number a b c)) \\
~~"Compute the discriminant for a quadratic equation. \\
~~~Given a, b, and c, the value b{\Xcircumflex}2-4*a*c is calculated. \\
~~~If the coefficients a, b, and c are all real (that is, \\
~~~not complex), then the quadratic equation a*x{\Xcircumflex}2+b*x+c=0 \\
~~~has real, multiple, or complex roots depending on \\
~~~whether this calculated value is positive, zero, or \\
~~~negative, respectively."
~~(- (* b b) (* 4 a c))) \\
~~~\EV\ discriminant \\
~~~\textrm{and now} (discriminant 1 2/3 -2) \EV\ 76/9
\end{lisp}

It is permissible to use \cdf{defun} to redefine a function,
to install a corrected version of an incorrect definition, for example.
It is permissible to redefine a macro as a function.
It is an error to attempt to redefine the name of a special
form (see table~\ref{SPECIAL-FORM-TABLE}) as a function.
\end{defmac}

\subsection{Declaring Global Variables and Named Constants}

The \cdf{defvar} and \cdf{defparameter} special operators are
the usual means of specifying globally defined variables.
The \cdf{defconstant} special operator is used for defining named constants.

\begin{defmac}
defvar name [initial-value [documentation]] \\
defparameter name initial-value [documentation] \\
defconstant name initial-value [documentation]

\cdf{defvar} is the recommended way to declare the use
of a special variable in a program.
\begin{lisp}
(defvar \emph{variable})
\end{lisp}
proclaims \emph{variable} to be \cdf{special} (see \cdf{proclaim}),
and may perform other system-dependent bookkeeping actions.

If no \emph{initial-value} form is provided, \cdf{defvar}
does not change the value of the \emph{variable};
if no \emph{initial-value} form is provided and the variable
has no value, \cdf{defvar} does not give it a value.

If a second argument form is supplied,
\begin{lisp}
(defvar \emph{variable} \emph{initial-value})
\end{lisp}
then \emph{variable} is initialized to the result of evaluating the form
\emph{initial-value} unless it already has a value.  The \emph{initial-value} form
is not evaluated unless it is used; this fact is useful if
evaluation of the \emph{initial-value} form does something
expensive like creating a large data structure.

\begin{newer}
X3J13 voted in June 1987 \issue{DEFVAR-INIT-TIME} to clarify that
evaluation of the \emph{initial-value} and the initialization of the
variable occur, if at all, at the time the \cdf{defvar} form is executed,
and that the \emph{initial-value} form is evaluated
if and only if the \emph{variable} does not already have a value.
\end{newer}
The initialization is
performed by assignment and thus assigns a global value to the variable
unless there are currently special bindings of that variable.
Normally there should not be any such special bindings.

\cdf{defvar} also provides a good place to put a comment describing the
meaning of the variable, whereas an ordinary \cdf{special} proclamation
offers the
temptation to declare several variables at once and not have room to
describe them all.
\begin{lisp}
(defvar *visible-windows* 0 \\
~~"Number of windows at least partially visible on the screen")
\end{lisp}

\cdf{defparameter} is similar to \cdf{defvar}, but \cdf{defparameter} requires
an \emph{initial-value} form, always evaluates the form, and assigns the
result to the variable.  The semantic distinction is that \cdf{defvar}
is intended to declare a variable changed by the program, whereas
\cdf{defparameter} is intended to declare a variable that is normally
constant but can be changed (possibly at run time), where such a change
is considered a
change \emph{to} the program.  \cdf{defparameter} therefore does not indicate
that the quantity \emph{never} changes; in particular, it does not license
the compiler to build assumptions about the value into programs being
compiled.

\cdf{defconstant} is like \cdf{defparameter} but \emph{does} assert that
the value of the variable \emph{name} is fixed and does license
the compiler to build assumptions about the value into programs being
compiled.  (However, if the compiler chooses to replace references
to the name of the constant by the value of the constant in code
to be compiled, perhaps in order to allow further optimization,
the compiler must take care that such ``copies'' appear to be \cdf{eql}
to the object that is the actual value of the constant.  For example,
the compiler may freely make copies of numbers but must exercise
care when the value is a list.)

It is an error if there are any special bindings
of the variable at the time the \cdf{defconstant} form
is executed (but implementations may or may not check for this).

Once a name has been declared by \cdf{defconstant} to be constant,
any further assignment to or binding of that special variable is an error.
This is the case for such system-supplied constants as \cdf{t} and
\cdf{most-positive-fixnum}.
A compiler may also choose to issue warnings about bindings of
the lexical variable of the same name.

\begin{new}
X3J13 voted in January 1989
\issue{DEFCONSTANT-SPECIAL}
to clarify the preceding paragraph by specifying
that it is an error to rebind constant symbols
as either lexical or special variables.
Consequently, a valid reference to a symbol declared with \cdf{defconstant}
always refers to its global value.
(Unfortunately, this violates the principle of referential transparency,
for one cannot always choose names for lexical variables without regard
to surrounding context.)
\end{new}

For any of these constructs,
the documentation should be a string.  The string is attached
to the name of the variable, parameter, or constant
under the \cdf{variable} documentation type; see the \cdf{documentation}
function.

The \emph{documentation-string}
is not evaluated but must appear as a literal string when the \cdf{defvar},
\cdf{defparameter}, or \cdf{defconstant} form is evaluated.

For example,
the form
\begin{lisp}
(defvar *avoid-registers* nil "Compilation control switch \#43")
\end{lisp}
is legitimate, but
\begin{lisp}
(defvar *avoid-registers* nil \\*
~~(format nil "Compilation control switch \#{\Xtilde}D" \\*
~~~~~~~~~~(incf *compiler-switch-number*)))
\end{lisp}
is erroneous because the call to \cdf{format} is not a literal string.

(On the other hand, the form
\begin{lisp}
(defvar *avoid-registers* nil \\*
~~\#.(format nil "Compilation control switch \#{\Xtilde}D" \\*
~~~~~~~~~~~~(incf *compiler-switch-number*)))
\end{lisp}
might be used to accomplish the same purpose, because the call to
\cdf{format} is evaluated at \cdf{read} time; when the \cdf{defvar} form
is evaluated, only the result of the call to \cdf{format}, a string,
appears in the \cdf{defvar} form.)

These constructs are normally used only as top-level forms.  The
value returned by each of these constructs is the \emph{name} declared.
\end{defmac}

\subsection{Control of Time of Evaluation}

\begin{defspec}
eval-when ({situation}*) {form}*

  The body of an \cdf{eval-when} form is processed as an implicit \cdf{progn}, but
  only in the situations listed.  Each \emph{situation} must be a symbol,
  either \cd{:compile-toplevel},
  \cd{:load-toplevel}, or \cd{:execute}.

  The use of \cd{:compile-toplevel} and \cd{:load-toplevel}
  controls whether and when processing
  occurs for top-level forms. The use of \cd{:execute} controls whether
  processing occurs for non-top-level forms.

  The \cdf{eval-when} construct may be more precisely understood in terms of
  a model of how the file compiler, \cdf{compile-file}, processes forms in a
  file to be compiled.

  Successive forms are read from the file by the file compiler using 
  \cdf{read}. These top-level forms are normally processed in what we call
  ``not-compile-time'' mode. There is one other mode, called 
  ``compile-time-too'' mode, which can come into play for top-level
  forms. The \cdf{eval-when} special operator is used to annotate a program
  in a way that allows the program doing the processing to select
  the appropriate mode.

  Processing of top-level forms in the file compiler works as follows:

\begin{itemize}
   \item If the form is a macro call, it is expanded and the result is
     processed as a top-level form in the same processing mode
     (compile-time-too or not-compile-time).

   \item If the form is a \cdf{progn} (or \cdf{locally} \issue{LOCALLY-TOP-LEVEL})
     form, each of its body forms is
     sequentially processed as top-level forms in the same processing
     mode.

   \item If the form is a \cdf{compiler-let}, \cdf{macrolet},
     or \cdf{symbol-macrolet},
     the file compiler makes the appropriate bindings and recursively
     processes the body forms as an implicit top-level \cdf{progn} with those 
     bindings in effect, in the same processing mode.

   \item If the form is an \cdf{eval-when} form, it is handled according to
     the following table:
     \begin{flushleft}
     \begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}c@{}cccl@{}}
     LT&CT&EX&CTTM&Action \\ \hlinesp
       yes & yes &--   & --  &    process body in compile-time-too mode \\
       yes & no  &yes  & yes &    process body in compile-time-too mode \\
       yes & no  &--   & no  &    process body in not-compile-time mode \\
       yes & no  &no   & --  &    process body in not-compile-time mode \\
       no  & yes &--   & --  &    evaluate body \\
       no  & no  &yes  & yes &    evaluate body \\
       no  & no  &--   & no  &    do nothing \\
       no  & no  &no   & --  &    do nothing \\
       \hline
     \end{tabular*}
     \end{flushleft}
     In the preceding table the column LT asks whether \cd{:load-toplevel}
     is one of the situations specified in the \cdf{eval-when} form;
     CT similarly refers to \cd{:compile-toplevel} and EX to \cd{:execute}.
     The column CTTM asks whether the \cdf{eval-when} form was encountered
     while in compile-time-too mode.  The phrase
     ``process body'' means to process the body as an implicit top-level
     \cdf{progn} in the indicated mode, and  ``evaluate body'' means to
     evaluate the body forms sequentially as an
     implicit \cdf{progn} in the dynamic execution context of the compiler and
     in the lexical environment in which the \cdf{eval-when} appears.

   \item Otherwise, the form is a top-level form that is not one of the
     special cases.  If in compile-time-too mode, the compiler first
     evaluates the form and then performs normal compiler processing
     on it.  If in not-compile-time mode, only normal compiler
     processing is performed (see section~\ref{COMPILER-SECTION}).
     Any subforms are treated as non-top-level forms.
\end{itemize}

  Note that top-level forms are guaranteed to be processed in the order
  in which they textually appear in the file, and that each top-level
  form read by the compiler is processed before the next is read.
  However, the order of processing (including, in particular, macro
  expansion) of subforms that are not top-level forms is unspecified.

  For an \cdf{eval-when} form that is not a top-level form in the file compiler
  (that is, either in the interpreter, in \cdf{compile}, or in the file
  compiler but not at top level), if the \cd{:execute} situation is specified,
  its body is treated as an implicit \cdf{progn}.  Otherwise, the body
  is ignored and the \cdf{eval-when} form has the value \cdf{nil}.

  For the sake of backward compatibility,
  a \emph{situation} may also be \cdf{compile}, \cdf{load}, or \cdf{eval}.
  Within a top-level \cdf{eval-when} form
  these have the same meaning as \cd{:compile-toplevel}, \cd{:load-toplevel},
  and \cd{:execute}, respectively; but their effect is undefined when used
  in an \cdf{eval-when} form that is not at top level.

  The following effects are logical consequences of the preceding specification:

  \begin{itemize}
   \item It is never the case that the execution of a single \cdf{eval-when}
     expression will execute the body code more than once.

   \item The old keyword \cdf{eval} was a misnomer because execution of
     the body need not be done by \cdf{eval}.  For example, when the
     function definition
     \begin{lisp}
     (defun foo () (eval-when (:execute) (print 'foo)))
     \end{lisp}
     is compiled
     the call to \cdf{print} should be compiled, not evaluated at compile time.

   \item Macros intended for use in top-level forms should arrange for all
     side-effects to be done by the forms in the macro expansion.
     The macro-expander itself should not perform the side-effects.

\begin{lisp}
(defmacro foo () \\*
~~(really-foo)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;{\rm Wrong}\\*
~~{\Xbq}(really-foo)) \\
\\
(defmacro foo () \\*
~~{\Xbq}(eval-when (:compile-toplevel \\*
~~~~~~~~~~~~~~~:load-toplevel :execute)~~~~~;{\rm Right} \\*
~~~~(really-foo)))
\end{lisp}

     Adherence to this convention will mean that such macros will behave
     intuitively when called in non-top-level positions.   

   \item Placing a variable binding around an \cdf{eval-when}
     reliably captures the
     binding because the ``compile-time-too'' mode cannot occur (because 
     the \cdf{eval-when} could not be a top-level form).
     For example,
\begin{lisp}
(let ((x 3)) \\*
~~(eval-when (:compile-toplevel :load-toplevel :execute) \\*
~~~~(print x)))
\end{lisp}
will print 3 at execution (that is, load) time
     and will not print anything at
     compile time.  This is important so that expansions of \cdf{defun} and 
     \cdf{defmacro} can be done in terms of \cdf{eval-when}
     and can correctly capture the lexical environment.
     For example, an implementation might expand a \cdf{defun} form such as
\begin{lisp}
(defun bar (x) (defun foo () (+ x 3)))
\end{lisp}
into
\begin{lisp}
(progn (eval-when (:compile-toplevel) \\*
~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~(setf (symbol-function 'bar) \\*
~~~~~~~~~~~~~~~\#'(lambda (x) \\*
~~~~~~~~~~~~~~~~~~~(progn (eval-when (:compile-toplevel)  \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(compiler::notice-function 'foo \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'())) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
\end{lisp}
     which by the preceding rules would be treated the same as
\begin{lisp}
(progn (eval-when (:compile-toplevel) \\*
~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~(setf (symbol-function 'bar) \\*
~~~~~~~~~~~~~~~\#'(lambda (x) \\*
~~~~~~~~~~~~~~~~~~~(progn (eval-when (:load-toplevel :execute) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
\end{lisp}

\end{itemize}

Here are some additional examples.
\begin{lisp} 
(let ((x 1)) \\*
~~(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~~~(setf (symbol-function 'foo1) \#'(lambda () x))))
\end{lisp}
 The \cdf{eval-when} in the preceding expression is not at top level,
       so only the \cd{:execute}
       keyword is considered.  At compile time, this has no effect.
       At load time (if the \cdf{let} is at top level), or at execution time
       (if the \cdf{let} is embedded in some other form which does not execute
       until later), this sets \cd{(symbol-function 'foo1)} to a function that
       returns \cd{1}.
\begin{lisp}
(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~(let ((x 2)) \\*
~~~~(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~~~~~(setf (symbol-function 'foo2) \#'(lambda () x)))))
\end{lisp}

 If the preceding expression occurs at the top level of a file to be compiled,
       it has \emph{both} a compile time \emph{and} a load-time effect of setting
       \cd{(symbol-function 'foo2)} to a function that returns \cd{2}.
\begin{lisp}
(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~(setf (symbol-function 'foo3) \#'(lambda () 3)))
\end{lisp}
 If the preceding expression occurs at the top level of a file to be compiled,
       it has \emph{both} a compile time \emph{and}
       a load-time effect of setting the
       function cell of \cd{foo3} to a function that returns \cd{3}.
\begin{lisp}
(eval-when (:compile-toplevel) \\*
~~(eval-when (:compile-toplevel)  \\*
~~~~(print 'foo4)))
\end{lisp}
  The preceding expression always does nothing; it simply returns \cdf{nil}.

\begin{lisp}
(eval-when (:compile-toplevel)  \\*
~~(eval-when (:execute) \\*
~~~~(print 'foo5)))
\end{lisp}
  If the preceding form occurs at the top level of a file to be compiled,
       \cd{foo5} is
       printed at compile time. If this form occurs in a non-top-level
       position, nothing is printed at compile time. Regardless of context,
       nothing is ever printed at load time or execution time.

\begin{lisp}
(eval-when (:execute :load-toplevel) \\*
~~(eval-when (:compile-toplevel) \\*
~~~~(print 'foo6)))
\end{lisp}

    If the preceding form occurs at the top level of a file to be compiled,
       \cd{foo6} is
       printed at compile time.  If this form occurs in a non-top-level
       position, nothing is printed at compile time. Regardless of context,
       nothing is ever printed at load time or execution time.
\end{defspec}

%RUSSIAN
\else

\chapter{Структура программы}
\label{PROGS}

В главе~\ref{DTYPES} был рассказано о синтаксисе записи Common Lisp'овых объектов.
А так как все Common Lisp'овые программы также являются и объектами данных, то и
синтаксис у них одинаковый.

Lisp'овые программы составляются из форм и функций. Формы \emph{выполняются}
(относительно некоторого контекста) для получения значений и побочных
эффектов. Функции в свою очередь вызываются с некоторыми аргументами. Это
называется помощью \emph{применени} функции к аргументам. 
Наиболее важный вид форм выполняет вызов функции, и наоборот, функция выполняет
вычисление с помощью выполнения форм.

В данной главе, сначала обсуждаются формы и затем функции. В конце, обсуждаются
операторы <<верхнего уровня (top level)>>. Наиболее важной из этих форм
является \cdf{defun}, цель которой --- создание именных функций (будут
ещё и безымянные).

\section{Формы}

Стандартной единицей взаимодействия с реализацией Common Lisp'а является
\emph{форма}, которая является объектом данных, который выполняется как
программа для вычисления одного или более \emph{значений} (которые также
являются объектами данных). Запросить выполнение можно для \emph{любого}
объекта данных, но не для всех это имеет смысл. Например, символы и списки имеет
смысл выполнять, тогда как массивы обычно нет. Примеры содержательных форм:
\cd{3}, значение которой \cd{3}, и \cd{(+ 3 4)}, значение которой \cd{7}.
Для обозначения этих фактов мы пишем \cd{3} \EV\ \cd{3} и \cd{(+ 3 4)} \EV\
\cd{7}. (\EV\ означает <<вычисляется в>>)

Содержательные формы могут быть разделены на три категории:
самовычисляемые формы, такие как числа,
символы, которые используются для переменных,
и списки. Списки в свою очередь могут быть разделены на три категории:
операторы, 
вызовы макросов,
вызовы функций.

Все стандартные объекты данных Common Lisp, не являющиеся символами и списками
(включая \cdf{defstruct} структуры, определённые без опции \cd{:type}) являются
самовычисляемыми. 

\subsection{Самовычисляемые формы}

Все числа, буквы, строки и битовые векторы являются
\emph{самовычисляемыми} формами.
Когда данный объект вычисляется, тогда объект (или возможно копия в случае с
числами и строковыми символами) возвращается в качестве значения данной
формы. Пустой список {\emptylist}, который также является значением ложь
({\false}), также является самовычисляемой формой: значение {\false} является
{\false}.
Ключевые символы (примечание переводчика: не путать с ключевыми словами в других
языках, в Common Lisp'е это вид символов) также вычисляются сами в себя:
значение \cd{:start} является \cd{:start}.

Деструктивная модификация любого объекта, представленного как
константа с помощью самовычисляемой формы или оператора \cdf{quote},
является ошибкой.

\subsection{Переменные}

В Common Lisp программах символы используются в качестве имён переменных.
Когда символ вычисляется как форма, то в качестве результата возвращается
значение переменной, которую данный символ именовал. Например, после выполнения
\cd{(setq items 3)}, которая присвоила значение \cd{3} переменой именованной
символом \cdf{items}, форма \cdf{items} выполнится в \cd{3} (\cdf{items} \EV\
\cd{3}).
Переменные могут быть \emph{назначены} с помощью \cdf{setq} или \emph{связаны} с
помощью \cdf{let}.
Любая программная конструкция, которая связывает переменную, сохраняет старое
значение переменной, и назначает новое, и при выходе из конструкции
восстанавливается старое значение.

В Common Lisp'е есть два вида переменных. Они называются \cd{лексические} (или
\emph{статические}) и \emph{специальные} (или \emph{динамические}).
В одно время каждая из них или обе переменные с одинаковым именем могут иметь
некоторое значение. На какую переменную ссылается символ при его вычислении,
зависит от контекста выполнения. Главное правило заключается в том, что если
символ вычисляется в тексте конструкции, которая создала \emph{связывание} для
переменной с одинаковым именем, то символ ссылается на переменную, обозначенную
в этом связывании, если же в тексте такой конструкции нет, то символ ссылается
на специальную переменную.

Различие между двумя видами переменных заключается в области видимости и
продолжительности видимости. Лексически связанная переменная может быть использована
\emph{только} в тексте формы, которая установила связывание. Динамически
связанная (специальная) переменная может быть использована в любое
\emph{время} между установкой связи и до выполнения конструкции, которая
упраздняет связывание. Таким образом лексическое связывание переменных
накладывает ограничение на использование переменной только в некоторой текстовой
области (но не на временные ограничения, так связывание продолжает существовать,
пока возможно существование ссылки на переменную). И наоборот, динамическое
связывание переменных накладывает ограничение на временные рамки использования
переменной (но не на текстовую область).
Для более подробной информации смотрите главу~\ref{SCOPE}.

Когда нет связываний, значение, которое имеет специальная
переменная, называется \emph{глобальным} значением (специальной) переменной.
Глобальное значение может быть задано переменной только с помощью назначения,
потому что значение заданное связыванием по определению не глобально.

Специальная переменная может вообще не иметь значения, в таком случае,
говориться, что она \emph{несвязанная}. 
По умолчанию, каждая глобальная переменная является несвязанной, пока значение
не будет назначено явно, за исключением переменных определённых в этой книге или
реализацией, которые уже имеют значения сразу после первого запуска Lisp машины.
Кроме того, существует возможность установки связывания специальной переменной и
затем упразднения этого связывания с помощью функции \cdf{makunbound}. В такой
ситуации переменная также называется <<несвязанной>>, хотя это и неправильно,
если быть точнее, переменная связана, но без значения FIXME. Ссылка на несвязанную
переменную является ошибкой.

Чтение несвязанной переменной или неопределённой функции может быть обработано
при самом высоком уровне безопасности (смотрите свойство \cdf{safety}
декларации \cdf{optimize}). При других уровнях безопасности поведение не
определено.
Таким образом, чтение несвязанной переменной или неопределённой функции должно
сигнализировать ошибку.
(<<Чтение функции>> включает ссылку на функцию используя специальный оператор
\cdf{function}, как для \cdf{f} в форме \cd{(function~f)} и ссылку при вызове
функции, как для \cdf{f} в форме \cd{(f~x~y)}.)

В случае \cdf{inline} функций (в реализациях где они поддерживаются),
выполнение встраивания функци представляет собой чтение функции, таким образом
нет необходимости в проверке \cdf{fboundp} во время исполнения. Иными словами,
результат применения \cdf{fmakunbound} к имени \cdf{inline} функции не определён.


При несвязанной переменой сигнализируется ошибка \cdf{unbound-variable}, и
слот \cdf{name} условия \cdf{unbound-variable} содержит значение имени
переменной, вызвавшей ошибку.

При неопределённой функции сигнализируется ошибка \cdf{unbound-function}, и
слот \cdf{name} условия \cdf{unbound-function} содержит значение имени
переменной, вызвавшей ошибку.

Тип условия \cdf{unbound-slot}, которое унаследовано от \cdf{cell-error},
имеет дополнительный слот \cdf{instance}, который может быть инициализировать
параметром \cd{:instance} в функции \cdf{make-condition}.
Функция \cdf{unbound-slot-instance} предоставляет доступ к этому слоту.

Тип ошибки, по-умолчанию сигнализирующейся для метода обобщённой функции
\cdf{slot-unbound} CLOS, является \cdf{unbound-slot}.
Слот \cdf{instance} условия \cdf{unbound-slot} устанавливается в
соответствующий экземпляр объекта и слот \cdf{name} в соответствующее имя
переменной.

Некоторые глобальные переменные зарезервированы в качестве <<именованных
констант>>.
Они имеют глобальное значение и не могут быть связаны или переназначены.
Например символы {\true} и {\false} зарезервированы.
Этим символам невозможно назначить значение. Также и невозможно связать эти
символы с другими значениями. Символы констант определённых с помощью
\cdf{defconstant} также становятся зарезервированными и не могут быть
переназначены или связаны (но они могут быть переопределены с помощью вызова
\cdf{defconstant}). Ключевые символы также не могут быть переназначены или
связаны, ключевые символы всегда вычисляются сами в себя.

\subsection{Специальные операторы}

Если список выполняется в качестве формы, первым шагом является определение
первого элемента списка. Если первый элемент списка является одним из символов,
перечисленных в таблице~\ref{SPECIAL-FORM-TABLE}, тогда список называется
\emph{специальным оператором}. (Использование слова <<специальный>> никак не
связано с использованием этого слова в фразе <<специальная переменная>>.)

Специальные операторы обычно являются окружениями и управляющими конструкциями.
Каждый специальный оператор имеет свой идиосинкразический синтаксис. Например,
специальный оператор \cdf{if}:
\cd{(if p (+ x 4) 5)} в Common Lisp'е означает то же, что и
<<\textbf{if} \emph{p} \textbf{then} \emph{x}+4 \textbf{else} 5>> означает в
Algol'е.

Выполнение специального оператора обычно возвращает одно или несколько значений, но
выполнение может и вызвать нелокальный выход; смотрите \cdf{return-from},
\cdf{go} и \cdf{throw}.

Множество специальных операторов в Common Lisp'е фиксировано. Создание
пользовательских операторов невозможно. Однако пользователь может
создавать новые синтаксические конструкции с помощью определения макросов.

Множество специальных операторов в Common Lisp'е специально держится малым, потому что
любая программа, анализирующая программы, должна содержать специальные знания о
каждом типе специального оператора. Такие программы не нуждаются в специальных
знаниях о макросах, так как раскрытие макроса просто, и далее остаётся только
оперирование с результатом раскрытия. (Это не значит, что программы, в
частности, компиляторы, не будут иметь специальных знаний о макросах. Компилятор
может генерировать боле эффективный код, если он распознает такие конструкции, как
\cdf{typecase} и \cdf{multiple-value-bind} и будет по-особому с ними
обращаться.)

\begin{table}[t]
\caption{Имена всех операторов}
\label{SPECIAL-FORM-TABLE}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lll@{}}
\cdf{block}&\cdf{if}&\cdf{progv} \\
\cdf{catch}&\cdf{labels}&\cdf{quote} \\
&\cdf{let}&\cdf{return-from} \\
\cdf{declare}&\cdf{let*}&\cdf{setq} \\
\cdf{eval-when}&\cdf{macrolet}&\cdf{tagbody} \\
\cdf{flet}&\cdf{multiple-value-call}&\cdf{the} \\
\cdf{function}&\cdf{multiple-value-prog1}&\cdf{throw} \\
\cdf{go}&\cdf{progn}&\cdf{unwind-protect} \\
& &\cdf{symbol-macrolet} \\
&\cdf{locally}&\cdf{load-time-value}
\end{tabular*}
\vskip 4pt
\end{table}

Реализация может исполнять в виде макроса любую конструкцию, описанную здесь как
специальную оператор. И наоборот, реализация может выполнять в виде специального
оператора любую конструкцию, описанную здесь как макрос, при условии, что также 
предоставляется эквивалентное определение макроса.
Практическое значение заключается в том, что предикаты \cdf{macro-function} и
\cdf{special-operator-p} могут оба возвращать истину, принимая один и тот же символ.
Рекомендуется, чтобы программа для анализа других программ обрабатывала форму
являющуюся списком с символом в первой позиции следующим образом:

\begin{enumerate}
\item
  Если программа имеет подробные знания о символе, обрабатывать форму необходимо с
  помощью специализированного кода. Все символы, перечисленные в
  таблице~\ref{SPECIAL-FORM-TABLE} должны попадать под данную категорию.

\item
  В противном случае, если для этого символа \cdf{macro-function} вычисляется в
  истину, необходимо применить \cdf{macroexpand} или \cdf{macroexpand-1} для раскрытия
  формы, и результат вновь анализировать.

\item
  В противном случае, необходимо расценивать форму как вызов функции.
\end{enumerate}

\subsection{Макросы}

Если форма является списком и первый элемент не обозначает специальную
форму, возможно он является именем \emph{макроса}. Если так, то форма
называется \emph{макровызовом или вызовом макроса (macrocall)}. Макрос
это функция, которая принимает формы и возвращает формы. Возвращённые формы
подставляются в то место, где происходил макровызов, и затем выполняются. (Этот
процесс иногда называется \emph{раскрытием макроса}.)
Например, макрос с именем \cdf{return} принимает форму, вот так: \cd{(return x)},
и полученная в результате раскрытия форма такая: \cd{(return-from {\nil} x)}. Мы
говорим: старая форма раскрылась в новую. Новая форма будет вычислена на месте
оригинальной формы. Значение новой формы будет возвращено, как значение
оригинальной формы.

Макровызовы, и подформы макровызовов не обязательно должны быть Ъ списками, но
использование списков с точкой требует совпадения с определением макроса,
например <<\cd{.~\emph{var}}>> или <<\cd{\&rest~\emph{var}}>>.
Таким образом определение макроса с точкой, позволяет корректно обрабатывать
макровызовы и их подформы с точкой.

В Common Lisp'е существует некоторое количество стандартных макросов, и
пользователь может определять свои макросы используя \cdf{defmacro}.

Макросы, предоставляемые реализацией Common Lisp'а и описанные здесь, могут
раскрываться в код, который не будет являться переносимым между реализациями.
Вызов макроса является портабельным, в то время как результат раскрытия нет.

\beforenoterule
\begin{implementation}
Implementors are encouraged to implement the macros
defined in this book, as far as is possible, in such a way that
the expansion will not contain any implementation-dependent
special operators, nor contain as forms data objects that
are not considered to be forms in Common Lisp.
The purpose of this restriction is to ensure that the expansion
can be processed by a program-analyzing program in an
implementation-independent manner.
There is no problem with a macro expansion containing
calls to implementation-dependent functions.
This restriction is not a requirement of Common Lisp; it is recognized
that certain complex macros may be able to expand into significantly
more efficient code in certain implementations
by using implementation-dependent special operators in the macro expansion.
\end{implementation}
\afternoterule

\subsection{Вызовы функций}

Если список выполняется как форма, и первый элемент не является символом,
обозначающим оператор или макрос, тогда предполагается, что список
является \emph{вызовом функции}. Первый элемент списка является именем
функции. Все следующие элементы списка будут вычислены. Одно значение каждого
вычисленного элемента будет является \emph{аргументом} для вызываемой
функции. 
Затем функция будет \emph{применена} к аргументам. Вычисление функции обычно
возвращает значение, однако вместо этого может быть выполнен нелокальный выход,
смотрите \cdf{throw}. Функция может возвращать 0 и более значений, смотрите
\cdf{values}. 
Если и когда функция возвращает значения, они становятся значениями вычисления
формы вызова функции.

Например, рассмотрим вычисление формы: \cd{(+ (* 4 5))}.
Символ \cdf{+} обозначает функцию сложения, а не оператор или макрос.
Таким образом две формы \cd{3} и \cd{(* 4 5)} вычисляются для аргументов. Форма
\cd{3} вычисляется в \cd{3}, а форма \cd{(* 4 5)} является вызовом функции
(умножения). Таким образом формы \cd{4} и \cd{5} вычисляются сами в себя, тем
самым предоставляя аргументы для функции умножения. Функция умножения вычисляет
результат \cd{20} и возвращает его. Значения \cd{3} и \cd{20} становятся
аргументами функции сложения, которая вычисляет и возвращает результат
\cd{23}. Таким образом мы говорим \cd{(+3 (* 4 5)) \EV\ 23}.

Тогда как аргументы в вызове функции всегда выполняются слева направо,
поиск самой функции для вызова может производится как до выполнения аргументов,
так и после. Программы, которые полагаются на тот факт, что поиск функции
осуществляется перед выполнением аргументов, являются ошибочными.

\section{Функции}

Существуют два метода указать функцию для использования в форме вызова
функции. Один из них заключается в указании символа имени функции. Это
использование символов для обозначения функций полностью независимо от их
использования для обозначения специальных и лексических переменных. Другой путь
заключается в использовании \emph{лямбда-выражения}, которое является списком
с первым элементом равным \cdf{lambda}. Лямбда-выражение \emph{не} является
формой, оно не может быть полноценно вычислено. Лямбда выражения и символы,
когда они используются в программах для обозначения функций, могут быть
указаны в качестве первого элемента формы вызова функции, или только в качестве
второго параметры в операторе \cdf{function}. Следует отметить, что
в этих двух контекстах символы и лямбда-выражения обрабатываются, как
\emph{имена} функций. Необходимо отличать это от обработки символов и лямбда
выражений, как \emph{функциональных объектов, или объектов функций (function
  objects)}, которые удовлетворяют предикату \cdf{functionp}, как при
представлении таких объектов в вызовы функций \cdf{apply} или \cdf{funcall}. 

\subsection{Именованные функции}

Функция может иметь два типа имена.
\emph{Глобальное имя} может быть дано функции с помощью конструкции
\emph{defun}.
\emph{Локальное имя} может быть дано функции с помощью операторов
\cdf{flet} или \cdf{labels}.
Когда для функции задаётся имя, то с этим именем связывается лямбда-выражение с
информацией о сущностях, которые были лексически доступны на момент связи.
Если в качестве первого элементы формы вызова функции используется символ, тогда
он ссылается на определение функции из наиболее ближней формы \cdf{flet} или
\cdf{labels}, которые в своем тексте содержат эту форму, иначе символ ссылается на
глобальное определение функции, при отсутствии вышеназванных форм.

\subsection{Лямбда-выражения}
\label{LAMBDA-EXPRESSIONS-SECTION}
\indexterm{lambda-expression}
\indexterm{lambda-list}
% \indexterm{{\&optional!Символ}}
% \indexterm{{\&rest!Символ}}
% \indexterm{{\&key!Символ}}
% \indexterm{{\&allow-other-keys!Символ}}
% \indexterm{{\&aux!Символ}}

\label{lambda-expression}
\label{lambda-list}
\label{optional}
\label{rest}
\label{key}
\label{allow-other-keys}
\label{aux}

\emph{Лямбда-выражение} является списком со следующим синтаксисом:
\begin{lisp}
(lambda \emph{lambda-list} . \emph{body})
\end{lisp}
Первый элемент должен быть символом \cdf{lambda}. Второй элемент должен быть
списком. Он называется \emph{лямбда-списком}, и задаёт имена для
\emph{параметров} функции. Когда функция, обозначенная лямбда-выражением,
применяется к аргументам, аргументы подставляются в соответствии с
лямбда-списком. \emph{body} может впоследствии ссылаться на аргументы используя
имена параметров. \emph{body} состоит из любого количества форм (возможно
нулевого количества). Эти формы выполняются последовательно, и в качестве
значения возвращается результат только \emph{последней} формы (в случае отсутствия
форм, возвращается {\false}).
Полный синтаксис лямбда-выражения:

\begingroup
\def\GrossOptVars{\Mstar{\emph{var} {\Mor} \cd{(}\emph{var} \Mopt{\emph{initform} \Mopt{\emph{svar}}}\cd{)}}}
\def\GrossKeyOptVars{\Mstar{\emph{var} {\Mor} \cd{(}\Mgroup{\emph{var} {\Mor} \cd{(}\emph{keyword} \emph{var}\cd{)}} \Mopt{\emph{initform} \Mopt{\emph{svar}}}\cd{)}}}
\def\GrossAuxVars{\Mstar{\emph{var} {\Mor} \cd{(}\emph{var} \Mopt{\emph{initform}}\cd{)}}}
\begin{lisp}
(lambda (\Mstar{\emph{var}} \\*
~~~~~~~~~\Mopt{\cd{\&optional} \GrossOptVars} \\*
~~~~~~~~~\Mopt{\cd{\&rest} \emph{var}} \\*
~~~~~~~~~\Mopt{\cd{\&key} \GrossKeyOptVars 
~~~~~~~~~~~~~~\Mopt{\cd{\&allow-other-keys}}} \\*
~~~~~~~~~\Mopt{\cd{\&aux} \GrossAuxVars}) \\*
~~~\Mchoice{\Mstar{\emph{declaration}} {\Mor} \emph{documentation-string}} \\*
~~~\Mstar{\emph{form}})
\end{lisp}
\endgroup

Каждый элемент лямбда-списка является или спецификатором параметра или
\emph{ключевым символом лямбда-списка}. Ключевые символы лямбда-списка
начинаются с символа \cd{\&}.
Следует отметить, что ключевые символы лямбда-списка не является ключевыми
символами в обычном понимании. Они не принадлежат пакету \cdf{keyword}. Они являются
обычными символами, имена которых начинаются амперсандом. Такая терминология
запутывает, но так сложилась история.

\emph{Keyword} в предыдущем определении лябмда-списка может быть любым, а не
только ключевым из пакета \cdf{keyword}, символом. Смотрите ниже.

Лямбда-список имеет пять частей, любая или все могут быть пустыми:

\begin{itemize}
\item
Спецификаторы для \emph{обязательных параметров}. К ним относятся все
спецификаторы параметров до первого ключевого символа лямбда-списка. Если такой
ключевой символ отсутствует, все спецификаторы считаются обязательными.

\item
Спецификаторы для \emph{необязательных} параметров.
Если указан ключевой символ \cd{\&optional}, после него будут следовать спецификаторы
\emph{необязательных} параметров вплоть до следующего ключевого слова, или до
конца списка.

\item
Спецификатор для \emph{неопределённого количества или оставшегося (rest)}
параметра. Если указан ключевой символ \cd{\&rest}, за ним должен следовать
только один спецификатор \emph{оставшегося (rest)} параметра, за которым может
следовать другой ключевой символ или лямбда-список может заканчиваться.

\item
Спецификатор для \emph{именованных (keyword)} параметров. Если указан ключевой
символ \cd{\&key}, все спецификаторы после данного символа до
следующего ключевого символа или конца списка являются спецификаторами
\emph{именованных} параметров. За спецификаторами именованных параметров
опционально может использовать ключевой символ
\cd{\&allow-others-keys}.

\item
Спецификатор для \emph{вспомогательных (aux)} переменных. Они не являются
параметрами. Если указан ключевой символ \cd{\&aux}, все
спецификаторы после него являются спецификаторами вспомогательных переменных.
\end{itemize}

Когда функция, заданная лямбда-выражением, применяется к аргументам, то эти
аргументы и параметры вычисляются слева направо.
В простейшем случае, в лямбда-списке присутствуют только обязательные
параметры. Каждый из них задаётся просто именем переменной \emph{var}
параметра.
Когда функция применяется, аргументов должно быть столько же, сколько и
параметров, и каждый параметр связывается с одним аргументом. В общем случае,
каждый параметр связывается как лексическая переменная, если только с помощью
декларации не указано, что связь должна осуществляться, как для специальной
переменной. Смотрите \cdf{defvar}, \cdf{proclaim}, \cdf{declare}.

В более общем случае, если указано \emph{n} обязательных параметров
(\emph{n} может равняться нулю), тогда должно быть как минимум \emph{n}
аргументов, и обязательные параметры будут связаны с \emph{n} первыми
аргументами.

Если указаны необязательные параметры, тогда каждый из них будет обработан так,
как описано ниже. Если осталось некоторое количество аргументов, тогда
переменная параметра \cd{var} будет связана с оставшимся аргументом. Принцип
такой же, как и для обязательных параметров. Если не осталось аргументов, тогда
выполняется часть \emph{initform}, и переменная
параметра связывается с её результатом (или с {\false}, если форма
\emph{initform} не была задана).
Если в спецификаторе указано имя ещё одной переменной \emph{svar}, то она
связывается с \emph{true}, если аргумент был задан, и с \emph{false}
аргумент не был задан (и в таком случае выполнилась \emph{initform}).
Переменная \emph{svar} называется \emph{supplied-p} параметр. Она
связывается не с аргументом, а со значением, которое показывает был ли задан
аргумент для данного параметра или нет.

После того, как все \emph{необязательные} параметры были обработаны, может
быть указан \emph{оставшийся (rest)} параметр.
Если \emph{оставшийся (rest)} параметр указан, он будет связан со списком все
оставшихся необработанных аргументов. Если таких аргументов не осталось,
\emph{оставшийся (rest)} параметр будет связан с пустым списком. Если в лямбда
списке отсутствуют \emph{оставшийся (rest)} параметр и \emph{именованные
  (keyword)} параметры, то необработанных аргументов оставаться не должно (иначе
будет ошибка).

\begin{new}
X3J13 voted in January 1989
\issue{REST-LIST-ALLOCATION}
to clarify that if a function has a \emph{rest} parameter
and is called using \cdf{apply}, then the list to which the
\emph{rest} parameter is bound is permitted, but not required,
to share top-level list structure with the list that was the last
argument to \cdf{apply}.  Programmers should be careful about performing
side effects on the top-level list structure of a \emph{rest} parameter.

This was the result of a rather long discussion within X3J13 and the
wider Lisp community.  To set it in its historical context, I must remark
that in Lisp Machine Lisp the list to which a \emph{rest} parameter was
bound had only dynamic extent; this in conjunction with the
technique of ``cdr-coding'' permitted a clever stack-allocation technique
with very low overhead.  However, the early designers of
Common Lisp, after a great deal of debate, concluded that it was dangerous
for cons cells to have dynamic extent; as an example, the ``obvious''
definition of the function \cdf{list}
\begin{lisp}
(defun list (\&rest x) x)
\end{lisp}
could fail catastrophically.  Therefore the first edition simply implied
that the list for a \emph{rest} parameter, like all other lists, would
have indefinite extent.  This still left open the flip side of the
question, namely, Is the list for a \emph{rest} parameter guaranteed fresh?
This is the question addressed by the X3J13 vote.
If it is always freshly consed, then it is permissible to destroy it,
for example by giving it to \cdf{nconc}.  However, the requirement always
to cons fresh lists could impose an unacceptable overhead in many implementations.
The clarification approved by X3J13 specifies that the programmer may
not rely on the list being fresh; if the function was called using \cdf{apply},
there is no way to know where the list came from.
\end{new}

Далее обрабатываются все \emph{именованные (keyword)} параметры.
Для этих параметров обрабатываются те же аргументы, что и для
\emph{оставшегося (rest)} параметра.
Безусловно, возможно указывать и \cd{\&rest} и \cd{\&key}. В таком случае
оставшиеся аргументы используются для обеих целей:
все оставшиеся аргументы составляются в список для \cd{\&rest} параметра и они
также обрабатываются, как \cd{\&key} параметры. Только в этой ситуации один
аргумент может обрабатываться более чем для одного параметра.
Если указан \cd{\&key}, должно остаться чётное количество аргументов. Они будут
обработаны попарно. Первый аргумент в паре должен быть ключевым символом,
который задаёт имя параметра, второй аргумент должен быть соответствующим
значением.

Именованный параметр в лямбда-списке может быть любым символом, а не только
ключевым символом из пакета \cdf{keyword}. Если после \cd{\&key} используется
только переменная или переменная в круглых скобках (возможно с первоначальным
значением и \emph{svar}), то поведение такое же как и было: для задания
именованного параметра используется ключевой символ с тем же именем, что и
переменная. Если спецификатор параметра выглядит так: \cd{((\emph{keyword}
  \emph{var})~...)} то имя параметра может не быть ключевым символом из пакета
\cdf{keyword}.
Например:
\begin{lisp}
(defun wager (\&key ((secret password) nil) amount) \\*
~~(format nil "Вы {\Xtilde}A \${\Xtilde}D" \\*
~~~~~~~~~~(if (eq password 'joe-sent-me) "выиграли" "проиграли") \\*
~~~~~~~~~~amount)) \\
\\
(wager :amount 100) \EV\ "Вы проиграли \$100" \\*
(wager :amount 100 'secret 'joe-sent-me) \EV\ "Вы выиграли \$100"
\end{lisp}
В данном примере слово \cdf{secret} может быть сделано более секретным, если
поместить его в некоторый пакет \cdf{obscure}. Тогда для выигрыша можно будет
использовать это так:
\begin{lisp}
(wager :amount 100 'obscure:secret 'joe-sent-me) \EV\ "Вы выиграли \$100"
\end{lisp}

В каждом именованном параметре спецификатор должен быть назван \emph{var} для
переменной параметра. FIXME
Если явно указан ключевой символ, тогда он будет использоваться для имени
параметра. В противном случае используется имя переменной \cdf{var} для поиска
ключевого символа в аргументах. Таким образом:
\begin{lisp}
(defun foo (\cd{\&key} radix (type 'integer)) ...)
\end{lisp}
означает то же, что и
\begin{lisp}
(defun foo (\cd{\&key} ((:radix radix)) ((:type type) 'integer)) ...)
\end{lisp}

Спецификатор именованного (keyword) параметра, как и все спецификаторы
параметров, обрабатывается слева направо.
Для каждого спецификатора именованного параметра, если в паре аргумента, в
которой ключевой символ совпадает с именем параметра (сравнение производится с
помощью \cdf{eq}), тогда переменная параметра связывается значением из этой
пары.
Если имеется более одной пар аргументов с одинаковым именем, то это не ошибка. В
таком случае используется наиболее левая пара.
Если пары аргументов не нашлось, тогда выполняется \emph{initform} и
переменная параметра связывается с этим значением (или с {\false}, если
\emph{initform} не задана). Переменная \emph{svar} используется в тех же
целях, что и для \emph{необязательных} параметров. Она будет связана с
\emph{истиной}, если была необходимая пара аргументов, и иначе --- с \emph{ложью}.

Если пара аргументов содержит ключевой символ, который не
присутствует в спецификаторах параметров в лямбда списке, то или возникнет
ошибка или возможны следующие условия:
\begin{itemize}
\item
В лямбда-списке был указан \cd{\&allow-other-keys}.

\item
Где-то среди именованных аргументов есть пара, в которой есть ключевой символ
\cd{:allow-other-keys} и значение не равно {\false}.
\end{itemize}

В случае возникновения одного из этих условий, можно использовать именованные
аргументы, которые не имеют соответствующих параметров (эти аргументы будут
доступны, как оставшийся \cd{\&rest} параметр). 
Целью этого механизма является возможность объединять лямбда-списки разных
функции без необходимости копировать все спецификаторы именованных (keyword)
параметров. Например функция обёртка может передать часть именованных аргументов
в обернутую функцию без необходимости явного ручного указания их всех. 

После того как все спецификаторы были обработаны, слева направо обрабатываются
спецификаторы вспомогательных параметров. Для каждого из них выполняется
\emph{initform} и переменная \emph{var} связывается с этим результатом (или
с {\false}, если \emph{initform} не определена). С \cd{\&aux} переменными
можно делать то же, что и со оператором \cdf{let*}:
\begin{lisp}
(lambda (x y \&aux (a (car x)) (b 2) c) ...) \\
~~~\EQ\ (lambda (x y) (let* ((a (car x)) (b 2) c) ...))
\end{lisp}

Что использовать зависит только от стиля.

Когда какая-либо форма \emph{initform} выполняется в каком-либо спецификаторе
параметра, данная форма может ссылаться на любую переменную параметра, стоящую
слева от данной формы, включая supplied-p переменные, и может рассчитывать на
то, что другие переменные параметров ещё не связаны (включая переменную данного
параметра).

После того как был обработан лямбда-список, выполняются формы из тела
лямбда-выражения. Эти формы могут ссылаться на аргументы функции, используя
имена параметров. При выходе из функции, как с помощью нормального возврата, так
и с помощью нелокального выхода, связывания параметров, и лексические, и
специальные, упраздняются. В случае создания <<замыкания>> над данными
связываниями, связи упраздняются не сразу, а сначала сохраняются, чтобы потом
быть вновь восстановленными. 

\noindent
Примеры использования \cd{\&optional} и \cd{\&rest} параметров:
\begin{lisp}
((lambda (a b) (+ a (* b 3))) 4 5) \EV\ 19 \\
((lambda (a \cd{\&optional} (b 2)) (+ a (* b 3))) 4 5) \EV\ 19 \\
((lambda (a \cd{\&optional} (b 2)) (+ a (* b 3))) 4) \EV\ 10 \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x))) \\*
~~~\EV\ (2 {\false} 3 {\false} {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6) \\*
~~~\EV\ (6 t 3 {\false} {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3) \\*
~~~\EV\ (6 t 3 t {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3 8) \\*
~~~\EV\ (6 t 3 t (8)) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3 8 9 10 11) \\*
~~~\EV\ (6 t 3 t (8 9 10 11))
\end{lisp}
Примеры \cd{\&key} параметров:
\begin{lisp}
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2) \\*
~~~\EV\ (1 2 {\nil} {\nil}) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :c 6) \\*
~~~\EV\ (1 2 6 {\nil}) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :d 8) \\*
~~~\EV\ (1 2 {\nil} 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :c 6 :d 8) \\*
~~~\EV\ (1 2 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :d 8 :c 6) \\*
~~~\EV\ (1 2 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) :a 1 :d 8 :c 6) \\*
~~~\EV\ (:a 1 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) :a :b :c :d) \\
~~~\EV\ (:a :b :d {\nil})
\end{lisp}
Пример смешения всех:
\begin{lisp}
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1)   \EV\ (1 3 {\nil} 1 ())
\end{lisp}

\begin{lisp}
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 2)   \EV\ (1 2 {\nil} 1 ()) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~:c 7)   \EV\ (:c 7 {\nil} :c ()) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :c 7)   \EV\ (1 6 7 1 (:c 7)) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :d 8)   \EV\ (1 6 {\nil} 8 (:d 8)) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :d 8 :c 9 :d 10)   \EV\ (1 6 9 8 (:d 8 :c 9 :d 10))
\end{lisp}

В лямбда-выражении, если оно стоит на первом месте в списке формы вызова функции,
допускаются все ключевые символы лямбда-списка, хотя они и не очень-то полезны в
таком контексте.
Гораздо полезнее их использовать в глобальных функциях, определённых с помощью
\cdf{defun}.

Все символы, что начинаются на \cd{\&} обычно зарезервированы для использования в
качестве ключевых символов лямбда-списка, и не должны использоваться для имён
переменных.
Реализации Common Lisp'а могут также предоставлять свои дополнительные ключевые
символы лямбда-списка.

\begin{defun}[Константа]
lambda-list-keywords

Значение \cdf{lambda-list-keywords} является списком всех ключевых символов
лямбда-списка, используемых в данной реализации, включая те, которые
используются только в \cdf{defmacro}. Этот список должен содержать как минимум
символы \cd{\&optional}, \cd{\&rest}, \cd{\&key}, \cd{\&allow-other-keys},
\cd{\&aux}, \cd{\&body}, \cd{\&whole} и \cd{\&environment}.
\end{defun}

Вот пример использования \cd{\&allow-other-keys} и \cd{:allow-other-keys}, 
рассматривающий функцию, которая принимает два своих именованных аргумента и
также дополнительные именованные аргументы, которые затем передаются
\cdf{make-array}:
\begin{lisp}
(defun array-of-strings (str dims \cd{\&rest} keyword-pairs \\*
~~~~~~~~~~~~~~~~~~~~~~~~~\cd{\&key} (start 0) end \cd{\&allow-other-keys}) \\*
~~(apply \#'make-array dims \\*
~~~~~~~~~:initial-element (subseq str start end) \\
~~~~~~~~~:allow-other-keys t \\*
~~~~~~~~~keyword-pairs))
\end{lisp}

Такая функция принимает строку и информацию о размерности и возвращает массив с
заданной размерностью, каждый из элементов которого равен заданной
строке. Именованные аргументы \cd{:start} и \cd{:end}, как обычно (смотрите
главу~\ref{KSEQUE}), можно использовать для указания того, что должна
использоваться подстрока. Кроме того, использование \cd{\&allow-other-keys} в
лямбда списке указывает на то, что вызов этой функции может содержать
дополнительные именованные аргументы. Для доступа к ним используется \cd{\&rest}
аргумент. Эти дополнительные именованные аргументы передаются в
\cdf{make-array}. \cdf{make-array} не принимает именованные аргументы
\cd{:start} и \cd{:end}, и было бы ошибкой допустить их использование. Однако
указание \cd{:allow-other-keys} равное не-{\false} значению позволяет передавать
любые другие именованные аргументы, включая \cd{:start} и \cd{:end}, и они были
бы приняты и проигнорированы.

\begin{defun}[Константа]
lambda-parameters-limit

Значение \cdf{lambda-parameters-limit} является положительным целым, которое
невключительно является верхней границей допустимого количества имён параметров,
которые могут использоваться в лямбда-списке.
Значение зависит от реализации, но не может быть менее 50.
Разработчики поощряются за создание данной границы как можно большей без потери
производительности.
Смотрите \cdf{call-arguments-list}.
\end{defun}

\section{Формы верхнего уровня}

Стандартный путь взаимодействия с реализацией Common Lisp через
\emph{цикл чтение-выполнение-печать} (\emph{read-eval-print loop}): система
циклично считывает форму из некоторого источника ввода (клавиатура, файл),
выполняет её, затем выводит результат(ы) в некоторое устройство вывода (дисплей,
другой файл). Допускается любая форма (выполняемый объект данных), однако
существуют некоторые ормы разработанные для удобного применения в качестве форм 
\emph{верхнего уровня}.
Эти операторы верхнего уровня могут использоваться для определения
глобальных функции (globally named functions), макросов, создания деклараций и
определения глобальных значений для специальных переменных.

While defining forms normally appear at top level,
it is meaningful to place them in non-top-level contexts.
All defining forms that create functional objects from code appearing
as argument forms must ensure that
such argument forms refer to the enclosing lexical environment.
Compilers must handle defining forms properly in all situations,
not just top-level contexts.  However, certain
compile-time side effects of these defining forms are performed only
when the defining forms occur at top level (see section~\ref{COMPILER-SECTION}).

Макросы обычно определяются с помощью оператора \cdf{defmacro}.
Этот механизм достаточно сложен. Для подробностей смотрите главу~\ref{MACROS}.

\subsection{Определение функций}

Оператор \cdf{defun} служит для определения функций.

\begin{defmac}
defun name lambda-list
  <{declaration}* | doc-string>
  {form}*

Выполнение формы \cdf{defun} приводит к тому, что символ \emph{name}
становиться глобальным именем для функции определённой лямбда-выражением.
\begin{lisp}
(lambda \emph{lambda-list} \Mstar{\emph{declaration} {\Mor} \emph{doc-string}} \Mstar{\emph{form}})
\end{lisp}
определяется в лексическом окружении, в котором выполнялась форма
\cdf{defun}. А так как формы \cdf{defun} обычно выполняются на самом верхнем
уровне, лямбда-выражение обычно выполняется в нулевом лексическом окружении.

Тогда как данная форма обычно используется на самом верхем уровне, ее можно
также использовать внутри других форм. \cdf{defun} может определять функцию
внутри некоторого, не нулевого, лексического окружения.

\cdf{defun} в качестве параметра \emph{name} принимает любое имя функции (символ
или список, у которого \emph{car} элемент равен \cdf{setf}---смотрите
раздел~\ref{FUNCTION-NAME-SECTION}).
Так теперь для определения \cdf{setf}-оператора для функции \cdf{cadr} можно записать
\begin{lisp}
(defun (setf cadr) ...)
\end{lisp}
Это удобнее, чем использование \cdf{defsetf} или \cdf{define-modify-macro}.

Если указана необязательная строка документации \emph{doc-string}, тогда она
присоединяется к символу \emph{name} в качестве строки документации типа
\cdf{function}. Смотрите \cdf{documentation}. Если после \emph{doc-string} нет
деклараций, строка документации может быть использована только при условии
существования хотя бы одной формы после неё, иначе она будет использована в
качестве форм \emph{form} функции. Указывать более чем одну строку
\emph{doc-string} является ошибкой.

Формы \emph{forms} составляют тело определяемой функции. Они выполняются как
неявный \cdf{progn}.

Тело определяемой функции неявно заключается в конструкцию \cdf{block}, имя
которой совпадает с \emph{именем (name)} функции. Таким образом для выхода из функции
может быть использовано выражение\cdf{return-from}.

В некоторых реализациях в \cdf{defun} могут также выполняться другие специальные
учётные действия. \emph{name} возвращается в качестве значения формы \cdf{defun}.
Например:
\begin{lisp}
(defun discriminant (a b c) \\
~~(declare (number a b c)) \\
~~"Вычисляет дискриминант квадратного уравнения. \\
~~~Получает a, b и c и если они являются действительными числами (не комплексными), \\
~~~ вычисляет значение b{\Xcircumflex}2-4*a*c. \\
~~~Квадратное уравнение a*x{\Xcircumflex}2+b*x+c=0 имеет действительные, multiple, \\
~~~или комплексные корни в зависимости от того, какое соответственно значение было получено \\
~~~положительное, ноль или отрицательное." \\
~~(- (* b b) (* 4 a c))) \\
~~~\EV\ discriminant \\
~~~\textrm{теперь} (discriminant 1 2/3 -2) \EV\ 76/9
\end{lisp}

Пользователю разрешено использовать \cdf{defun} для переопределения функции, например, для
установки корректной версии некорректного определения.
Пользователю также разрешено переопределять макрос на функцию.
Однако попытка переопределить имя оператора (смотрите
таблицу~\ref{SPECIAL-FORM-TABLE}) на функцию является ошибкой.
\end{defmac}

\subsection{Определение глобальных переменных и констант}

Для определения глобальных переменных используются операторы
\cdf{defvar} и \cdf{defparameter}. 
Для определения констант используется оператор \cdf{defconstant}. 

\begin{defmac}
defvar name [initial-value [documentation]] \\
defparameter name initial-value [documentation] \\
defconstant name initial-value [documentation]

\cdf{defvar} рекомендуется для декларации использования в программе специальных
переменных.
\begin{lisp}
(defvar \emph{variable})
\end{lisp}
указывает на то, что переменная \emph{variable} будет специальной
(\cdf{special}) (смотрите \cdf{proclaim}), и может выполнять некоторые учётные
действия, зависимые от реализации.

Если \emph{initial-value} не было указано, \cdf{defvar} не изменяет значение
переменной \emph{variable}. 
Если \emph{initial-value} не было указано и переменная не имела значения,
\cdf{defvar} не устанавливает значение.

Если для формы указан второй аргумент,
\begin{lisp}
(defvar \emph{variable} \emph{initial-value})
\end{lisp}
тогда переменная \emph{variable}, если она ещё не была проинициализирована,
инициализируется результатом выполнения формы \emph{initial-value}. Форма
\emph{initial-value} не выполняется, если в этом нет необходимости. Это
полезно, если форма \emph{initial-value} выполняет что-то
трудоёмкое, как, например, создание большой структуры данных.

Если не существует специального связывания этой переменной, инициализация
производится присвоением глобального значения переменной. 
Обычно, такого связывания быть не должно. FIXME.

\cdf{defvar} также предоставляют хорошее место для комментария, описывающего
значение переменной, тогда как обычное \cd{special} указание соблазняет
задекларировать несколько переменных за один раз и не предоставляет возможности
прокомментировать их.
\begin{lisp}
(defvar *visible-windows* 0 \\
~~"Количество видимых окон на экране")
\end{lisp}

\cdf{defparameter} подобна \cdf{defvar}, но \cdf{defparameter} требует
обязательной формы \emph{initial-value}, и, выполняя эту форму присваивает
результат переменной. Семантическое различие заключается в том, что 
\cdf{defvar} предназначена декларировать переменную, изменяемую программой,
тогда как \cdf{defparameter} предназначена для декларации переменной, как
константы, которая может быть изменена (и во время выполнения программы), для
изменения поведения программы. Таким образом \cdf{defparameter} не указывает,
что количество никогда не изменяется, в частности, она не разрешает 
компилятору предположить то, что значение может быть вкомпилировано в
программу.

\cdf{defconstant} похожа на \cdf{defparameter}, но в отличие от последней,
указывает, что значение переменной \emph{name} фиксировано и позволяет
компилятору предположить, что значение может быть вкомпилировано в
программу. Однако, если компилятор  для оптимизации выбирает путь замены ссылок
на имя константы на значения этой константы в компилируемом коде, он должен
позаботиться о том, чтобы такие <<копии>> были эквивалентны \cdf{eql}
объектам-значениям констант. Например, компилятор может спокойно копировать
числа, но должен позаботиться об этом правиле, если значение константы
является списком.

Если для переменной на момент вызова формы \cdf{defconstant} существует
специальные связывания, то возникает ошибка (но реализации могут проверять, а
могут и не проверять этот факт).

Если имя задекларировано с помощью \cdf{defconstant},
последующие присваивания и связывания данной специальной переменной будут
являться ошибкой. Это справедливо для системозависимых констант, например,
\cdf{t} и \cdf{most-positive-fixnum}.
Компилятор может также сигнализировать о связывании лексической переменной с
одинаковым именем.

Для любой из этих конструкций, документация должна быть строкой. Строка
присоединяется к имени переменной, параметра или константы как тип документации
\cdf{variable}, смотрите функцию \cdf{documentation}.

\emph{documentation-string}
не выполняется и должна представлять строку, когда выполняется \cdf{defvar},
\cdf{defparameter} или \cdf{defconstant}.

Например, форма
\begin{lisp}
(defvar *avoid-registers* nil "Compilation control switch \#43")
\end{lisp}
законна, но
\begin{lisp}
(defvar *avoid-registers* nil \\*
~~(format nil "Compilation control switch \#{\Xtilde}D" \\*
~~~~~~~~~~(incf *compiler-switch-number*)))
\end{lisp}
ошибочна, так как вызов \cdf{format} не является дословно строкой.

С другой стороны, форма
\begin{lisp}
(defvar *avoid-registers* nil \\*
~~\#.(format nil "Compilation control switch \#{\Xtilde}D" \\*
~~~~~~~~~~~~(incf *compiler-switch-number*)))
\end{lisp}
может использоваться для вышеназванной цели, потому что вызов \cdf{format}
выполняется на во время чтения кода \cdf{read}, когда форма \cdf{defvar}
выполняется, в ней указана строка, которая являлась результатом вызова
\cdf{format}.

Эти конструкции обычно используются только как формы верхнего уровня. Значения,
возвращаемые каждой из этих конструкций, это задекларированные имена \emph{name}.
\end{defmac}

\subsection{Контроль времени выполнения}

\begin{defspec}
eval-when ({situation}*) {form}*

Тело формы \cdf{eval-when} выполняется как неявный \cdf{progn}, но только в
перечисленных ниже ситуациях. Каждая ситуация \emph{situation} должна быть
одним символов, \cd{:compile-toplevel}, \cd{:load-toplevel} или \cd{:execute}.

Использование \cd{:compile-toplevel} и \cd{:load-toplevel} контролирует, что и
когда выполняется для форм верхнего уровня. Использование \cd{:execute}
контролирует будет ли производится выполнения форм не верхнего уровня.

Конструкция \cdf{eval-when} может быть более понятна в терминах модели того,
как компилятор файлов, \cdf{compile-file}, выполняет формы в файле для
компиляции.

Формы следующие друг за другом читаются из файла с помощью компилятора
файла используя \cdf{read}. Эти формы верхнего уровня обычно
обрабатываются в том, что мы называем режим <<времени некомпиляции
(not-compile-time mode)>>. Существует и другой режим, называемый режим
<<времени-компиляции (compile-time-too mode)>>, которые вступает в
игру для форм верхнего уровня. Оператор \cdf{eval-when} используется
выбора режима(ов), в котором происходит выполнение кода.

Обработка форм верхнего уровня в компиляторе файла работает так, как
рассказано ниже:

\begin{itemize}

\item Если форма является макровызовом, она разворачивается и результат
  обрабатывается, как форма верхнего уровня в том же режиме обработки
  (времени-компиляции или времени-некомпиляции, (compile-time-too или not-compile-time).

\item Если форма \cdf{progn} (или \cdf{locally}), каждая из форм из их тел
  обрабатываются, как формы верхнего уровня в том же режиме обработки.

\item Если форма \cdf{compiler-let}, \cdf{macrolet} или
  \cdf{symbol-macrolet}, компилятор файла создаёт соответствующие связывания и
  рекурсивно обрабатывает тела форм, как неявный \cdf{progn} верхнего уровня
  в контексте установленных связей в том же режиме обработки.

\item Если форма \cdf{eval-when}, она обрабатывается в соответствии со
  следующей таблицей:
  \begin{flushleft}
    \begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}c@{}cccl@{}}
      LT  &CT    &EX  &CTTM &Действие \\ \hlinesp
      да  & да   &--  & --  &    обработать тело в режиме время-компиляции \\
      да  & нет  &да  & да  &    обработать тело в режиме время-компиляции \\
      да  & нет  &--  & нет &    обработать тело в режиме время-некомпиляции \\
      да  & нет  &нет & --  &    обработать тело в режиме время-некомпиляции \\
      нет & да   &--  & --  &    выполнить тело \\
      нет & нет  &да  & да  &    выполнить тело \\
      нет & нет  &--  & нет &    ничего не делать \\
      нет & нет  &нет  & -- &    ничего не делать
    \end{tabular*}
  \end{flushleft}
  В этой таблице столбец LT спрашивает присутствует ли \cd{:load-toplevel} в
  ситуациях указанных в форме \cdf{eval-when}.
  CT соответственно указывает на \cd{:compile-toplevel} и EX на
  \cd{:execute}. Столбец CTTM спрашивает встречается ли форма \cdf{eval-when}
  в режиме времени-компиляции. Фраза <<обработка тела>> означает обработку
  последовательно форм тела, как неявного \cdf{progn} верхнего уровня в
  указанном режиме, и <<выполнение тела>> означает выполнение форм тела
  последовательно, как неявный \cdf{progn} в динамическом контексте
  выполнения компилятора и в лексическом окружении, в котором встретилась \cdf{eval-when}.

\item В противном случае, форма верхнего уровня, которая не представлена в
  специальных случаях. Если в режиме времени-компиляции, компилятор сначала
  выполняет форму и затем выполняет обычную обработку компилятором. Если
  установлен режим времени-некомпиляции, выполняется только обычная обработка
  компилятором (смотрите раздел~\ref{COMPILER-SECTION}).
  Любые подформы обрабатываются как формы не верхнего уровня.
\end{itemize}

Следует отметить, что формы верхнего уровня обрабатываются гарантированно в
порядке, в котором они были перечислены в тексте в файле, и каждая форма
верхнего уровня прочтённая компилятором обрабатывается перед тем, как будет
прочтена следующая.
Однако, порядок обработки (включая, в частности, раскрытие макросов) подформ,
которые не являются формами верхнего уровня, не определён.

Для формы \cdf{eval-when}, которая не является формой верхнего уровня в
компиляторе файлов (то есть либо в интерпретаторе, либо \cdf{compile}, либо в
компиляторе файлов, но не на верхнем уровне), если указана ситуация
\cd{:execute}, тело формы обрабатывается как неявный \cdf{progn}. В противном
случае, тело игнорируется и форма \cdf{eval-when} имеет значение \cdf{nil}.

Для сохранения обратной совместимости, \emph{situation} может также быть
\cdf{compile}, \cdf{load} или \cdf{eval}.
Внутри формы верхнего уровня \cdf{eval-when}, они имеют значения
\cd{:compile-toplevel}, \cd{:load-toplevel} и \cd{:execute} соответственно.
Однако их поведение не определено при использовании в \cdf{eval-when} не
верхнего уровня.

Следующие правила являются логическим продолжением предыдущих определений:

\begin{itemize}

\item Никогда не случится так, чтобы выполнение одного \cdf{eval-when}
  выражения приведёт к выполнению тела более чем один раз.

\item Старый ключевой символ \cd{eval} был неправильно использован, потому
  что выполнение тела не нуждается в \cd{eval}. Например, когда определение
  функции
  \begin{lisp}
    (defun foo () (eval-when (:execute) (print 'foo)))
  \end{lisp}
  скомпилируется,
  вызов \cdf{print} должен быть скомпилирован, а не выполнен во время
  компиляции.

\item Макросы, предназначенные для использования в качестве форм верхнего
  уровня, должны контролировать все побочные эффекты, которые будут сделаны
  формами в процессе развёртывания.
  Разворачиватель макроса сам по себе не должен порождать никаких побочных
  эффектов.
  
  \begin{lisp}
    (defmacro foo () \\*
    ~~(really-foo)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Неправильно}\\*
    ~~{\Xbq}(really-foo)) \\
    \\
    (defmacro foo () \\*
    ~~{\Xbq}(eval-when (:compile-toplevel \\*
    ~~~~~~~~~~~~~~~:load-toplevel :execute)~~~~~;\textrm{Правильно} \\*
    ~~~~(really-foo)))
  \end{lisp}
  Соблюдение этого правила будет значит, что такие макросы будут вести себя
  интуитивно понятно при вызовах в формах не верхнего уровня.

\item Расположение связывания переменной окружённой \cdf{eval-when}
  захватывает связывание, потому что режим <<время-компиляции>> не может
  случиться (потому что \cdf{eval-when} не может быть формой верхнего уровня)
  \begin{lisp}
    (let ((x 3)) \\*
    ~~(eval-when (:compile-toplevel :load-toplevel :execute) \\*
    ~~~~(print x)))
  \end{lisp}
  выведет 3 во время выполнения (в данном случае загрузки) и не будет ничего
  выводить во время компиляции. Разворачивание \cdf{defun} и \cdf{defmacro} может
  быть выполнено в контексте \cdf{eval-when} и могут корректно захватывать
  лексическое окружение.
  Например, реализация может разворачивать форму \cdf{defun}, такую как:
  \begin{lisp}
    (defun bar (x) (defun foo () (+ x 3)))
  \end{lisp}
  в
  \begin{lisp}
    (progn (eval-when (:compile-toplevel) \\*
    ~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
    ~~~~~~~(eval-when (:load-toplevel :execute) \\*
    ~~~~~~~~~(setf (symbol-function 'bar) \\*
    ~~~~~~~~~~~~~~~\#'(lambda (x) \\*
    ~~~~~~~~~~~~~~~~~~~(progn (eval-when (:compile-toplevel)  \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~(compiler::notice-function 'foo \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'())) \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~(eval-when (:load-toplevel :execute) \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
  \end{lisp}
  которая по предыдущим правилам будет обработана также, как и 
  \begin{lisp}
    (progn (eval-when (:compile-toplevel) \\*
    ~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
    ~~~~~~~(eval-when (:load-toplevel :execute) \\*
    ~~~~~~~~~(setf (symbol-function 'bar) \\*
    ~~~~~~~~~~~~~~~\#'(lambda (x) \\*
    ~~~~~~~~~~~~~~~~~~~(progn (eval-when (:load-toplevel :execute) \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
  \end{lisp}

\end{itemize}

Вот несколько дополнительных примеров.
\begin{lisp} 
  (let ((x 1)) \\*
  ~~(eval-when (:execute :load-toplevel :compile-toplevel) \\*
  ~~~~(setf (symbol-function 'foo1) \#'(lambda () x))))
\end{lisp}
\cdf{eval-when} в предыдущем выражении не является формой верхнего уровня, таким
образом во внимание берётся только ключевой символ \cd{:execute}. это не будет
иметь эффекта во время компиляции. Однако этот код установит
в \cd{(symbol-function 'foo1)} функцию которая возвращает \cd{1} во время
загрузки (если \cdf{let} форма верхнего уровня) или во время выполнения (если
форма \cdf{let} вложена в какую-либо другую форму, которая ещё не была
выполнена). 
\begin{lisp}
  (eval-when (:execute :load-toplevel :compile-toplevel) \\*
  ~~(let ((x 2)) \\*
  ~~~~(eval-when (:execute :load-toplevel :compile-toplevel) \\*
  ~~~~~~(setf (symbol-function 'foo2) \#'(lambda () x)))))
\end{lisp}
Если предыдущее выражение находилось на верхнем уровне в компилируемом файле, оно
будет выполнятся в обоих случаях, и во время компиляции и во время загрузки.

\begin{lisp}
  (eval-when (:execute :load-toplevel :compile-toplevel) \\*
  ~~(setf (symbol-function 'foo3) \#'(lambda () 3)))
\end{lisp}
Если предыдущее выражение находилось на верхнем уровне в компилируемом файле, оно
будет выполняться в обоих случаях, и во время компиляции и во время загрузки.

\begin{lisp}
  (eval-when (:compile-toplevel) \\*
  ~~(eval-when (:compile-toplevel)  \\*
  ~~~~(print 'foo4)))
\end{lisp}
Предыдущее выражение ничего не делает, оно просто возвращает \cdf{nil}.

\begin{lisp}
  (eval-when (:compile-toplevel)  \\*
  ~~(eval-when (:execute) \\*
  ~~~~(print 'foo5)))
\end{lisp}
Если предыдущее выражение находилось на верхнем уровне в компилируемом файле,
\cd{foo5} будет выведено во время компиляции. Если эта форма была не на верхнем
уровне, ничего не будет выведено во время компиляции. Вне зависимости от 
контекста, ничего не будет выведено во время загрузки или выполнения.

\begin{lisp}
  (eval-when (:execute :load-toplevel) \\*
  ~~(eval-when (:compile-toplevel) \\*
  ~~~~(print 'foo6)))
\end{lisp}
Если предыдущая форма находилась на верхнем уровне в компилируемом файле,
\cd{foo6} будет выведено во время компиляции. Если форма была не на верхнем
уровне, ничего не будет выведено во время компиляции. Вне зависимости от
контекста, ничего не будет выведение во время загрузки или выполнения кода.
\end{defspec}

\fi